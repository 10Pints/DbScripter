/*
Parameters:

--------------------------------------------------------------------------------
 Type            : Params
--------------------------------------------------------------------------------
 CreateMode      : Create
 Database        : Dorsu_dev
 DisplayLog      : True
 DisplayScript   : True
 IndividualFiles              : False
 Instance                     : 
 IsExprtngData                : False
 LogFile                      : D:\Dev\DbScripter\DbScripterLibTests\ExportTestCrtRtns_When_Expect_45\export crt tst rtns.log
 LogLevel                     : Info
 Name                         : ExportTestCrtRtns_When_Expect_45
 RequiredAssemblies           : System.Collections.Generic.List`1[System.String]
 RequiredSchemas              : System.Collections.Generic.List`1[System.String]
 RequiredFunctions            : System.Collections.Generic.List`1[System.String]
 RequiredProcedures           : System.Collections.Generic.List`1[System.String]
 RequiredTables               : System.Collections.Generic.List`1[System.String]
 RequiredViews                : System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedTypes     : System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedDataTypes : System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedTableTypes: System.Collections.Generic.List`1[System.String]
 Want All:                  : Assembly
 Want All:                  : Database
 Want All:                  : Function
 Want All:                  : Procedure
 Want All:                  : Schema
 Want All:                  : Table
 Want All:                  : View
 Want All:                  : UserDefinedType
 Want All:                  : UserDefinedDataType
 Want All:                  : UserDefinedTableType
 Script Dir                   : D:\Dev\DbScripter\DbScripterLibTests\ExportTestCrtRtns_When_Expect_45
 Script File                  : D:\Dev\DbScripter\DbScripterLibTests\ExportTestCrtRtns_When_Expect_45\Dorsu_ schema.sql
 ScriptUseDb                  : True
 Server                       : DevI9
 AddTimestamp                 : False
 Timestamp                    : 250720-0903

 RequiredSchemas : 1
	

*/

USE [Dorsu_dev]
GO

CREATE ASSEMBLY [RegEx]
FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C010300B1C625930000000000000000E00022200B0130000022000000080000000000007E40000000200000006000000000001000200000000200000400000000000000060000000000000000A0000000020000000000000300608500001000001000000000100000100000000000001000000000000000000000002A4000004F000000006000001C04000000000000000000000000000000000000008000000C000000883F0000380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E7465787400000084200000002000000022000000020000000000000000000000000000200000602E727372630000001C040000006000000006000000240000000000000000000000000000400000402E72656C6F6300000C0000000080000000020000002A000000000000000000000000000040000042000000000000000000000000000000005E400000000000004800000002000500242900006416000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001330020065000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1300000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281400000A281500000A2A000000133004007F000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1300000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281900000A281500000A2A00133002006A000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1A00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A6F1C00000A281D00000A2A00001330040084000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1A00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281E00000A6F1C00000A281D00000A2A133002006A000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A282000000A6F2100000A282200000A2A00001330040084000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001282300000A6F2100000A282200000A2A133003008F000000000000000F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A0F02FE16140000016F1100000A282400000A282200000A2A0013300500A9000000000000000F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A0F02FE16140000016F1100000AD01F000001281600000A05281700000A281800000AA51F000001282500000A282200000A2A0000001B3004001B010000010000110F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A0A066F1C00000A163E8C000000066F1C00000A8D1E0000010B160C066F2600000A13042B1C11046F2700000A7419000001130507082517580C11056F2100000AA211046F2800000A2DDBDE151104751A000001130611062C0711066F2900000ADC000F02FE16140000016F1100000A0713071107282A00000A0DDE161308720100007011086F2B00000A282C00000A0DDE0009282200000A2A7E1F00000A2A00011C000002009F0029C80015000000000000DE001AF800161B0000011B30040035010000020000110F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A05281700000A281800000AA51F000001281E00000A0A066F1C00000A163E8C000000066F1C00000A8D1E0000010B160D066F2600000A13042B1C11046F2700000A7419000001130507092517580D11056F2100000AA211046F2800000A2DDBDE151104751A000001130611062C0711066F2900000ADC000F02FE16140000016F1100000A0713071107282A00000A0CDE161308720100007011086F2B00000A282C00000A0CDE0008282200000A2A7E1F00000A2A000000011C00000200B90029E20015000000000000F8001A1201161B000001133002008A0000000000000002282D00000A2D03162B011703282D00000A2D03162B01186004282D00000A2D03162B011A6005282D00000A2D03162B011E600E04282D00000A2D03162B021F10600E05282D00000A2D03162B021F20600E06282D00000A2D03162B021F40600E07282D00000A2D03162B052000010000600E08282D00000A2D03162B05200002000060281D00000A2A0000133002005C000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D02142A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A2A1330040076000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D02142A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281E00000A2A0000133002003C000000030000110274190000010A03066F2E00000A281D00000A811600000104066F2F00000A281D00000A811600000105066F2100000A282200000A733000000A512A42534A4201000100000000000C00000076342E302E33303331390000000005006C00000034050000237E0000A0050000A805000023537472696E677300000000480B00001C00000023555300640B0000100000002347554944000000740B0000F00A000023426C6F620000000000000002000001471502000900000000FA0133001600000100000023000000020000000E0000002F000000300000001B0000000300000001000000030000000000EA020100000000000600DA01B70306004702B7030600F90085030F00D70300000600210116030600BD01160306008901160306002E0216030600FA01160306001302160306003801160306000D0198030600EB00980306006C01160306005301770206008304FF020A00A8014A030A0031004A030A000B03EE030A009102EE030E00A10503040A000100EE030E00280303040600650322040E00B802030406007E00FF0206003803FF020600720022040A005D04EE0306009D02FF020E00430403040600C300FF0206008A00FF0206000603FF020E00D0000304000000000A00000000000100010081011000A10500004100010001005020000000009600B002EF000100C4200000000096001505F80003005021000000009600D70403010600C8210000000096004C050C0108005822000000009600A40217010B00D022000000009600050520010D00602300000000960040002B011000FC23000000009600F30436011300B4240000000096006D042B011700F8250000000096003B0536011A005827000000009600350443011E00F027000000009600DA025A0127005828000000009600270563012900DC2800000000960083056E012C00000001006D05000002004203000001006D05000002004203000003005004000001006D05000002004203000001006D05000002004203000003004304000001006D05000002004203000001006D05000002004203000003004304000001006D0500000200420300000300BF04000001006D0500000200420300000300BF04000004004304000001006D05000002004203000003007A04000001006D0500000200420300000300730500000400430400000100D80000000200B90000000300C80000000400280000000500AE00000006004E00000007008A0400000800620500000900AE04000001006D05000002004203000001006D0500000200420300000300430400000100D602020002009B0502000300CF0202000400BE0209007F03010011007F03060019007F030A0029007F03100031007F03100039007F03100041007F03100049007F03100051007F03100059007F03100061007F03150069007F03100071007F03100079007F03100089007F030600A100F4021A0081009B021E00F100C40222009900FA022600A900B6022A0099009604300001019C003600B100A2043F00110181044500A900B6024D00B100FA025500A900E6035900B900E9042200B10096046000A900E6036600A100FA026F00A900B8027300190165021E00A10096047A00A900B8028000A90046008900A90046009000B9007103AC00C100CB04B100C1007A051A00D100E3000600F1007304B500D90066001E00F1006604BC0099006F02D5001901910522001901C4022200E9007F03E00020007B00C4022E000B007C012E00130085012E001B00A4012E002300AD012E002B00BB012E003300F3012E003B00F9012E004300AD012E004B0014022E005300F3012E005B00F3012E0063003F022E006B0069022E007300760240007B007D0360007B003A0480007B00F704A0007B00B805C0007B006F06E0007B002A0700017B00E30720017B00A00840017B00580960017B00140A80017B00CD0AA0017B00CD0A9900C200DB000480000001000000000000000000000000008B050000040000000000000000000000E6001F0000000000040000000000000000000000E600130000000000040000000000000000000000E600FF0200000000000000000053716C496E743332003C4D6F64756C653E0053797374656D2E44617461006D73636F726C696200436F6D70696C656400446174614163636573734B696E640052656765785F5265706C6163650049676E6F72655061747465726E57686974657370616365006765745F4D6573736167650049456E756D657261626C650049446973706F7361626C650052756E74696D655479706548616E646C65004765745479706546726F6D48616E646C650053696E676C654C696E65004D756C74694C696E650054797065004578706C69636974436170747572650049676E6F72654361736500446973706F736500477569644174747269627574650044656275676761626C6541747472696275746500436F6D56697369626C6541747472696275746500417373656D626C795469746C6541747472696275746500417373656D626C7954726164656D61726B417474726962757465005461726765744672616D65776F726B41747472696275746500417373656D626C7946696C6556657273696F6E41747472696275746500417373656D626C79436F6E66696775726174696F6E4174747269627574650053716C46756E6374696F6E41747472696275746500417373656D626C794465736372697074696F6E41747472696275746500436F6D70696C6174696F6E52656C61786174696F6E7341747472696275746500417373656D626C7950726F6475637441747472696275746500417373656D626C79436F7079726967687441747472696275746500417373656D626C79436F6D70616E794174747269627574650052756E74696D65436F6D7061746962696C697479417474726962757465006765745F56616C7565006F705F547275650053797374656D2E52756E74696D652E56657273696F6E696E670053716C537472696E6700546F537472696E670052656765785F4D617463680052656765785F49734D61746368006D61746368006765745F4C656E677468006C656E677468006F626A0052656765785F4D617463685F416C6C0052656745782E646C6C006765745F49734E756C6C0053797374656D00456E756D0053716C426F6F6C65616E0053797374656D2E5265666C656374696F6E004D61746368436F6C6C656374696F6E00457863657074696F6E007061747465726E004D6963726F736F66742E53716C5365727665722E5365727665720049456E756D657261746F7200476574456E756D657261746F72002E63746F720053797374656D2E446961676E6F73746963730053797374656D2E52756E74696D652E496E7465726F7053657276696365730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F646573004D6174636865730053797374656D2E446174612E53716C54797065730053797374656D2E546578742E526567756C617245787072657373696F6E730053797374656D2E436F6C6C656374696F6E730052656765785F4F7074696F6E730052656765784F7074696F6E730072656765784F7074696F6E730053716C436861727300436F6E6361740052656765785F466F726D617400666F726D617400546F4F626A656374005269676874546F4C656674006F705F496D706C69636974006F705F4578706C696369740043756C74757265496E76617269616E74007265706C6163656D656E74006765745F43757272656E740052656765785F4D617463685F436F756E74006765745F436F756E740052656765785F5265706C6163655F4F70740052656765785F4D617463685F4F70740052656765785F49734D617463685F4F70740052656765785F4D617463685F416C6C5F4F70740052656765785F466F726D61745F4F70740052656765785F4D617463685F436F756E745F4F70740045434D4153637269707400696E707574006F7574707574004D6F76654E6578740046696C6C526F77005265674578006765745F496E64657800696E6465780052656765780000001745007800630065007000740069006F006E003A00200000000000CA0849E65B60614FBB66A50C49F81C3400042001010803200001052001011111042001010E0420010102032000020320000E032000080306114D050002020E0E050001114D020800011280811180850500010811590700021C12808108070003020E0E117D03061159060002125D0E0E050001115908080003125D0E0E117D0306115106000212650E0E05000111510E08000312650E0E117D0600030E0E0E0E0800040E0E0E0E117D120709125D1D0E080E1261126512691D1C126D04200012610320001C0600020E0E1D1C0500020E0E0E120709125D1D0E0E081261126512691D1C126D05000102114D040701126505200101115108B77A5C561934E089080002114D115111510A0003114D1151115111590800021159115111510A000311591151115111590800021151115111510A000311511151115111590A000311511151115111510C0004115111511151115111591600091159114D114D114D114D114D114D114D114D114D0800021271115111510A000312711151115111590D0004011C1011591011591012750801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F7773010801000200000000000D01000853514C5265676578000037010032526567756C61722045787072657373696F6E732073616D706C6520617373656D626C7920666F722053514C2053657276657200000501000000001A0100154D6963726F736F667420436F72706F726174696F6E00002A010025436F7079726967687420C2A92032303232204D6963726F736F667420436F72706F7261746500002901002439316233393038372D636434382D343633622D613838632D63346566323038303464623400000C010007312E302E302E3000004D01001C2E4E45544672616D65776F726B2C56657273696F6E3D76342E372E320100540E144672616D65776F726B446973706C61794E616D65142E4E4554204672616D65776F726B20342E372E3280B701000300540E044E616D650D52656765785F49734D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F49734D617463685F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F4D617463685F436F756E745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BF01000300540E044E616D651552656765785F4D617463685F436F756E745F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B501000300540E044E616D650B52656765785F4D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B901000300540E044E616D650F52656765785F4D617463685F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B701000300540E044E616D650D52656765785F5265706C6163655455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F5265706C6163655F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B601000300540E044E616D650C52656765785F466F726D61745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BA01000300540E044E616D651052656765785F466F726D61745F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B701000300540E044E616D650D52656765785F4F7074696F6E735455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E6973746963002001000100540E1146696C6C526F774D6574686F644E616D650746696C6C526F770000000000004A84A98800000000020000006A000000C03F0000C02100000000000000000000000000001000000000000000000000000000000052534453AC0D2DF91B817E4284EDEAC96F1DA1BE01000000443A5C4465765C53514C5F434C525C53514C5F434C525F362E305F646F6E745F776F726B5F696E5F73716C5F7365727665725C53716C52656745785C6F626A5C52656C656173655C52656745782E706462005240000000000000000000006C4000000020000000000000000000000000000000000000000000005E400000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C00000000000000FF2500200010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058600000C00300000000000000000000C00334000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE00000100000001000000000000000100000000003F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B00420030000010053007400720069006E006700460069006C00650049006E0066006F000000FC02000001003000300030003000300034006200300000007E003300010043006F006D006D0065006E0074007300000052006500670075006C00610072002000450078007000720065007300730069006F006E0073002000730061006D0070006C006500200061007300730065006D0062006C007900200066006F0072002000530051004C002000530065007200760065007200000000004C001600010043006F006D00700061006E0079004E0061006D006500000000004D006900630072006F0073006F0066007400200043006F00720070006F0072006100740069006F006E0000003A0009000100460069006C0065004400650073006300720069007000740069006F006E0000000000530051004C005200650067006500780000000000300008000100460069006C006500560065007200730069006F006E000000000031002E0030002E0030002E003000000034000A00010049006E007400650072006E0061006C004E0061006D0065000000520065006700450078002E0064006C006C0000006E00250001004C006500670061006C0043006F007000790072006900670068007400000043006F0070007900720069006700680074002000A9002000320030003200320020004D006900630072006F0073006F0066007400200043006F00720070006F007200610074006500000000002A00010001004C006500670061006C00540072006100640065006D00610072006B00730000000000000000003C000A0001004F0072006900670069006E0061006C00460069006C0065006E0061006D0065000000520065006700450078002E0064006C006C000000320009000100500072006F0064007500630074004E0061006D00650000000000530051004C005200650067006500780000000000340008000100500072006F006400750063007400560065007200730069006F006E00000031002E0030002E0030002E003000000038000800010041007300730065006D0062006C0079002000560065007200730069006F006E00000031002E0030002E0030002E00300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000C000000803000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
WITH PERMISSION_SET = SAFE

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




-- ===============================================================
-- Author:      Terry Watts
-- Create date: 08-JAN-2020
-- Description: fnLen deals with the trailing spaces bug in Len
-- ===============================================================
CREATE  FUNCTION [dbo].[fnLen]( @v VARCHAR(8000))
RETURNS INT
AS
BEGIN
   RETURN CASE
            WHEN @v IS NULL THEN 0
            ELSE Len(@v+'x')-1
            END;
END
/*
EXEC test.sp__crt_tst_rtns 'dbo].[fnLen]', 43;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




-- ==========================================================================
-- Author:      Terry Watts
-- Create date: 08-JAN-2020
-- Description: Removes specific characters from the right end of a string
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ==========================================================================
CREATE FUNCTION [dbo].[fnRTrim]
(
   @s VARCHAR(MAX)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE  
       @tcs    VARCHAR(20)

   IF (@s IS NULL ) OR (LEN(@s) = 0)
      RETURN @s;

   SET @tcs = CONCAT( NCHAR(9), NCHAR(10), NCHAR(13), NCHAR(32), NCHAR(160))

   WHILE CHARINDEX(Right(@s, 1) , @tcs) > 0 AND dbo.fnLen(@s) > 0 -- SUBSTRING(@s,  dbo.fnLen(@s)-1, 1) or Right(@s, 1)
      SET @s = SUBSTRING(@s, 1, dbo.fnLen(@s)-1); -- SUBSTRING(@s, 1, dbo.fnLen(@s)-1) or Left(@s, dbo.fnLen(@s)-1)

   RETURN @s;
END




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




-- ================================================================
-- Author:      Terry Watts
-- Create date: 23-JUN-2023
-- Description: Removes specific characters from 
--              the beginning of a string
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ==================================================================
CREATE FUNCTION [dbo].[fnLTrim]
(
    @s VARCHAR(MAX)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE  
       @tcs    VARCHAR(20)

   IF (@s IS NULL ) OR (dbo.fnLen(@s) = 0)
      RETURN @s;

   SET @tcs = CONCAT( NCHAR(9), NCHAR(10), NCHAR(13), NCHAR(32), NCHAR(160))

   WHILE CHARINDEX(SUBSTRING(@s, 1, 1), @tcs) > 0 AND dbo.fnLen(@s) > 0
      SET @s = SUBSTRING(@s, 2, dbo.fnLen(@s)-1);

   RETURN @s;
END
/*
PRINT CONCAT('[', fnTrim(' '), ']')
PRINT CONCAT('[', fnLTrim(' '), ']')
PRINT CONCAT('[', fnLTrim2(' ', ' '), ']')
PRINT CONCAT('[', fnLTrim(CONCAT(0x20, 0x09, 0x0a, 0x0d, 0x20,'a', 0x20, 0x09, 0x0a, 0x0d, 0x20,' #cd# ')), ']');
*/




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ================================================================
-- Author:      Terry Watts
-- Create date: 10-OCT-2019
-- Description: Trims leading and trailing whitesace including the 
--                normally untrimmable CHAR(160)
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ================================================================
CREATE FUNCTION [dbo].[fnTrim]( @s VARCHAR(4000)
)
RETURNS VARCHAR(4000)
AS
BEGIN
  RETURN dbo.fnRTrim( dbo.fnLTrim(@s));
END
/*
PRINT CONCAT('[', dbo.fnTrim(CONCAT(0x20, 0x09, 0x0a, 0x0d, 0xA0, '  a  #cd# ', 0x20, 0x09, 0x0a, 0x0d, 0x0d,0xA0)), ']');
*/




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




-- =============================================    
-- Author:      Terry Watts
-- Create date: 23-JUN-2023
-- Description: Pads Right with specified padding character
-- =============================================    
CREATE FUNCTION [dbo].[fnPadRight2]
(
    @s      VARCHAR(MAX)
   ,@width  INT
   ,@pad    VARCHAR(1)
)
RETURNS VARCHAR (1000)
AS
BEGIN
   DECLARE 
      @ret  VARCHAR(1000)
     ,@len  INT

   IF @s IS null
      SET @s = '';

   SET @len = ut.dbo.fnLen(@s)
   RETURN LEFT( CONCAT( @s, REPLICATE( @pad, @width-@len)), @width)
END
/*
SELECT CONCAT('[', dbo.fnPadRight2('a very long string indeed - its about time we had a beer', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadRight2('', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadRight2(NULL, 25, '.'), ']  ');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- =============================================    
-- Author:  Terry Watts
-- Create date: 04-OCT-2019
-- Description: Pads Right
-- =============================================    
CREATE FUNCTION [dbo].[fnPadRight]( @s VARCHAR(500), @width INT)
RETURNS VARCHAR (1000)
AS
BEGIN
   RETURN dbo.fnPadRight2( @s, @width, ' ' )
END
/*
SELECT CONCAT(', ]', dbo.fnPadRight([name], 25), ']  ', [type])
FROM [tg].[test].[fnCrtPrmMap]( '          @table_nm                  VARCHAR(50)  
         ,@folder                    VARCHAR(260)  
         ,@workbook_nm               VARCHAR(260)   OUTPUT  
         ,@sheet_nm                  VARCHAR(50)    OUTPUT  
         ,@view_nm                   VARCHAR(50)    OUTPUT  
         ,@error_msg                 VARCHAR(200)   OUTPUT  ')
*/




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 25-NOV-2023
-- Description: returns the log level key
-- =============================================
CREATE FUNCTION [dbo].[fnGetLogLevelKey] ()
RETURNS NVARCHAR(50)
AS
BEGIN
   RETURN N'LOG_LEVEL';
END
/*
EXEC test.sp_crt_tst_rtns 'dbo.fnGetLogLevelKey', 
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- ===============================================================
-- Author:      Terry Watts
-- Create date: 25-MAY-2020
-- Description: Get session context as int - default = -1
-- RETURNS      if    key/value present returns value as INT
--              if no key/value present returns NULL
--
-- See Also: fnGetSessionContextAsString, sp_set_session_context
--
-- CHANGES:
-- 14-JUL-2023: default = -1 (not found) was 0 before
-- 06-FEB-2024: simply returns value if key found else NULL
-- ===============================================================
CREATE FUNCTION [dbo].[fnGetSessionContextAsInt](@key NVARCHAR(100))
RETURNS INT
BEGIN
   RETURN CONVERT(INT, SESSION_CONTEXT(@key));
END
/*
PRINT CONCAT('[',dbo.fnGetSessionContextAsInt(N'cor_id'),']')
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 25-NOV-2023
-- Description: returns the log level
-- =============================================
CREATE FUNCTION [dbo].[fnGetLogLevel]()
RETURNS INT
AS
BEGIN
   RETURN dbo.fnGetSessionContextAsInt(dbo.fnGetLogLevelKey());
END
/*
EXEC test.sp_crt_tst_rtns 'dbo.fnGetLogLevel', 80;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[AppLog](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[timestamp] [varchar](30) NOT NULL,
	[schema_nm] [varbinary](20) NULL,
	[rtn] [varchar](60) NULL,
	[hit] [int] NULL,
	[log] [varchar](max) NULL,
	[msg] [varchar](max) NULL,
	[level] [int] NULL,
	[row_count] [int] NULL,
 CONSTRAINT [PK_AppLog] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

ALTER TABLE [dbo].[AppLog] ADD  CONSTRAINT [DF_AppLog_timestamp]  DEFAULT (getdate()) FOR [timestamp]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- =========================================================================
-- Author:      Terry Watts
-- Create date: 22-MAR-2020
-- Description: Logs to output and to the AppLog table

-- Level: 0 DEBUG
--        1 INFO
--        2 NOTE
--        3 WARNING (CONTINUE)
--        4 ERROR   (STOP)
--
-- Changes:
-- 231014: Added support of table logging: add a row to table for each log 
--            Level and msg
-- 231016: Added fn and optional row count columns
-- 231017: @fn no longer needs the trailing ' :'
-- 231018: @fn, @row_count are stored as separate fields
-- 231115: added Level
-- 231116: always append to the AppLog table - bit print is conditional on level
-- 240309: Trimmed the  @fn paameter as it is left padded
-- 240314: Logic Change: now if less than min log level do not log or print msg
-- 231221: added hold, values:
--          0: print cache first then this msg on same line immediatly
--          1: cache msg for later - dont print it now 
--          2: dump cache first then print this msg on a new line immediatly
-- 240422: separate lines into a separate display line if msg contains \r\n
-- =================================================================================
CREATE PROCEDURE [dbo].[sp_log]
 @level  INT = 1
,@fn     VARCHAR(45)=NULL
,@msg00  VARCHAR(MAX)=NULL,@msg01  VARCHAR(MAX)=NULL,@msg02  VARCHAR(MAX)=NULL,@msg03  VARCHAR(MAX)=NULL,@msg04  VARCHAR(MAX)=NULL,@msg05  VARCHAR(MAX)=NULL,@msg06  VARCHAR(MAX)=NULL,@msg07  VARCHAR(MAX)=NULL,@msg08  VARCHAR(MAX)=NULL,@msg09  VARCHAR(MAX)=NULL
,@msg10  VARCHAR(MAX)=NULL,@msg11  VARCHAR(MAX)=NULL,@msg12  VARCHAR(MAX)=NULL,@msg13  VARCHAR(MAX)=NULL,@msg14  VARCHAR(MAX)=NULL,@msg15  VARCHAR(MAX)=NULL,@msg16  VARCHAR(MAX)=NULL,@msg17  VARCHAR(MAX)=NULL,@msg18  VARCHAR(MAX)=NULL,@msg19  VARCHAR(MAX)=NULL
,@msg20  VARCHAR(MAX)=NULL,@msg21  VARCHAR(MAX)=NULL,@msg22  VARCHAR(MAX)=NULL,@msg23  VARCHAR(MAX)=NULL,@msg24  VARCHAR(MAX)=NULL,@msg25  VARCHAR(MAX)=NULL,@msg26  VARCHAR(MAX)=NULL,@msg27  VARCHAR(MAX)=NULL,@msg28  VARCHAR(MAX)=NULL,@msg29  VARCHAR(MAX)=NULL
,@msg30  VARCHAR(MAX)=NULL,@msg31  VARCHAR(MAX)=NULL,@msg32  VARCHAR(MAX)=NULL,@msg33  VARCHAR(MAX)=NULL,@msg34  VARCHAR(MAX)=NULL,@msg35  VARCHAR(MAX)=NULL,@msg36  VARCHAR(MAX)=NULL,@msg37  VARCHAR(MAX)=NULL,@msg38  VARCHAR(MAX)=NULL,@msg39  VARCHAR(MAX)=NULL
,@msg40  VARCHAR(MAX)=NULL,@msg41  VARCHAR(MAX)=NULL,@msg42  VARCHAR(MAX)=NULL,@msg43  VARCHAR(MAX)=NULL,@msg44  VARCHAR(MAX)=NULL,@msg45  VARCHAR(MAX)=NULL,@msg46  VARCHAR(MAX)=NULL,@msg47  VARCHAR(MAX)=NULL,@msg48  VARCHAR(MAX)=NULL,@msg49  VARCHAR(MAX)=NULL
,@msg50  VARCHAR(MAX)=NULL,@msg51  VARCHAR(MAX)=NULL,@msg52  VARCHAR(MAX)=NULL,@msg53  VARCHAR(MAX)=NULL,@msg54  VARCHAR(MAX)=NULL,@msg55  VARCHAR(MAX)=NULL,@msg56  VARCHAR(MAX)=NULL,@msg57  VARCHAR(MAX)=NULL,@msg58  VARCHAR(MAX)=NULL,@msg59  VARCHAR(MAX)=NULL
,@msg60  VARCHAR(MAX)=NULL,@msg61  VARCHAR(MAX)=NULL,@msg62  VARCHAR(MAX)=NULL,@msg63  VARCHAR(MAX)=NULL,@msg64  VARCHAR(MAX)=NULL,@msg65  VARCHAR(MAX)=NULL,@msg66  VARCHAR(MAX)=NULL,@msg67  VARCHAR(MAX)=NULL,@msg68  VARCHAR(MAX)=NULL,@msg69  VARCHAR(MAX)=NULL
,@msg70  VARCHAR(MAX)=NULL,@msg71  VARCHAR(MAX)=NULL,@msg72  VARCHAR(MAX)=NULL,@msg73  VARCHAR(MAX)=NULL,@msg74  VARCHAR(MAX)=NULL,@msg75  VARCHAR(MAX)=NULL,@msg76  VARCHAR(MAX)=NULL,@msg77  VARCHAR(MAX)=NULL,@msg78  VARCHAR(MAX)=NULL,@msg79  VARCHAR(MAX)=NULL
,@msg80  VARCHAR(MAX)=NULL,@msg81  VARCHAR(MAX)=NULL,@msg82  VARCHAR(MAX)=NULL,@msg83  VARCHAR(MAX)=NULL,@msg84  VARCHAR(MAX)=NULL,@msg85  VARCHAR(MAX)=NULL,@msg86  VARCHAR(MAX)=NULL,@msg87  VARCHAR(MAX)=NULL,@msg88  VARCHAR(MAX)=NULL,@msg89  VARCHAR(MAX)=NULL
,@msg90  VARCHAR(MAX)=NULL,@msg91  VARCHAR(MAX)=NULL,@msg92  VARCHAR(MAX)=NULL,@msg93  VARCHAR(MAX)=NULL,@msg94  VARCHAR(MAX)=NULL,@msg95  VARCHAR(MAX)=NULL,@msg96  VARCHAR(MAX)=NULL,@msg97  VARCHAR(MAX)=NULL,@msg98  VARCHAR(MAX)=NULL,@msg99  VARCHAR(MAX)=NULL
,@msg100 VARCHAR(MAX)=NULL,@msg101 VARCHAR(MAX)=NULL,@msg102 VARCHAR(MAX)=NULL,@msg103 VARCHAR(MAX)=NULL,@msg104 VARCHAR(MAX)=NULL,@msg105 VARCHAR(MAX)=NULL,@msg106 VARCHAR(MAX)=NULL,@msg107 VARCHAR(MAX)=NULL,@msg108 VARCHAR(MAX)=NULL,@msg109 VARCHAR(MAX)=NULL
,@msg110 VARCHAR(MAX)=NULL,@msg111 VARCHAR(MAX)=NULL,@msg112 VARCHAR(MAX)=NULL,@msg113 VARCHAR(MAX)=NULL,@msg114 VARCHAR(MAX)=NULL,@msg115 VARCHAR(MAX)=NULL,@msg116 VARCHAR(MAX)=NULL,@msg117 VARCHAR(MAX)=NULL,@msg118 VARCHAR(MAX)=NULL,@msg119 VARCHAR(MAX)=NULL
,@msg120 VARCHAR(MAX)=NULL,@msg121 VARCHAR(MAX)=NULL,@msg122 VARCHAR(MAX)=NULL,@msg123 VARCHAR(MAX)=NULL,@msg124 VARCHAR(MAX)=NULL,@msg125 VARCHAR(MAX)=NULL,@msg126 VARCHAR(MAX)=NULL,@msg127 VARCHAR(MAX)=NULL,@msg128 VARCHAR(MAX)=NULL,@msg129 VARCHAR(MAX)=NULL
,@msg130 VARCHAR(MAX)=NULL,@msg131 VARCHAR(MAX)=NULL,@msg132 VARCHAR(MAX)=NULL,@msg133 VARCHAR(MAX)=NULL,@msg134 VARCHAR(MAX)=NULL,@msg135 VARCHAR(MAX)=NULL,@msg136 VARCHAR(MAX)=NULL,@msg137 VARCHAR(MAX)=NULL,@msg138 VARCHAR(MAX)=NULL,@msg139 VARCHAR(MAX)=NULL
,@msg140 VARCHAR(MAX)=NULL,@msg141 VARCHAR(MAX)=NULL,@msg142 VARCHAR(MAX)=NULL,@msg143 VARCHAR(MAX)=NULL,@msg144 VARCHAR(MAX)=NULL,@msg145 VARCHAR(MAX)=NULL,@msg146 VARCHAR(MAX)=NULL,@msg147 VARCHAR(MAX)=NULL,@msg148 VARCHAR(MAX)=NULL,@msg149 VARCHAR(MAX)=NULL
,@msg150 VARCHAR(MAX)=NULL,@msg151 VARCHAR(MAX)=NULL,@msg152 VARCHAR(MAX)=NULL,@msg153 VARCHAR(MAX)=NULL,@msg154 VARCHAR(MAX)=NULL,@msg155 VARCHAR(MAX)=NULL,@msg156 VARCHAR(MAX)=NULL,@msg157 VARCHAR(MAX)=NULL,@msg158 VARCHAR(MAX)=NULL,@msg159 VARCHAR(MAX)=NULL
,@msg160 VARCHAR(MAX)=NULL,@msg161 VARCHAR(MAX)=NULL,@msg162 VARCHAR(MAX)=NULL,@msg163 VARCHAR(MAX)=NULL,@msg164 VARCHAR(MAX)=NULL,@msg165 VARCHAR(MAX)=NULL,@msg166 VARCHAR(MAX)=NULL,@msg167 VARCHAR(MAX)=NULL,@msg168 VARCHAR(MAX)=NULL,@msg169 VARCHAR(MAX)=NULL
,@msg170 VARCHAR(MAX)=NULL,@msg171 VARCHAR(MAX)=NULL,@msg172 VARCHAR(MAX)=NULL,@msg173 VARCHAR(MAX)=NULL,@msg174 VARCHAR(MAX)=NULL,@msg175 VARCHAR(MAX)=NULL,@msg176 VARCHAR(MAX)=NULL,@msg177 VARCHAR(MAX)=NULL,@msg178 VARCHAR(MAX)=NULL,@msg179 VARCHAR(MAX)=NULL
,@msg180 VARCHAR(MAX)=NULL,@msg181 VARCHAR(MAX)=NULL,@msg182 VARCHAR(MAX)=NULL,@msg183 VARCHAR(MAX)=NULL,@msg184 VARCHAR(MAX)=NULL,@msg185 VARCHAR(MAX)=NULL,@msg186 VARCHAR(MAX)=NULL,@msg187 VARCHAR(MAX)=NULL,@msg188 VARCHAR(MAX)=NULL,@msg189 VARCHAR(MAX)=NULL
,@msg190 VARCHAR(MAX)=NULL,@msg191 VARCHAR(MAX)=NULL,@msg192 VARCHAR(MAX)=NULL,@msg193 VARCHAR(MAX)=NULL,@msg194 VARCHAR(MAX)=NULL,@msg195 VARCHAR(MAX)=NULL,@msg196 VARCHAR(MAX)=NULL,@msg197 VARCHAR(MAX)=NULL,@msg198 VARCHAR(MAX)=NULL,@msg199 VARCHAR(MAX)=NULL
,@msg200 VARCHAR(MAX)=NULL,@msg201 VARCHAR(MAX)=NULL,@msg202 VARCHAR(MAX)=NULL,@msg203 VARCHAR(MAX)=NULL,@msg204 VARCHAR(MAX)=NULL,@msg205 VARCHAR(MAX)=NULL,@msg206 VARCHAR(MAX)=NULL,@msg207 VARCHAR(MAX)=NULL,@msg208 VARCHAR(MAX)=NULL,@msg209 VARCHAR(MAX)=NULL
,@msg210 VARCHAR(MAX)=NULL,@msg211 VARCHAR(MAX)=NULL,@msg212 VARCHAR(MAX)=NULL,@msg213 VARCHAR(MAX)=NULL,@msg214 VARCHAR(MAX)=NULL,@msg215 VARCHAR(MAX)=NULL,@msg216 VARCHAR(MAX)=NULL,@msg217 VARCHAR(MAX)=NULL,@msg218 VARCHAR(MAX)=NULL,@msg219 VARCHAR(MAX)=NULL
,@msg220 VARCHAR(MAX)=NULL,@msg221 VARCHAR(MAX)=NULL,@msg222 VARCHAR(MAX)=NULL,@msg223 VARCHAR(MAX)=NULL,@msg224 VARCHAR(MAX)=NULL,@msg225 VARCHAR(MAX)=NULL,@msg226 VARCHAR(MAX)=NULL,@msg227 VARCHAR(MAX)=NULL,@msg228 VARCHAR(MAX)=NULL,@msg229 VARCHAR(MAX)=NULL
,@msg230 VARCHAR(MAX)=NULL,@msg231 VARCHAR(MAX)=NULL,@msg232 VARCHAR(MAX)=NULL,@msg233 VARCHAR(MAX)=NULL,@msg234 VARCHAR(MAX)=NULL,@msg235 VARCHAR(MAX)=NULL,@msg236 VARCHAR(MAX)=NULL,@msg237 VARCHAR(MAX)=NULL,@msg238 VARCHAR(MAX)=NULL,@msg239 VARCHAR(MAX)=NULL
,@msg240 VARCHAR(MAX)=NULL,@msg241 VARCHAR(MAX)=NULL,@msg242 VARCHAR(MAX)=NULL,@msg243 VARCHAR(MAX)=NULL,@msg244 VARCHAR(MAX)=NULL,@msg245 VARCHAR(MAX)=NULL,@msg246 VARCHAR(MAX)=NULL,@msg247 VARCHAR(MAX)=NULL,@msg248 VARCHAR(MAX)=NULL,@msg249 VARCHAR(MAX)=NULL
,@row_count INT = NULL
,@short_msg BIT = 0
AS
BEGIN
   DECLARE
       @fnThis          VARCHAR(35) = 'sp_log'
      ,@min_log_level   INT
      ,@lvl_msg         VARCHAR(MAX)
      ,@log_msg         VARCHAR(4000)
      ,@display_msg     VARCHAR(4000)
      ,@row_count_str   VARCHAR(30) = NULL

   SET NOCOUNT ON
   SET @min_log_level = COALESCE(dbo.fnGetLogLevel(), 1); -- Default: INFO

   SET @lvl_msg = 
   CASE
      WHEN @level = 0 THEN 'DEBUG'
      WHEN @level = 1 THEN 'INFO '
      WHEN @level = 2 THEN 'NOTE '
      WHEN @level = 3 THEN 'WARN '
      WHEN @level = 4 THEN 'ERROR'
      ELSE '???? '
   END;

   SET @fn= dbo.fnPadRight(@fn, 45);

   IF @row_count IS NOT NULL SET @row_count_str = CONCAT(' rowcount: ', @row_count)

   SET @log_msg = CONCAT
   (
       @msg00 ,@msg01 ,@msg02 ,@msg03, @msg04, @msg05, @msg06 ,@msg07 ,@msg08 ,@msg09 
      ,@msg10 ,@msg11 ,@msg12 ,@msg13, @msg14, @msg15, @msg16 ,@msg17 ,@msg18 ,@msg19
      ,@msg20 ,@msg21 ,@msg22 ,@msg23, @msg24, @msg25, @msg26 ,@msg27 ,@msg28 ,@msg29
      ,@msg30 ,@msg31 ,@msg32 ,@msg33, @msg34, @msg35, @msg36 ,@msg37 ,@msg38 ,@msg39
      ,@msg40 ,@msg41 ,@msg42 ,@msg43, @msg44, @msg45, @msg46 ,@msg47 ,@msg48 ,@msg49
      ,@msg50 ,@msg51 ,@msg52 ,@msg53, @msg54, @msg55, @msg56 ,@msg57 ,@msg58 ,@msg59
      ,@msg60 ,@msg61 ,@msg62 ,@msg63, @msg64, @msg65, @msg66 ,@msg67 ,@msg68 ,@msg69
      ,@msg70 ,@msg71 ,@msg72 ,@msg73, @msg74, @msg75, @msg76 ,@msg77 ,@msg78 ,@msg79
      ,@msg80 ,@msg81 ,@msg82 ,@msg83, @msg84, @msg85, @msg86 ,@msg87 ,@msg88 ,@msg89
      ,@msg90 ,@msg91 ,@msg92 ,@msg93, @msg94, @msg95, @msg96 ,@msg97 ,@msg98 ,@msg99
      ,@msg100,@msg101,@msg102,@msg103,@msg104,@msg105,@msg106,@msg107,@msg108,@msg109 
      ,@msg110,@msg111,@msg112,@msg113,@msg114,@msg115,@msg116,@msg117,@msg118,@msg119 
      ,@msg120,@msg121,@msg122,@msg123,@msg124,@msg125,@msg126,@msg127,@msg128,@msg129 
      ,@msg130,@msg131,@msg132,@msg133,@msg134,@msg135,@msg136,@msg137,@msg138,@msg139 
      ,@msg140,@msg141,@msg142,@msg143,@msg144,@msg145,@msg146,@msg147,@msg148,@msg149 
      ,@msg150,@msg151,@msg152,@msg153,@msg154,@msg155,@msg156,@msg157,@msg158,@msg159 
      ,@msg160,@msg161,@msg162,@msg163,@msg164,@msg165,@msg166,@msg167,@msg168,@msg169 
      ,@msg170,@msg171,@msg172,@msg173,@msg174,@msg175,@msg176,@msg177,@msg178,@msg179 
      ,@msg180,@msg181,@msg182,@msg183,@msg184,@msg185,@msg186,@msg187,@msg188,@msg189 
      ,@msg190,@msg191,@msg192,@msg193,@msg194,@msg195,@msg196,@msg197,@msg198,@msg199 
      ,@msg200,@msg201,@msg202,@msg203,@msg204,@msg205,@msg206,@msg207,@msg208,@msg209 
      ,@msg210,@msg211,@msg212,@msg213,@msg214,@msg215,@msg216,@msg217,@msg218,@msg219 
      ,@msg220,@msg221,@msg222,@msg223,@msg224,@msg225,@msg226,@msg227,@msg228,@msg229 
      ,@msg230,@msg231,@msg232,@msg233,@msg234,@msg235,@msg236,@msg237,@msg238,@msg239 
      ,@msg240,@msg241,@msg242,@msg243,@msg244,@msg245,@msg246,@msg247,@msg248,@msg249 
      ,@row_count_str
   );

   -- Always log to log table
   INSERT INTO AppLog (rtn, msg, [level], row_count)
   VALUES (dbo.fnTrim(@fn), @log_msg, @level, @row_count);

   -- Only display if required
   IF @level >= @min_log_level
   BEGIN
      IF @short_msg = 0
         SET @display_msg =  CONCAT(@lvl_msg, ' ',@fn, ': ', @log_msg);
      ELSE
         SET @display_msg =  CONCAT(@lvl_msg, ' ', @log_msg);

      PRINT @display_msg;
   END
END
/*
EXEC tSQLt.RunAll;
SELECT * From AppLog
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ============================================================
-- Author:      Terry Watts
-- Create date: 19-JUL-2025
-- Description: Aggregates messages and separates with a space
-- Design:      
-- Tests:       
-- ============================================================
CREATE FUNCTION [dbo].[fnAggregateMsgs]
(
    @msg0  VARCHAR(MAX) = NULL,
    @msg1  VARCHAR(MAX) = NULL,
    @msg2  VARCHAR(MAX) = NULL,
    @msg3  VARCHAR(MAX) = NULL,
    @msg4  VARCHAR(MAX) = NULL,
    @msg5  VARCHAR(MAX) = NULL,
    @msg6  VARCHAR(MAX) = NULL,
    @msg7  VARCHAR(MAX) = NULL,
    @msg8  VARCHAR(MAX) = NULL,
    @msg9  VARCHAR(MAX) = NULL,
    @msg10 VARCHAR(MAX) = NULL,
    @msg11 VARCHAR(MAX) = NULL,
    @msg12 VARCHAR(MAX) = NULL,
    @msg13 VARCHAR(MAX) = NULL,
    @msg14 VARCHAR(MAX) = NULL,
    @msg15 VARCHAR(MAX) = NULL,
    @msg16 VARCHAR(MAX) = NULL,
    @msg17 VARCHAR(MAX) = NULL,
    @msg18 VARCHAR(MAX) = NULL,
    @msg19 VARCHAR(MAX) = NULL
)
RETURNS VARCHAR(MAX)
AS
BEGIN
    DECLARE @result VARCHAR(MAX);

    DECLARE @msgs TABLE (txt VARCHAR(MAX));

    INSERT INTO @msgs (txt)
    SELECT TRIM(value)
    FROM (VALUES
        (@msg0), (@msg1), (@msg2), (@msg3), (@msg4),
        (@msg5), (@msg6), (@msg7), (@msg8), (@msg9),
        (@msg10), (@msg11), (@msg12), (@msg13), (@msg14),
        (@msg15), (@msg16), (@msg17), (@msg18), (@msg19)
    ) AS V(value)
    WHERE value IS NOT NULL AND LTRIM(RTRIM(value)) <> '';

    SELECT @result = STRING_AGG(txt, ' ') FROM @msgs;

    RETURN @result;
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ================================================================
-- Author:      Terry Watts
-- Create date: 25-MAR-2020
-- Description: Raises an exception coallescing the error messages
-- with a space between the messages
--
-- Ensures @state is positive
-- if @ex_num < 50000 message and raise to 50K+ @ex_num
-- ================================================================
CREATE PROCEDURE [dbo].[sp_raise_exception]
       @ex_num    INT           = 53000
      ,@msg0      VARCHAR(MAX)  = NULL
      ,@msg1      VARCHAR(MAX)  = NULL
      ,@msg2      VARCHAR(MAX)  = NULL
      ,@msg3      VARCHAR(MAX)  = NULL
      ,@msg4      VARCHAR(MAX)  = NULL
      ,@msg5      VARCHAR(MAX)  = NULL
      ,@msg6      VARCHAR(MAX)  = NULL
      ,@msg7      VARCHAR(MAX)  = NULL
      ,@msg8      VARCHAR(MAX)  = NULL
      ,@msg9      VARCHAR(MAX)  = NULL
      ,@msg10     VARCHAR(MAX)  = NULL
      ,@msg11     VARCHAR(MAX)  = NULL
      ,@msg12     VARCHAR(MAX)  = NULL
      ,@msg13     VARCHAR(MAX)  = NULL
      ,@msg14     VARCHAR(MAX)  = NULL
      ,@msg15     VARCHAR(MAX)  = NULL
      ,@msg16     VARCHAR(MAX)  = NULL
      ,@msg17     VARCHAR(MAX)  = NULL
      ,@msg18     VARCHAR(MAX)  = NULL
      ,@msg19     VARCHAR(MAX)  = NULL
      ,@fn        VARCHAR(35)   = NULL
AS
BEGIN
   DECLARE
       @fnThis    VARCHAR(35) = 'sp_raise_exception'
      ,@msg       VARCHAR(max)
   ;

   DECLARE @msgs TABLE (txt VARCHAR(MAX));

   SELECT @msg =  dbo.fnAggregateMsgs
   (
       @msg0,  @msg1,  @msg2,  @msg3,  @msg4
      ,@msg5 , @msg6,  @msg7,  @msg8,  @msg9
      ,@msg10, @msg11, @msg12, @msg13, @msg14
      ,@msg15, @msg16, @msg17, @msg18, @msg19
   );

   IF @ex_num IS NULL SET @ex_num = 53000; -- default
      EXEC sp_log 4, @fnThis, '000: throwing exception ', @ex_num, ' ', @msg, ' st: 1';

   ------------------------------------------------------------------------------------------------
   -- Validate
   ------------------------------------------------------------------------------------------------
   -- check ex num >= 50000 if not add 50000 to it
   IF @ex_num < 50000
   BEGIN
      SET @ex_num = abs(@ex_num) + 50000;
      EXEC sp_log 3, @fnThis, '010: supplied exception number is too low changing to ', @ex_num;
   END

   ------------------------------------------------------------------------------------------------
   -- Throw the exception
   ------------------------------------------------------------------------------------------------
   ;THROW @ex_num, @msg, 1;
END
/*
EXEC tSQLt.Run 'test.test_076_sp_raise_exception';
*/





GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =========================================================
-- Author:      Terry Watts
-- Create date: 06-DEc-2024
-- Description: compares 2 SQL_VARIANTs
-- RULES:
-- R01: if a < b return 1, 0 otherwise
-- R02: if types are same then a normal comparison should be used
-- R03: NULL < NULL returns 0
-- R04: NULL < NON NULL returns 1
-- R05: NON NULL < NULL returns 0
-- R06: different types try to convert to strings and then compare
--
-- Postconditions
-- Post 01: if a < b return 1
-- Post 02: if types are same then a normal comparison should be used
-- Post 03: NULL < NULL returns 0
-- Post 04: NULL < NON NULL returns 1
-- Post 05: NON NULL < NULL returns 0
-- Post 06: different types try to convert to strings and then compare
-- =========================================================
CREATE FUNCTION [dbo].[fnIsLessThan]( @a SQL_VARIANT, @b SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   DECLARE 
       @aTxt   VARCHAR(4000)
      ,@bTxt   VARCHAR(4000)
      ,@typeA  VARCHAR(50)
      ,@typeB  VARCHAR(50)
      ,@ret    BIT
      ,@res    INT

   ------------------------------------------------------
   -- Handle Null NULL
   ------------------------------------------------------
   IF @a IS NULL AND @b IS NULL RETURN 0;

   ------------------------------------------------------
   -- Handle Null not NULL scenarios
   ------------------------------------------------------
   IF @a IS NULL AND @b IS NOT NULL RETURN 1;
   IF @a IS NOT NULL AND @a IS NULL RETURN 0;

   ------------------------------------------------------
   -- ASSERTION: Both a and b are not NULL
   ------------------------------------------------------

   ------------------------------------------------------
   -- Handle different types
   ------------------------------------------------------
   SELECT @typeA = CONVERT(VARCHAR(500),SQL_VARIANT_PROPERTY(@a, 'BaseType'))
         ,@typeB = CONVERT(VARCHAR(500),SQL_VARIANT_PROPERTY(@b, 'BaseType'))
    ;

   IF @typeA <> @typeB
   BEGIN
      SELECT @aTxt = CONVERT(VARCHAR(500),@a)
            ,@bTxt = CONVERT(VARCHAR(500),@b);

      RETURN iif(@aTxt < @bTxt, 1, 0);
   END

   ------------------------------------------------------
   -- ASSERTION: Both a and b are the same type
   ------------------------------------------------------

   ------------------------------------------------------
   -- Handle types where the variant < operator
   -- does not return correct value
   ------------------------------------------------------

   ------------------------------------------------------
   -- Handle general case where variant < operator works
   ------------------------------------------------------

   RETURN iif(@a<@b, 1, 0);
END
/*
EXEC test.test_054_fnIsLT
EXEC tSQLt.Run 'test.test_054_fnIsLT';
EXEC tSQLt.RunAll;
PRINT DB_Name()

   DECLARE 
       @a      SQL_VARIANT = 2
      ,@b      SQL_VARIANT = '2'
      ,@aTxt   VARCHAR(4000) = CONVERT(VARCHAR(500),@a)
      ,@bTxt   VARCHAR(4000) = CONVERT(VARCHAR(500),@b)
      ;
   PRINT iif(@a<@b, 1, 0);

   DECLARE 
       @a      SQL_VARIANT =  2
      ,@b      SQL_VARIANT = 'abc'
      ,@aTxt   VARCHAR(4000)
      ,@bTxt   VARCHAR(4000)
      ;

   SELECT @aTxt = CONVERT(VARCHAR(500),@a)
         ,@bTxt = CONVERT(VARCHAR(500),@b)

   PRINT iif(@a<@b, 1, 0);
   PRINT iif(@b<@a, 1, 0);
   PRINT iif(@aTxt<@bTxt, 1, 0);
   PRINT iif(@bTxt<@aTxt, 1, 0);
   PRINT CONCAT('[',@aTxt, ']');
   PRINT CONCAT('[',@bTxt, ']');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: asserts that a is greater than b
--              raises an exception if not
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_gtr_than]
       @a         SQL_VARIANT
      ,@b         SQL_VARIANT
      ,@msg       VARCHAR(200)  = NULL
      ,@msg2      VARCHAR(200)  = NULL
      ,@msg3      VARCHAR(200)  = NULL
      ,@msg4      VARCHAR(200)  = NULL
      ,@msg5      VARCHAR(200)  = NULL
      ,@msg6      VARCHAR(200)  = NULL
      ,@msg7      VARCHAR(200)  = NULL
      ,@msg8      VARCHAR(200)  = NULL
      ,@msg9      VARCHAR(200)  = NULL
      ,@msg10     VARCHAR(200)  = NULL
      ,@msg11     VARCHAR(200)  = NULL
      ,@msg12     VARCHAR(200)  = NULL
      ,@msg13     VARCHAR(200)  = NULL
      ,@msg14     VARCHAR(200)  = NULL
      ,@msg15     VARCHAR(200)  = NULL
      ,@msg16     VARCHAR(200)  = NULL
      ,@msg17     VARCHAR(200)  = NULL
      ,@msg18     VARCHAR(200)  = NULL
      ,@msg19     VARCHAR(200)  = NULL
      ,@ex_num    INT            = 53502
      ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE
       @fnThis VARCHAR(35) = 'sp_assert_gtr_than'
      ,@aTxt   VARCHAR(100)= CONVERT(VARCHAR(100), @a)
      ,@bTxt   VARCHAR(100)= CONVERT(VARCHAR(100), @b)

   EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';

   -- a>b -> b<a 
   IF dbo.fnIsLessThan(@b ,@a) = 1
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, @a:[',@aTxt, '] IS GTR THN @b:[', @bTxt, ']';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fnThis, '020: [',@aTxt, '] IS GTR THN [', @bTxt, '] IS FALSE, raising exception';

   EXEC sp_raise_exception
          @msg1   = @msg
         ,@msg2   = @msg2
         ,@msg3   = @msg3
         ,@msg4   = @msg4
         ,@msg5   = @msg5
         ,@msg6   = @msg6
         ,@msg7   = @msg7
         ,@msg8   = @msg8
         ,@msg9   = @msg9
         ,@msg10  = @msg10
         ,@msg11  = @msg11
         ,@msg12  = @msg12
         ,@msg13  = @msg13
         ,@msg14  = @msg14
         ,@msg15  = @msg15
         ,@msg16  = @msg16
         ,@msg17  = @msg17
         ,@msg18  = @msg18
         ,@msg19  = @msg19
         ,@ex_num = @ex_num
         ,@fn     = @fn
   ;
END
/*
EXEC sp_assert_gtr_than 4, 5;
EXEC sp_assert_gtr_than 5, 4;
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_055_sp_assert_gtr_than';
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: Raises exception if @a is null or empty
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_not_null_or_empty]
    @val       VARCHAR(3999)
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@ex_num    INT            = NULL
   ,@fn        VARCHAR(35)    = '*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE 
       @fnThis    VARCHAR(35) = N'sp_assert_not_null_or_empty'
      ,@valTxt    VARCHAR(20)= @val
   ;

   EXEC sp_log @log_level, @fnThis, '000: starting,' ,@msg1,': @val:[',@val,']';

   IF dbo.fnLen(@val) > 0
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
       IF dbo.fnLen(@valTxt) < 20 SET @valTxt= CONCAT(@valTxt, '   ');
      EXEC sp_log @log_level, @fnThis, '010: OK, ASSERTION: val: [',@valTxt, '] IS NOT NULL';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fn, '020: @val IS NULL OR EMPTY, raising exception';
   IF @ex_num IS NULL SET @ex_num = 50005;
   DECLARE @msg0 VARCHAR(20)= 'val is NULL or empty'

   EXEC sp_raise_exception
       @ex_num = @ex_num
      ,@msg0   = 'sp_assert_not_null_or_empty'
      ,@msg1   = @msg0
      ,@msg2   = @msg1
      ,@msg3   = @msg2
      ,@msg4   = @msg3
      ,@msg5   = @msg4
      ,@msg6   = @msg5
      ,@msg7   = @msg6
      ,@msg8   = @msg7
      ,@msg9   = @msg8
      ,@msg10  = @msg9
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@fn     = @fn
      ;
END
/*
EXEC tSQLt.Run 'test.test_049_sp_assert_not_null_or_empty';
EXEC tSQLt.RunAll;
EXEC sp_assert_not_null_or_empty NULL
EXEC sp_assert_not_null_or_empty ''
EXEC sp_assert_not_null_or_empty 'Fred'
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




CREATE FUNCTION [dbo].[fnMin] (@p1 INT, @p2 INT)
RETURNS INT
AS
BEGIN
   RETURN CASE WHEN @p1 > @p2 THEN @p2 ELSE @p1 END;
END




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




-- ========================================================================================================
-- Author:      Terry Watts
-- Create date: 28-MAR-2020
-- Description: standard error handling:
--              get the exception message, log messages
--              clear the log cache first
-- NB: this does not throw
--
-- CHANGES
-- 231221: added clear the log cache first
-- 240315: added ex num, ex msg as optional out parmeters
-- 241204: it is possible that ERROR_MESSAGE() or ERROR_NUMBER() are throwing exceptions 
--        -this can happen inside tranactions when low level errors like select * from non existant table
-- 241221: error proc and error line do not always work - for example when executing SQL statements that
--         return a low error number like the following: 207:Invalid column name    
-- ========================================================================================================
CREATE PROCEDURE [dbo].[sp_log_exception]
       @fn        VARCHAR(35)
      ,@msg01     VARCHAR(4000) = NULL
      ,@msg02     VARCHAR(1000) = NULL
      ,@msg03     VARCHAR(1000) = NULL
      ,@msg04     VARCHAR(1000) = NULL
      ,@msg05     VARCHAR(1000) = NULL
      ,@msg06     VARCHAR(1000) = NULL
      ,@msg07     VARCHAR(1000) = NULL
      ,@msg08     VARCHAR(1000) = NULL
      ,@msg09     VARCHAR(1000) = NULL
      ,@msg10     VARCHAR(1000) = NULL
      ,@msg11     VARCHAR(1000) = NULL
      ,@msg12     VARCHAR(1000) = NULL
      ,@msg13     VARCHAR(1000) = NULL
      ,@msg14     VARCHAR(1000) = NULL
      ,@msg15     VARCHAR(1000) = NULL
      ,@msg16     VARCHAR(1000) = NULL
      ,@msg17     VARCHAR(1000) = NULL
      ,@msg18     VARCHAR(1000) = NULL
      ,@msg19     VARCHAR(1000) = NULL
      ,@ex_num    INT            = NULL OUT
      ,@ex_msg    VARCHAR(500)  = NULL OUT
      ,@ex_proc   VARCHAR(80)   = NULL OUT
      ,@ex_line   VARCHAR(20)   = NULL OUT
AS
BEGIN
   DECLARE 
       @fnThis    VARCHAR(35) = 'sp_log_exception'
      ,@NL        VARCHAR(2)  =  NCHAR(13) + NCHAR(10)
      ,@msg       VARCHAR(500)
      ,@fnHdr     VARCHAR(100)
      ,@isTrans   BIT = 0
      ,@line      VARCHAR(4000)

   SET @ex_num = -1; -- unknown
   SET @msg    = 'UNKNOWN MESSAGE';

   --EXEC sp_log 4, @fnThis, '510: starting';

   SELECT
       @ex_num = ERROR_NUMBER()
      ,@ex_proc= ERROR_PROCEDURE()
      ,@ex_line= CAST(ERROR_LINE() AS VARCHAR(20))
      ,@ex_msg = ERROR_MESSAGE();

   SET @fnHdr = CONCAT(@ex_proc, '(',@ex_line,'): ')

   BEGIN TRY
      SET @msg =
      CONCAT
      (
         '500: caught exception ', @ex_num, ': ', @ex_msg, ' ', 
          @msg01
         ,iif(@msg02 IS NOT NULL, CONCAT(' ', @msg02 ), '')
         ,iif(@msg03 IS NOT NULL, CONCAT(' ', @msg03 ), '')
         ,iif(@msg04 IS NOT NULL, CONCAT(' ', @msg04 ), '')
         ,iif(@msg05 IS NOT NULL, CONCAT(' ', @msg05 ), '')
         ,iif(@msg06 IS NOT NULL, CONCAT(' ', @msg06 ), '')
         ,iif(@msg07 IS NOT NULL, CONCAT(' ', @msg07 ), '')
         ,iif(@msg08 IS NOT NULL, CONCAT(' ', @msg08 ), '')
         ,iif(@msg09 IS NOT NULL, CONCAT(' ', @msg09 ), '')
         ,iif(@msg10 IS NOT NULL, CONCAT(' ', @msg10 ), '')
         ,iif(@msg11 IS NOT NULL, CONCAT(' ', @msg11 ), '')
         ,iif(@msg12 IS NOT NULL, CONCAT(' ', @msg12 ), '')
         ,iif(@msg13 IS NOT NULL, CONCAT(' ', @msg13 ), '')
         ,iif(@msg14 IS NOT NULL, CONCAT(' ', @msg14 ), '')
         ,iif(@msg15 IS NOT NULL, CONCAT(' ', @msg15 ), '')
         ,iif(@msg16 IS NOT NULL, CONCAT(' ', @msg16 ), '')
         ,iif(@msg17 IS NOT NULL, CONCAT(' ', @msg17 ), '')
         ,iif(@msg18 IS NOT NULL, CONCAT(' ', @msg18 ), '')
         ,iif(@msg19 IS NOT NULL, CONCAT(' ', @msg19 ), '')
      );

      SET @line = REPLICATE('*', dbo.fnMin(300, dbo.fnLen(@msg)+46));

      PRINT CONCAT(@nl, @line);
      EXEC sp_log 4, @fnThis, @fnHdr, @msg;
      PRINT CONCAT(@line, @nl);
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fnThis, '590: failed. exception was: ', @ex_num, ': ', @ex_msg;
      SET @ex_num = ERROR_NUMBER();
      SET @ex_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fnThis,  '580: sp_log failed, exception: ',@ex_num, ': @ex_msg';
      SET @ex_msg ='*** system error: failed to get error msg ***';
   END CATCH
END




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from the right end of a string
-- =============================================
CREATE FUNCTION [dbo].[fnRTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   IF @str IS NOT NULL AND @trim_chr IS NOT NULL
      WHILE Right(@str, 1)= @trim_chr AND dbo.fnLen(@str) > 0
         SET @str = Left(@str, dbo.fnLen(@str)-1);

   RETURN @str
END
/*
PRINT CONCAT('[',  dbo.fnRTrim2('  ', ' '), ']');
PRINT CONCAT('[',  dbo.fnRTrim2(' ', ' '), ']');
PRINT CONCAT('[',  dbo.fnRTrim2('', ' '), ']');
PRINT CONCAT('[', Right('', 1), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' s 5   ', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' ', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2('', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(NULL, ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' ', NULL), ']
PRINT CONCAT('[', dbo.fnRTrim2('', NULL), ']');
IF dbo.fnRTrim2(NULL, NULL) IS NULL PRINT 'IS NULL';
*/




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from 
--              the beginning end of a string
-- =============================================
CREATE FUNCTION [dbo].[fnLTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE @len INT;

   IF @str IS NOT NULL AND @trim_chr IS NOT NULL
      WHILE Left(@str, 1) = @trim_chr
      BEGIN
         SET @len = dbo.fnLen(@str)-1;

         IF @len < 0
            BREAK;

         SET @str = Substring(@str, 2, dbo.fnLen(@str)-1);
      END

   RETURN @str
END

/*
PRINT CONCAT('1: [',  dbo.fnLTrim2('  ', ' '), ']');
PRINT CONCAT('2: [',  dbo.fnLTrim2(' ', ' '), ']');
PRINT CONCAT('3: [',  dbo.fnLTrim2('', ' '), ']');
PRINT CONCAT('4: [', Right('', 1), ']');
PRINT CONCAT('5: [', dbo.fnLTrim2(' s 5   ', ' '), ']');
PRINT CONCAT('6: [', dbo.fnLTrim2(' ', ' '), ']');
PRINT CONCAT('7: [', dbo.fnLTrim2('', ' '), ']');
PRINT CONCAT('8: [', dbo.fnLTrim2(NULL, ' '), ']');
PRINT CONCAT('9: [', dbo.fnLTrim2(' ', NULL), ']');
PRINT CONCAT('10:[', dbo.fnLTrim2('', NULL), ']');
IF dbo.fnLTrim2(NULL, NULL) IS NULL PRINT 'IS NULL';
*/




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from 
--              the beginning end of a string
-- =============================================
CREATE FUNCTION [dbo].[fnTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   RETURN dbo.fnRTrim2(dbo.fnLTrim2(@str, @trim_chr), @trim_chr);
END




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ================================================================================================
-- Author:      Terry Watts
-- Create date: 05-APR-2024
-- Description: returns:
--    if @ty_nm is a text array type then returns the full type from a data type + max_len fields
--    else returns @ty_nm on its own.
--
--    This is useful when using sys rtns like sys.columns
--
-- Test: test.test_089_fnGetFullTypeName
-- ================================================================================================
CREATE FUNCTION [dbo].[fnGetFullTypeName]
(
    @ty_nm  VARCHAR(20)
   ,@len    INT
)
RETURNS VARCHAR(50)
AS
BEGIN
   RETURN 
      iif
      (
         @ty_nm in ('VARCHAR','VARCHAR')
         ,CONCAT
         (
            UPPER(@ty_nm), '('
           ,iif(@len=-1, 'MAX', FORMAT(@len, '####'))
           ,')'
         )
         ,UPPER(@ty_nm)
      );
END
/*
  PRINT dbo.fnGetFullTypeName('VARCHAR', -1);
  PRINT dbo.fnGetFullTypeName('VARCHAR', 20);
  PRINT dbo.fnGetFullTypeName('VARCHAR', 4000);
  PRINT dbo.fnGetFullTypeName('INT', 30);
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2023
-- Description: returns the type name from the type code
--e.g. sysobjects xtype code 
-- ======================================================
CREATE FUNCTION [dbo].[fnGetTyNmFrmTyCode]
(
   @ty_code VARCHAR(2)
)
RETURNS VARCHAR(30)
AS
BEGIN
   RETURN
   (
      CASE 
         WHEN @ty_code = 'AF' THEN 'CLR aggregate function'
         WHEN @ty_code = 'C'  THEN 'CHECK constraint'
         WHEN @ty_code = 'D'  THEN 'DEFAULT'
         WHEN @ty_code = 'EC' THEN 'Edge constraint'
         WHEN @ty_code = 'ET' THEN 'External tbl'
         WHEN @ty_code = 'F'  THEN 'Foreign key'
         WHEN @ty_code = 'FN' THEN 'Scalar function'
         WHEN @ty_code = 'FS' THEN 'CLR scalar function'
         WHEN @ty_code = 'FT' THEN 'CLR table function'
         WHEN @ty_code = 'IF' THEN 'Inline table function'
         WHEN @ty_code = 'IT' THEN 'Intrnl table'
         WHEN @ty_code = 'P'  THEN 'Procedure'
         WHEN @ty_code = 'PC' THEN 'CLR procedure'
         WHEN @ty_code = 'PG' THEN 'Plan guide'
         WHEN @ty_code = 'PK' THEN 'Primary key'
         WHEN @ty_code = 'R'  THEN 'Rule'
         WHEN @ty_code = 'RF' THEN 'Repl fltr proc'
         WHEN @ty_code = 'S'  THEN 'Sys base table'
         WHEN @ty_code = 'SN' THEN 'Synonym'
         WHEN @ty_code = 'SO' THEN 'Sequence object'
         WHEN @ty_code = 'SQ' THEN 'Service queue'
         WHEN @ty_code = 'TA' THEN 'CLR DML trigger'
         WHEN @ty_code = 'TF' THEN 'Table function'
         WHEN @ty_code = 'TR' THEN 'SQL DML trigger'
         WHEN @ty_code = 'TT' THEN 'Table type'
         WHEN @ty_code = 'U'  THEN 'Table'
         WHEN @ty_code = 'UQ' THEN 'Unique Key'
         WHEN @ty_code = 'V'  THEN 'View'
         WHEN @ty_code = 'X'  THEN 'Extended procedure'
         ELSE '???'
      END
   );
END
/*
PRINT dbo.fnGetTyNmFrmTyCode('TF')
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2023
-- Description: returns the parameters
-- e.g. sysobjects xtype code 
-- ======================================================
CREATE VIEW [dbo].[SysRtnPrms_vw]
AS 
SELECT
    SCHEMA_NAME( schema_id)            AS schema_nm
   ,OBJECT_NAME(sap.object_id)         AS rtn_nm
   ,sap.name                           AS prm_nm
   ,parameter_id                       AS ordinal
   ,UPPER(TYPE_NAME(system_type_id))   AS ty_nm

   ,IIF( TYPE_NAME(system_type_id) IN ('VARCHAR', 'NVARCHAR', 'NTEXT')
      ,CONCAT( UPPER(TYPE_NAME(system_type_id)), '('
              ,iif
               ( system_type_id in (167, 231)
                ,iif(max_length= -1, 4000,max_length/2)
                , max_length
               )
              ,')'
             ) -- end concat
      ,dbo.fnGetFullTypeName(TYPE_NAME(system_type_id), max_length/2)--TYPE_NAME(system_type_id)
      )          AS ty_nm_full
   ,system_type_id                     AS ty_id
   ,iif
    (
       system_type_id in (231)
      ,max_length/2, max_length
    ) AS ty_len
    , IIF(TYPE_NAME(system_type_id) IN ('VARCHAR', 'NVARCHAR', 'NCHAR','CHAR','NTEXT'), 1, 0) AS is_chr_ty
   ,is_output
   ,is_nullable
   ,has_default_value
   ,default_value
   ,dbo.fnGetTyNmFrmTyCode([type])     AS rtn_ty_nm
   ,[type]                             AS rtn_ty_code
FROM sys.all_parameters sap
     JOIN sys.all_objects so ON sap.object_id=so.object_id
 ;

/*
SELECT * FROM SysRtnPrms_vw WHERE rtn_nm = 'sp_ImportAttendanceGMeet2Staging';
SELECT  * FROM paramsVw where param_nm ='' -- Scalar function, CLR scalar function return value
SELECT TOP 100 * FROM sys.all_parameters sap JOIN sys.all_objects so ON sap.object_id=so.object_id;
SELECT top 10 * FROM sys.sysobjects
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================================
-- Author:        Terry watts
-- Create date:   05-APR-2024
-- Description:   gets the output columns from a table function (TF)
-- Tests:         test_042_fnGetFnOutputCols
-- Preconditions  @q_rtn_nm is a table function
-- Postconditions OUTPUT table holds the output column meta data for the given TF
-- ===============================================================================
CREATE FUNCTION [dbo].[fnGetFnOutputCols]
(
    @q_rtn_nm     VARCHAR(60)
)
RETURNS @t TABLE
(
    name          VARCHAR(50)
   ,ordinal       INT
   ,ty_nm         VARCHAR(40)
   ,[len]         INT
   ,is_nullable   BIT
   ,is_results    BIT
)
AS
BEGIN
      INSERT INTO @t (name, ordinal, ty_nm, [len], is_nullable, is_results)
      --SELECT name, column_id as ordinal, TYPE_NAME(user_type_id) as ty_nm, max_length, is_nullable
      SELECT name, column_id as ordinal, dbo.fnGetFullTypeName(TYPE_NAME(user_type_id), max_length) as ty_nm, max_length, is_nullable, 0
      FROM sys.columns
      WHERE object_id=object_id(@q_rtn_nm)
      ORDER BY column_id
      ;

   RETURN;
END
/*
EXEC test.test_042_fnGetFnOutputCols;

SELECT * FROM dbo.fnGetFnOutputCols('test.fnCrtHlprSigParams');
SELECT * FROM dbo.fnGetFnOutputCols('test.fnCrtHlprSigParams');

SELECT name, column_id as ordinal, TYPE_NAME(user_type_id) as ty_nm, max_length, is_nullable
FROM sys.columns
WHERE object_id=object_id('test.fnCrtHlprSigParams')
ORDER BY column_id
;
SELECT *, column_id as ordinal, TYPE_NAME(user_type_id) as ty_nm, dbo.fnGetFullTypeName(TYPE_NAME(user_type_id), max_length) as ty_nm_full, max_length, is_nullable
FROM sys.columns
WHERE object_id=object_id('test.fnCrtHlprSigParams')
ORDER BY column_id
;
EXEC test.sp__crt_tst_rtns '[dbo].[fnGetFnOutputCols]';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- =====================================================================
-- Author:      Terry Watts
-- Create date: 31-OCT-2024
-- Description: determines if @ty is a text datatype
-- e.g. 'VARCHAR' is a text type
-- 
-- PRECONDITIONS: @ty is just the datatype without ()
-- e.g. 'VARCHAR' is OK but 'VARCHAR(20)' the output is undefined
-- =====================================================================
CREATE FUNCTION [dbo].[fnIsTextType](@ty   VARCHAR(500))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('char','nchar','varchar','nvarchar'), 1, 0);
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_097_fnIsTextType';
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [test].[ParamDetails](
	[ordinal] [int] IDENTITY(1,1) NOT NULL,
	[param_nm] [varchar](50) NULL,
	[type_nm] [varchar](32) NULL,
	[parameter_mode] [varchar](10) NULL,
	[is_chr_ty] [bit] NULL,
	[is_result] [bit] NULL,
	[is_output] [bit] NULL,
	[is_nullable] [bit] NULL,
	[tst_ty] [nchar](3) NULL,
	[is_exception] [bit] NULL,
 CONSTRAINT [PK_ParamDetails] PRIMARY KEY CLUSTERED 
(
	[ordinal] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [test].[RtnDetails](
	[qrn] [varchar](90) NULL,
	[schema_nm] [varchar](60) NULL,
	[rtn_nm] [varchar](60) NULL,
	[trn] [int] NULL,
	[cora] [nchar](1) NULL,
	[ad_stp] [bit] NULL,
	[rtn_ty] [varchar](2) NULL,
	[rtn_ty_code] [varchar](2) NULL,
	[is_clr] [bit] NULL,
	[tst_rtn_nm] [varchar](50) NULL,
	[hlpr_rtn_nm] [varchar](50) NULL,
	[max_prm_len] [int] NULL,
	[sc_fn_ret_ty] [varchar](20) NULL,
	[prm_cnt] [int] NULL,
	[display_tables] [bit] NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



CREATE FUNCTION [dbo].[fnMax] (@p1 INT, @p2 INT)
RETURNS INT
AS
BEGIN
   RETURN CASE WHEN @p1 > @p2 THEN @p1 ELSE @p2 END 
END



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [test].[sp_first_result_col_info](
	[name] [varchar](50) NULL,
	[column_ordinal] [int] NULL,
	[is_nullable] [bit] NULL,
	[system_type_name] [varchar](50) NULL,
	[error_message] [varchar](300) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================================================================================
-- Author:      Terry Watts
-- Create date: 17-DEC-2021
-- Description: populates Test.ParamDetails table with the tested rtn paramer details
--
-- Responsibilities;
-- R01: fully populate the ParamDetails table
-- R02: update the RtnDetails table max_prm_len field with the max parameter name length
-- R03: update the RtnDetails table sc_fn_ret_ty field with the the scalar fn return type - if tstd rtn is a scalar function
--
--ALGORITHM:
-- Clear the test.Param TabIe
-- Add the tst_num parameter setting type = SYS
-- Get the rtn parameters
-- Add the rtn parameters as inp if a Scalar FN ignore the is_result parameter
-- Add an exp row cnt INT setting type = TST
--
-- If Table fn:
--    Add a search key to identify the row to be checked etting type = TST
--    Get the tn ouput table cols
--    Add an exp row cnt INT setting type = TST
--    Add a search key to identify the row to be checked setting type = TST
--    For each Col: add the param as exp_x setting type = EXP
--
-- If Scalar fn:
--    Add the is result parameter as exp_result ty: EXP
--
-- PRECONDITIONS:
--    Test.RtnDetails pop'd 
--
-- POST CONDITIONS:
-- POST 01: the following ParamDetails fields not null: ordinal, param_nm, type_nm, parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception
-- POST 02: if routine not found then exception 70003, 'Routine <@schema_nm.@rtn_nm> was not found'
-- POST 03: fully populates the ParamDetails table or exception <TBA> <TBA>
-- POST 04: updates the RtnDetails table max_prm_len field or exception <TBA> <TBA>
-- POST 05: updates the RtnDetails table scalar fn return type field or exception <TBA> <TBA>
--
-- NOTES:
-- 1. The MS routines and views to get default parameter values DONT WORK - no suprise there then
--
-- CALLED BY: test.sp_get_rtn_details
--
-- Tests: test_042_sp_pop_param_details
--
-- Changes:
-- 240403: Changed to use INFORMATION_SCHEMA.PARAMETERS and dbo.SysRtnPrms_vw
--          not bother with comments
--          Table is now fixed as test.ParamTable
-- 240415: redesign, added several fields to make it eassier to use latter in the test rtn creation
-- 240503: added sc_fn_ret_ty to test.RtnParameters to hold the scalar fn return type - if tstd rtn is a scalar function
-- 241205: removed @tst_key param
-- =============================================================================================================================
CREATE PROCEDURE [test].[sp_pop_param_details]
    @throw_if_err    BIT      = 1
   ,@display_tables  BIT      = 0
AS
BEGIN
   DECLARE
     @fn             VARCHAR(35)   = 'sp_pop_param_details'
    ,@qrn            VARCHAR(120)
    ,@schema_nm      VARCHAR(25)
    ,@rtn_nm         VARCHAR(50)
    ,@rtn_ty_code    VARCHAR(2)
    ,@ndx            INT            = 1
    ,@row_cnt        INT
    ,@max_prm_len    INT
    ,@msg            VARCHAR(500)
    ,@sc_fn_ret_ty   VARCHAR(20)

BEGIN TRY
   SELECT
       @schema_nm    = schema_nm
      ,@rtn_nm       = rtn_nm
      ,@rtn_ty_code  = rtn_ty_code
   FROM test.RtnDetails;

   EXEC sp_log 1, @fn, '000: starting
@schema_nm  :[',@schema_nm,']
@rtn_nm     :[',@rtn_nm,']
@rtn_ty_code:[',@rtn_ty_code,']';

   SET @qrn = CONCAT(@schema_nm, '.', @rtn_nm);

   -- Clear the test.Param TabIe
   EXEC sp_log 1, @fn, '005: clearing param details'
   TRUNCATE TABLE test.ParamDetails;

   -------------------------------------------------------------------------------
   -- Validate parameters
   -------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '010: Validating parameters   ';

-- POST 01: if routine not found then exception 70003, 'Routine <@schema_nm.@rtn_nm> was not found'
   IF @rtn_nm IS NULL
   BEGIN
      SET @msg = CONCAT('Routine <', @schema_nm, '.',@rtn_nm,'> was not found');
      EXEC sp_log 4, @fn, '020: raising exception 70003, ', @msg;

      IF @throw_if_err = 1
         THROW 70003, @msg, 1;
      ELSE
         RETURN
   END

   IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
   WHERE SPECIFIC_SCHEMA = @schema_nm AND SPECIFIC_NAME = @rtn_nm)
   BEGIN
      SET @msg = CONCAT('routine <',@schema_nm,'>.<',@rtn_nm,'> was not found');

      IF @throw_if_err = 1
         THROW 70003, @msg, 1;
      ELSE
      BEGIN
         EXEC sp_log 4, @fn, '030: routine ',@schema_nm,'.',@rtn_nm,' not found';
      END
   END

   -------------------------------------------------------------------------------
   -- Validation complete
   -------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '040: Validation complete';

   -------------------------------------------------------------------------------
   -- Process
   -------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '050: starting process
@qrn:[',@qrn,']
@rtn_ty_code:[',@rtn_ty_code,']'
;

-- Add the tst_num parameter setting type = SYS
   EXEC sp_log 1, @fn, '060: Populating ParamDetails, adding tst_num ';

   INSERT INTO test.ParamDetails(param_nm ,  type_nm      , parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
   VALUES                       ('tst_num', 'VARCHAR(50)', 'IN'           , 1        , 0        , 0        , 0          ,'TST' , 0)
   ;

   EXEC sp_log 1, @fn, '070:';
   IF @rtn_ty_code IN ('P','TF')
   BEGIN
      EXEC sp_log 1, @fn, '018:';
      SET @ndx = @ndx + 1;

      INSERT INTO test.ParamDetails(param_nm ,type_nm       , parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
      VALUES
          ('display_tables' ,'BIT' , 'IN'           , 0        , 0        , 0        , 0          ,'TST' , 0)
      ;
   END

   SET @ndx = @ndx + 1;

   -- Get the rtn parameters-- Add the rtn parameters as INP if a Scalar FN ignore the is_result parameter
   EXEC sp_log 1, @fn, '020: adding rtn parameters as INP';

   INSERT INTO test.ParamDetails( param_nm, parameter_mode, type_nm, is_output, is_chr_ty, is_result, is_nullable, tst_ty,is_exception)
   SELECT
       iif( is_result = 'YES', 'out_val', dbo.fnTrim2(pv.prm_nm, '@'))
      ,parameter_mode
      ,upper(ty_nm_full)
      ,is_output
      ,is_chr_ty
      ,iif(is_result='Yes', 1,0)
      ,is_nullable
      ,iif( is_result = 'YES','EXP','INP')
      ,0
   FROM INFORMATION_SCHEMA.PARAMETERS isp
   JOIN dbo.SysRtnPrms_vw pv ON 
       isp.SPECIFIC_SCHEMA  = pv.schema_nm
   AND isp.SPECIFIC_NAME    = pv.rtn_nm
   AND isp.PARAMETER_NAME   = pv.prm_nm
   WHERE schema_nm = @schema_nm
   AND   rtn_nm    = @rtn_nm
   ;

   SET @row_cnt = @@ROWCOUNT;
   SET @ndx = @ndx + @row_cnt;
   EXEC sp_log 1, @fn, '080: @ndx after geting rtn params: ', @ndx,'  @row_cnt: ',@row_cnt;

   ----------------------------------------------------------------------------------------------------------------------------------
   -- IF SP or TF: get the output cols and add EXP row_cnt param
   ----------------------------------------------------------------------------------------------------------------------------------
   IF @rtn_ty_code IN ('P','TF')
   BEGIN
      EXEC sp_log 1, @fn, '090: @rtn_ty_code:', @rtn_ty_code, ', adding exp_row_cnt';
      -- Add an exp_row_cnt INT setting type = TST
      INSERT INTO test.ParamDetails( param_nm    , type_nm, parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
      VALUES                       ('row_cnt'    , 'INT'  , 'IN'          , 0        , 0        , 0        , 1          ,'EXP',   0);

      SET @ndx = @ndx + 1;

      IF(@rtn_ty_code = 'P')
      BEGIN
         INSERT INTO test.ParamDetails(param_nm ,  type_nm      , parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
         VALUES                       ('RC',       'INT',            'IN'       , 0        , 0        , 0        , 0          ,'EXP' , 0);

         SET @ndx = @ndx + 1;
      END

      IF  @rtn_ty_code = 'TF'
      BEGIN
         -- Get the TF ouput table cols
         EXEC sp_log 1, @fn, '100: , adding the TF ouput table cols';
         INSERT INTO test.ParamDetails
               (param_nm, type_nm, parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
         SELECT
             dbo.fnTrim2(name, '@')
            ,ty_nm
            ,'IN'
            ,dbo.fnIsTextType(ty_nm)
            ,0
            ,0
            ,1
            ,'EXP'
            ,0
         FROM dbo.fnGetFnOutputCols(@qrn)
      END

      IF @rtn_ty_code = 'P'
      BEGIN
         EXEC sp_log 1, @fn, '120: , getting the SP ouput table cols';

         BEGIN TRY
            DELETE FROM test.sp_first_result_col_info;
            DECLARE @obj_id INT
            SET @obj_id = OBJECT_ID(@qrn);
            EXEC sp_log 1, @fn, '130: , checking OBJECT_ID(',@qrn, ') = ', @obj_id, ' is > 0   ';

            -------------------------------------------------------------------------------------------
            -- Make sure rtn was found
            -------------------------------------------------------------------------------------------
            EXEC sp_assert_gtr_than @obj_id, 0, '140: failed to get the object id for ', @qrn;

            INSERT INTO test.sp_first_result_col_info(name, column_ordinal, is_nullable, system_type_name, [error_message])
            SELECT name, column_ordinal, is_nullable, system_type_name, [error_message]
            FROM sys.dm_exec_describe_first_result_set_for_object(@obj_id, 0);

            INSERT INTO test.ParamDetails
                  (param_nm, type_nm, parameter_mode
                  ,is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
            SELECT
                dbo.fnTrim2(name, '@')                   -- raw_param_nm
               ,UPPER(system_type_name)                  -- type_nm
               ,'IN'                                     -- parameter_mode
               ,dbo.fnIsTextType(system_type_name)       -- is_chr_ty
               ,1                                        -- is_result
               ,0                                        -- is_output
               ,1                                        -- is_nullable
               ,'EXP'                                    -- tst_ty
               ,0                                        -- is_exception
            FROM test.sp_first_result_col_info
            WHERE name <> 'SP RTN COLS:';

            EXEC sp_log 1, @fn, '150: , getting the SP ouput table cols succeeded';
         END TRY
         BEGIN CATCH
            EXEC sp_log_exception @fn, 'sys.dm_exec_describe_first_result_set cannnot get output cols from SP - continuing without the output col exp/act params';
         END CATCH
      END -- IF @rtn_ty_code = 'P'
   END -- IF @rtn_ty_code IN ('P','TF')

   -------------------------------------------------------------------------------------------------------------------------------
   -- R02: add exception params
   -------------------------------------------------------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '160: adding  exception params';
   SET @ndx = @ndx + 1;
   INSERT INTO test.ParamDetails
    (param_nm ,type_nm        , parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
   VALUES
    ('ex_num', 'INT'          , 'IN'          , 1        , 0        , 0        , 1           ,'EXP'   , 1)
   ,('ex_msg', 'VARCHAR(500) ', 'IN'          , 1        , 0        , 0        , 1           ,'EXP'   , 1)
   ;

   -------------------------------------------------------------------------------------------------------------------------------
   -- R02: update the RtnDetails table max_prm_len field with the length of the longest parameter name including the @xxx_ prefix
   -------------------------------------------------------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '170: calculating max param len   '

   -- Set max param nm len make sure atleast size of our standard parameters like @act_ex_msg
   SELECT
       @max_prm_len = dbo.fnMax(14, MAX(dbo.fnLen(param_nm)))
      ,@ndx         = COUNT(*)
   FROM ParamDetails;

   -- Updaet the RtnDetails with aff data for params: count of and max len
   UPDATE test.RtnDetails
   SET
       max_prm_len = @max_prm_len
      ,prm_cnt     = @ndx
      ;

   -------------------------------------------------------------------------------------------------------------------------------
   -- R03: if tstd rtn is a scalar function then update the RtnDetails table sc_fn_ret_ty field with the scalar fn return type
   -------------------------------------------------------------------------------------------------------------------------------
   IF @rtn_ty_code = 'FN'
   BEGIN
      EXEC sp_log 1, @fn, '180: tstd rtn is a scalar function so set the fn''s return type'
      SELECT @sc_fn_ret_ty = type_nm
      FROM test.ParamDetails
      WHERE is_output=1;

      EXEC sp_log 1, @fn, '190: getting sc fn ret type from parameters    @sc_fn_ret_ty:[', @sc_fn_ret_ty,']';
      EXEC sp_assert_not_null_or_empty @sc_fn_ret_ty, 'scalar fn return type was not found';

      EXEC sp_log 1, @fn, '200: ASSERTION @sc_fn_ret_ty found'
      UPDATE test.RtnDetails
      SET sc_fn_ret_ty = @sc_fn_ret_ty;
      EXEC sp_log 1, @fn, '210: ASSERTION @sc_fn_ret_ty found'
   END

   -------------------------------------------------------------------------------
   -- Checking post conditionms
   -------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '400: checking post conditionms';
   EXEC sp_log 1, @fn, '900: completed processing, @max_prm_len: ',@max_prm_len;

   -------------------------------------------------------------------------------
   -- Process complete
   -------------------------------------------------------------------------------
   if @display_tables = 1
      SELECT * FROM test.ParamDetails;
END TRY
BEGIN CATCH
   EXEC sp_log 4, @fn, '500 caught exception';
   EXEC sp_log_exception @fn;
   THROW;
END CATCH

   EXEC sp_log 1, @fn, '999: leaving'
END
/*
EXEC test.test_042_sp_pop_param_details;
EXEC tSQLt.Run 'test_042_sp_pop_param_details';
EXEC tSQLt.RunAll;
------------------------------------------------------------
EXEC test.sp_set_rtn_details @qrn='test.fnCrtHlprCodeDeclActParams',@display_tables = 1
EXEC test.sp_pop_rtn_details @qrn='test.fnCrtHlprCodeDeclActParams',@display_tables = 1
EXEC test.sp_pop_param_details @display_tables = 1;
EXEC test.sp__crt_tst_rtns ''
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


--===========================================================
-- Author:      Terry watts
-- Create date: 18-MAY-2020
-- Description: lists routine details
-- ===========================================================
CREATE VIEW [dbo].[SysRtns_vw]
AS
SELECT TOP 2000
    SCHEMA_NAME([schema_id])              AS schema_nm
   ,[name]                                AS rtn_nm
   ,IIF([type] IN ('P','PC'), 'P', 'F')   AS rtn_ty
   ,dbo.fnTrim([type])                    AS ty_code
   ,[type_desc]                           AS ty_nm
   ,IIF([type] IN ('FS','FT','PC'),1,0)   AS is_clr
   ,is_ms_shipped
   ,DATEFROMPARTS(YEAR(create_date), MONTH(create_date), Day(create_date)) AS created
   ,DATEFROMPARTS(YEAR(modify_date), MONTH(modify_date), Day(modify_date)) AS modified
FROM sys.objects
    WHERE
     [type] IN ('P', 'FN', 'TF', 'IF', 'AF', 'FT', 'IS', 'PC', 'FS')
ORDER BY [schema_nm], [type], [name]
;
/*
SELECT * FROM SysRtns_vw WHERE ty_code = 'P' AND schema_nm IN ('dbo','test')
SELECt top 500 * from sys.objects WHERE name like 'sp_%'
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO




-- =================================================
-- Author:      Terry Watts
-- Create date: 24-NOV-2023
--
-- Description: removes square brackets from string
-- in any position in the string
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
--    [ ] brackets removed
--
-- Tests:
-- =============================================
CREATE FUNCTION [dbo].[fnDeSquareBracket](@s VARCHAR(4000))
RETURNS VARCHAR(4000)
AS
BEGIN
   RETURN REPLACE(REPLACE(@s, '[', ''), ']', '');
END
/*
   EXEC test.sp_crt_tst_rtns 'dbo.fnDeSquareBracket', 69
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2023
--
-- Description: splits a qualified rtn name 
-- into a row containing the schema_nm and the rtn_nm
-- removes square brackets
--
-- RULES:
-- @qrn  schema   rtn
-- a.b   a        b
-- a     dbo      a
-- NULL  null     null
-- ''    null     null
--
-- Preconditions
-- PRE 02: if schema is not specifed in @qrn and there are more than 1 rtn with the rtn nm
--          but differnt schema then raise div by zero exception

-- Postconditions:
-- Post 01: if schema is not specifed then get it from the sys rtns PROVIDED ONLY ONE rtn named the @rtn_nm
-- 
-- Changes:
-- 231117: handle [ ] wrappers
-- 240403: handle errors like null @qual_rtn_nm softly as per rules above
-- 241207: changed schema from test to dbo
-- 241227: default schema is now the schema found in the sys rtns for the given rtn in @qrn
--         will throw a div by zero error if PRE 02 violated
-- ==============================================================================================================
CREATE FUNCTION [dbo].[fnSplitQualifiedName]
(
   @qrn VARCHAR(150) -- qualified routine name
)
RETURNS @t TABLE
(
    schema_nm  VARCHAR(50)
   ,rtn_nm     VARCHAR(100)
)
AS
BEGIN
   DECLARE
    @n          INT
   ,@schema_nm  VARCHAR(50)
   ,@rtn_nm     VARCHAR(100)

   -- Remove [ ] wrappers
   SET @qrn = dbo.fnDeSquareBracket(@qrn);

   IF @qrn IS NOT NULL AND @qrn <> ''
   BEGIN
      SET @n = CHARINDEX('.',@qrn);

      -- if rtn nm not qualified then assume schema = dbo
      SET @schema_nm = iif(@n=0, 'dbo',SUBSTRING( @qrn, 1   , @n-1));
      SET @rtn_nm    = iif(@n=0,  @qrn,SUBSTRING( @qrn, @n+1, dbo.fnLen(@qrn)-@n))

      -- PRE 02: if schema is not specifed in @qrn and there are more than 1 rtn with the rtn nm
      --          but differnt schema then raise div by zero exception
      IF( CHARINDEX('.', @qrn) = 0)
      BEGIN
         DECLARE @cnt INT;
         SELECT @cnt = COUNT(*) FROM dbo.SysRtns_vw WHERE rtn_nm = @qrn;

         -- Raise div by zero exception
         IF @cnt > 1 SET @cnt = @cnt/0;
      END
   END

   INSERT INTO @t (schema_nm, rtn_nm)
   VALUES( @schema_nm,@rtn_nm);
   RETURN;
END
/*
SELECT * FROM fnSplitQualifiedName('test.fnGetRtnNmBits')
SELECT * FROM fnSplitQualifiedName('a.b')
SELECT * FROM fnSplitQualifiedName('a.b.c')
SELECT * FROM fnSplitQualifiedName('a')
SELECT * FROM fnSplitQualifiedName(null)
SELECT * FROM fnSplitQualifiedName('')
EXEC test.sp__crt_tst_rtns '[dbo].[fnSplitQualifiedName]';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ============================================================================================================================
-- Author:      Terry Watts
-- Create date: 09-MAY-2020
-- Description: checks if the routine exists
--
-- Preconditions
-- PRE 02: if schema is not specifed in @qrn and there are more than 1 rtn with the rtn nm
--          but differnt schema then raise div by zero exception - delegated to fnSplitQualifiedName
--
-- Postconditions:
-- Post 01: RETURNS if @q_rtn_name exists then [schema_nm, rtn_nm, rtn_ty, ty_code,] , 0 otherwise
--
-- Changes 240723: now returns a single row table as above
--
-- Tests: test.test_029_fnChkRtnExists
-- ============================================================================================================================
CREATE FUNCTION [dbo].[fnGetRtnDetails]
(
    @qrn VARCHAR(120)
)
RETURNS @t TABLE
(
    qrn           VARCHAR(120)
   ,schema_nm     VARCHAR(32)
   ,rtn_nm        VARCHAR(60)
   ,rtn_ty        NCHAR(61)
   ,ty_code       VARCHAR(25)
   ,is_clr        BIT
)
AS
BEGIN
   DECLARE
       @schema       VARCHAR(20)
      ,@rtn_nm       VARCHAR(4000)
      ,@ty_nm        VARCHAR(20)
      ,@qrn2         VARCHAR(120)

   SELECT
       @schema = schema_nm
      ,@rtn_nm = rtn_nm
      ,@qrn2   = CONCAT(schema_nm, '.', rtn_nm)
   FROM fnSplitQualifiedName(@qrn);

   SELECT @ty_nm = ty_nm FROM dbo.sysRtns_vw WHERE schema_nm = @schema and rtn_nm = 'fn_CamelCase';

   INSERT INTO @t
   (
       qrn
      ,schema_nm
      ,rtn_nm
      ,rtn_ty
      ,ty_code
      ,is_clr
   )
   SELECT
       @qrn2
      ,schema_nm
      ,rtn_nm
      ,rtn_ty
      ,ty_code
      ,is_clr
   FROM dbo.sysRtns_vw WHERE schema_nm = @schema and rtn_nm = @rtn_nm;

   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_029_fnChkRtnExists';
SELECT * FROM [dbo].[fnGetRtnDetails]('[dbo].[fnIsCharType]');
SELECT * FROM [dbo].[fnGetRtnDetails]('sp_assert_rtn_exists');
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ================================================
-- Author:      Terry Watts
-- Create date: 04-JAN-2021
-- Description: determines if a sql_variant is an
-- approximate type: {float, real or numeric}
-- test: [test].[t 025 fnIsFloat]
-- ================================================
CREATE FUNCTION [dbo].[fnIsFloatType](@ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('float','real','numeric'), 1, 0);
END



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is of type GUID
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsGuidType](@v SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   RETURN iif(CONVERT(VARCHAR(500), SQL_VARIANT_PROPERTY(@v, 'BaseType')) = 'uniqueidentifier', 1, 0);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is an
-- integral type: {int, smallint, tinyint, bigint, money, smallmoney}
-- test: [test].[t 025 fnIsFloat]
--
-- Changes:
-- 241128: added optional check for non negative ints
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsIntType]( @ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('BIT','INT','SMALLINT','TINYINT','BIGINT','MONEY','SMALLMONEY'), 1, 0);
END
/*
SELECT dbo.fnIsInt('0',0) as [fnIsInt('0', 0)], dbo.fnIsInt('05',0) as [fnIsInt(05,0)]
SELECT dbo.fnIsInt('0',1) as [fnIsInt('0',1)], dbo.fnIsInt('05',1) as [dbo.fnIsInt('05',1)]
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 08-DEC-2024
-- Description: Returns true if a time type
--              Handles single and array types like INT and VARCHAR(MAX)
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsTimeType](@ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('date','datetime','datetime2','datetimeoffset','smalldatetime','TIME'), 1, 0);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===================================================================
-- Author:      Terry Watts
-- Create date: 08-DEC-2024
-- Description: Gets the type category for a Sql Uerver datatype
-- e.g. Exact types : INT, MONEY 
-- Floating point types: float real
--
-- TESTS:
-- ===================================================================
CREATE FUNCTION [dbo].[fnGetTypeCat](@ty VARCHAR(25))
RETURNS VARCHAR(25)
AS
BEGIN
   DECLARE @type SQL_VARIANT
   ;

   RETURN
      CASE
         WHEN dbo.fnIsIntType (@ty)     = 1 THEN 'Int'
         WHEN dbo.fnIsTextType(@ty)     = 1 THEN 'Text'
         WHEN dbo.fnIsTimeType(@ty) = 1 THEN 'Time'
         WHEN dbo.fnIsFloatType(@ty)    = 1 THEN 'Float'
         WHEN dbo.fnIsGuidType(@ty)     = 1 THEN 'GUID'
         END;
END
/*
EXEC test.sp__crt_tst_rtns '[dbo].[fnGetTypeCat]';
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is of type BIT
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsBoolType](@v SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   RETURN iif( @v = 'bit', 1,0);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =========================================================
-- Author:      Terry Watts
-- Create date: 05-JAN-2021
-- Description: function to compare values - includes an
--              approx equal check for floating point types
-- Returns 1 if equal, 0 otherwise
-- =========================================================
CREATE FUNCTION [dbo].[fnChkEquals]( @a SQL_VARIANT, @b SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   DECLARE
    @fn     VARCHAR(35)   = N'sp_fnChkEquals'
   ,@res    BIT
   ,@a_str  VARCHAR(4000) = CONVERT(VARCHAR(400), @a)
   ,@b_str  VARCHAR(4000) = CONVERT(VARCHAR(400), @b)
   ,@a_ty   VARCHAR(25)   = CONVERT(VARCHAR(25), SQL_VARIANT_PROPERTY(@a, 'BaseType'))
   ,@b_ty   VARCHAR(25)   = CONVERT(VARCHAR(25), SQL_VARIANT_PROPERTY(@b, 'BaseType'))
   ;

   -- NULL check
   IF @a IS NULL AND @b IS NULL
   BEGIN
      RETURN 1;
   END

   IF @a IS NULL AND @b IS NOT NULL
   BEGIN
      RETURN 0;
   END

   IF @a IS NOT NULL AND @b IS NULL
   BEGIN
      RETURN 0;
   END

   -- if both are floating point types, fnCompareFloats evaluates  fb comparison to accuracy +- epsilon
   -- any differnce less that epsilon is consider insignifacant so considers and b to =
   -- fnCompareFloats returns 1 if a>b, 0 if a==b, -1 if a<b
   IF (dbo.[fnIsFloatType](@a_ty) = 1) AND (dbo.[fnIsFloatType](@b_ty) = 1)
   BEGIN
      RETURN iif(dbo.[fnCompareFloats](CONVERT(FLOAT(24), @a), CONVERT(FLOAT(24), @b)) = 0, 1, 0);
   END

   -- if both are int types
   IF (dbo.fnIsIntType(@a_ty) = 1) AND (dbo.fnIsIntType(@b_ty) = 1)
      RETURN iif(CONVERT(BIGINT, @a) = CONVERT(BIGINT, @b), 1, 0);

   -- if both are string types
   IF (dbo.fnIsTextType(@a_ty) = 1) AND (dbo.fnIsTextType(@b_ty) = 1)
      RETURN iif(@a_str = @b_str, 1, 0);

   -- if both are boolean types
   IF (dbo.fnIsBoolType(@a_ty) = 1) AND (dbo.fnIsBoolType(@b_ty) = 1)
      RETURN iif(CONVERT(BIT, @a) = CONVERT(BIT, @b), 1, 0);

   -- if both are datetime types
   IF (dbo.fnIsTimeType(@a_ty) = 1) AND (dbo.fnIsTimeType(@b_ty) = 1)
      RETURN iif( CONVERT(DATETIME, @a) = CONVERT(DATETIME, @b), 1, 0);

   -- if both are guid types
   IF (dbo.fnIsGuidType(@a_ty) = 1) AND (dbo.fnIsGuidType(@b_ty) = 1)
      RETURN iif(CONVERT(UNIQUEIDENTIFIER, @a) = CONVERT(UNIQUEIDENTIFIER, @b), 1, 0);

   ----------------------------------------------------
   -- Compare by type cat
   ----------------------------------------------------

   DECLARE
    @a_cat  VARCHAR(25)
   ,@b_cat  VARCHAR(25)

   SET @a_cat = [dbo].[fnGetTypeCat](@a_ty);
   SET @b_cat = [dbo].[fnGetTypeCat](@b_ty);

   if(@a_cat = @b_cat)
   BEGIN
      IF @a_cat = 'Int'
      BEGIN
         SET @res = iif(CONVERT(BIGINT, @a) = CONVERT(BIGINT, @b), 1, 0);
      END
      ELSE IF @a_cat = 'Float'
      BEGIN
         SET @res = iif(CONVERT(FLOAT(24), @a) = CONVERT(FLOAT(24), @b), 1, 0);
      END
      ELSE IF @a_cat = 'Text'
      BEGIN
         SET @res = iif(CONVERT(VARCHAR(8000), @a) = CONVERT(VARCHAR(8000), @b), 1, 0);
      END
      ELSE IF @a_cat = 'Time'
      BEGIN
         SET @res = iif(CONVERT(DATETIME2, @a) = CONVERT(DATETIME2, @b), 1, 0);
      END
      ELSE IF @a_cat = 'GUID'
      BEGIN
         SET @res = iif(CONVERT(UNIQUEIDENTIFIER, @a) = CONVERT(UNIQUEIDENTIFIER, @b), 1, 0);
      END

      RETURN @res;
   END

   ----------------------------------------------------------------------
   -- Can compare Floats with integral types -> convert both to big float
   ----------------------------------------------------------------------
   IF (@a_cat='Int' AND @b_cat='Float') OR (@a_cat='Float' AND @b_cat='Int')
   BEGIN
      RETURN iif(CONVERT(FLOAT(24), @a) = CONVERT(FLOAT(24), @b), 1, 0);
   END

   ----------------------------------------------------
   -- Final option: compare by converting to text
   ----------------------------------------------------
   SET @res = iif(@a_str = @b_str, 1, 0)
   RETURN @res;
END



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry watts
-- Create date: 21-JAN-2020
-- Description: 1 line check null or mismatch and throw message
--              ASSUMES data types are the same
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_equal]
    @a         SQL_VARIANT
   ,@b         SQL_VARIANT
   ,@msg0      VARCHAR(MAX)   = NULL
   ,@msg1      VARCHAR(MAX)   = NULL
   ,@msg2      VARCHAR(MAX)   = NULL
   ,@msg3      VARCHAR(MAX)   = NULL
   ,@msg4      VARCHAR(MAX)   = NULL
   ,@msg5      VARCHAR(MAX)   = NULL
   ,@msg6      VARCHAR(MAX)   = NULL
   ,@msg7      VARCHAR(MAX)   = NULL
   ,@msg8      VARCHAR(MAX)   = NULL
   ,@msg9      VARCHAR(MAX)   = NULL
   ,@msg10     VARCHAR(MAX)   = NULL
   ,@msg11     VARCHAR(MAX)   = NULL
   ,@msg12     VARCHAR(MAX)   = NULL
   ,@msg13     VARCHAR(MAX)   = NULL
   ,@msg14     VARCHAR(MAX)   = NULL
   ,@msg15     VARCHAR(MAX)   = NULL
   ,@msg16     VARCHAR(MAX)   = NULL
   ,@msg17     VARCHAR(MAX)   = NULL
   ,@msg18     VARCHAR(MAX)   = NULL
   ,@msg19     VARCHAR(MAX)   = NULL
   ,@ex_num    INT             = 50001
   ,@fn        VARCHAR(35)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
DECLARE
    @fnThis VARCHAR(35) = 'sp_assert_equal'
   ,@aTxt   VARCHAR(100)= CONVERT(VARCHAR(20), @a)
   ,@bTxt   VARCHAR(100)= CONVERT(VARCHAR(20), @b)

   EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';

   IF dbo.fnChkEquals(@a ,@b) <> 0
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, @a:[',@aTxt, '] = @b:[', @bTxt, ']';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fnThis, '020: @a:[',@aTxt, '] <> @b:[', @bTxt, '], raising exception';

   EXEC sp_raise_exception
       @msg0   = @msg0 
      ,@msg1   = @msg1 
      ,@msg2   = @msg2 
      ,@msg3   = @msg3 
      ,@msg4   = @msg4 
      ,@msg5   = @msg5 
      ,@msg6   = @msg6 
      ,@msg7   = @msg7 
      ,@msg8   = @msg8 
      ,@msg9   = @msg9 
      ,@msg10  = @msg10
      ,@msg11  = @msg11
      ,@msg12  = @msg12
      ,@msg13  = @msg13
      ,@msg14  = @msg14
      ,@msg15  = @msg15
      ,@msg16  = @msg16
      ,@msg17  = @msg17
      ,@msg18  = @msg18
      ,@msg19  = @msg19
      ,@ex_num = @ex_num
      ,@fn     = @fn
END
/*
   EXEC tSQLt.RunAll;
   EXEC sp_assert_equal 1, 1;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: Raises exception if exp = act
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_not_equal]
    @a         SQL_VARIANT
   ,@b         SQL_VARIANT
   ,@msg       VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@ex_num    INT             = NULL
   ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
DECLARE
    @fnThis    VARCHAR(35) = 'sp_assert_not_equal'
   ,@aTxt      VARCHAR(100)= CONVERT(VARCHAR(20), @a)
   ,@bTxt      VARCHAR(100)= CONVERT(VARCHAR(20), @b)
   ,@std_msg   VARCHAR(200)

    EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';

   -- a<>b MEANS a<b OR b<a -> !(!a<b AND !(b<a))
   IF ((dbo.fnIsLessThan(@a ,@b) = 1) OR (dbo.fnIsLessThan(@b ,@a) = 1))
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, [',@aTxt, '] <> [', @bTxt, ']';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   --EXEC sp_log 3, @fnThis, '020: [', @aTxt , '] equals [',@bTxt,'], raising exception';
   IF @ex_num IS NULL SET @ex_num = 50003;

   SET @std_msg = CONCAT(@fnThis, ' [', @aTxt , '] equals [',@bTxt,'] ');

   EXEC sp_raise_exception
       @msg1   = @std_msg
      ,@msg2   = @msg
      ,@msg3   = @msg2
      ,@msg4   = @msg3
      ,@msg5   = @msg4
      ,@msg6   = @msg5
      ,@msg7   = @msg6
      ,@msg8   = @msg7
      ,@msg9   = @msg8
      ,@msg10  = @msg9
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@ex_num = @ex_num
      ,@fn     = @fn
   ;
END
/*
-- Smoke test 
EXEC sp_assert_not_equal 0, 1, 'Failed: tested routine not qualified'
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_047_sp_assert_not_equal';
EXEC test.sp__crt_tst_rtns '[dbo].[sp_assert_not_equal]'
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- ======================================================================
-- Author:      Terry Watts
-- Create Date: 06-AUG-2023
-- Description: Checks that the given table is populated    or not
-- Normal mode: this checks to see if the table has atleast 1 row
--
-- However it can be use to Checks that the given table is NOT populated
-- by setting @exp_cnt to 0
--
-- Called by sp_chk_tbl_not_pop
-- ======================================================================
CREATE PROCEDURE [dbo].[sp_assert_tbl_pop]
    @table           VARCHAR(60)
   ,@msg0            VARCHAR(MAX)   = NULL
   ,@msg1            VARCHAR(MAX)   = NULL
   ,@msg2            VARCHAR(MAX)   = NULL
   ,@msg3            VARCHAR(MAX)   = NULL
   ,@msg4            VARCHAR(MAX)   = NULL
   ,@msg5            VARCHAR(MAX)   = NULL
   ,@msg6            VARCHAR(MAX)   = NULL
   ,@msg7            VARCHAR(MAX)   = NULL
   ,@msg8            VARCHAR(MAX)   = NULL
   ,@msg9            VARCHAR(MAX)   = NULL
   ,@msg10           VARCHAR(MAX)   = NULL
   ,@msg11           VARCHAR(MAX)   = NULL
   ,@msg12           VARCHAR(MAX)   = NULL
   ,@msg13           VARCHAR(MAX)   = NULL
   ,@msg14           VARCHAR(MAX)   = NULL
   ,@msg15           VARCHAR(MAX)   = NULL
   ,@msg16           VARCHAR(MAX)   = NULL
   ,@msg17           VARCHAR(MAX)   = NULL
   ,@msg18           VARCHAR(MAX)   = NULL
   ,@display_msgs    BIT            = 0
   ,@exp_cnt         INT            = NULL
   ,@ex_num          INT            = 56687
   ,@ex_msg          VARCHAR(500)   = NULL
   ,@fn              VARCHAR(35)    = N'*'
   ,@log_level       INT            = 0
   ,@display_row_cnt BIT            = 1
AS
BEGIN
   DECLARE 
    @fnThis          VARCHAR(35)   = N'sp_assert_tbl_pop'
   ,@sql             NVARCHAR(MAX)
   ,@act_cnt         INT           = -1
   ,@schema_nm       VARCHAR(50)
   ;

   SET NOCOUNT ON;

   SELECT 
       @table     = rtn_nm 
      ,@schema_nm = schema_nm
   FROM dbo.fnSplitQualifiedName(@table)
   ;

   SET @sql = CONCAT('SELECT @act_cnt = COUNT(*) FROM [', @schema_nm, '].[', @table, ']');
   EXEC sp_executesql @sql, N'@act_cnt INT OUT', @act_cnt OUT

   IF @display_row_cnt = 1
   BEGIN
      EXEC sp_log 1, @fnThis, @msg0, 'table:[', @table, '] has ', @act_cnt, ' rows';
   END

   IF @exp_cnt IS NOT null
   BEGIN
      IF @exp_cnt <> @act_cnt
      BEGIN
         IF @ex_msg IS NULL
            SET @ex_msg = CONCAT('Table: ', @table, ' row count: exp ',@exp_cnt,'  act:', @act_cnt);

         EXEC sp_log 4, @fnThis ,'040: @exp_cnt (', @exp_cnt, ')<> @act_cnt (', @act_cnt, ') raising exception: ',@ex_msg;
       --EXEC sp_raise_exception @ex_num, @ex_msg, 1, @fn=@fn;
         EXEC sp_raise_exception
             @ex_num = @ex_num
            ,@msg0   = @ex_msg
            ,@msg1   = @msg0
            ,@msg2   = @msg1
            ,@msg3   = @msg2
            ,@msg4   = @msg3
            ,@msg5   = @msg4
            ,@msg6   = @msg5
            ,@msg7   = @msg6
            ,@msg8   = @msg7
            ,@msg9   = @msg8
            ,@msg10  = @msg9
            ,@msg11  = @msg10
            ,@msg12  = @msg11
            ,@msg13  = @msg12
            ,@msg14  = @msg13
            ,@msg15  = @msg14
            ,@msg16  = @msg15
            ,@msg17  = @msg16
            ,@msg18  = @msg17
            ,@msg19  = @msg18
            ,@fn     = @fn
            ;
      END
   END
   ELSE
   BEGIN -- Check at least 1 row
      IF @act_cnt = 0
      BEGIN
         IF @ex_msg IS NULL
            SET @ex_msg = CONCAT('Table: ', @table, ' does not have any rows');

         EXEC sp_log 4, '070: table ',@table,' has no rows: ', @ex_msg;
         THROW @ex_num, @ex_msg, 1;
      END
   END
END
/*
   -- This should not create an exception as dummytable has rows
   EXEC dbo.sp_assert_tbl_po 'use'
   EXEC dbo.sp_assert_tbl_po 'dummytable'
   
   -- This should create the following exception:
   -- Msg 56687, Level 16, State 1, Procedure dbo.sp_assert_tbl_po, Line 27 [Batch Start Line 37]
   -- Table: [AppLog] does not have any rows
    
   EXEC dbo.sp_assert_tbl_po 'AppLog'
   IF EXISTS (SELECT 1 FROM [dummytable]) PRINT '1' ELSE PRINT '0'
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =========================================================================
-- Author:      Terry Watts
-- Create date: 03-Dec-2023
-- Description: gets the next test rtn number
--
--- changes:
-- 240419: speeded up this routine by NOT USING the SQL# IsNumeric routine
-- 241111: first look for the first unused trn less than the max used trn
--         if not found take the max used trn + 1
-- =========================================================================
CREATE FUNCTION [test].[fnGetNxtTstRtnNum]()
RETURNS INT
AS
BEGIN
   DECLARE @ret INT

   -- first look for the first unused trn less than the max used trn
   SET @ret =
   (
      SELECT TOP 1 FORMAT(trn+1, '000') AS nxt_trn
      FROM
      (
         SELECT SUBSTRING(rtn_nm, 6,3) AS trn, LEAD(SUBSTRING(rtn_nm, 6,3)) OVER(ORDER BY rtn_nm) AS nxt_trn
         FROM SysRtns_vw 
         WHERE
             schema_nm = 'test'
         AND ty_code   = 'P'
         AND rtn_nm like 'test%'
         AND iif(SUBSTRING(rtn_nm, 6,3) LIKE '[0-9][0-9][0-9]', CONVERT(int, SUBSTRING(rtn_nm, 6,3)), 0) > 0
      ) X
      WHERE nxt_trn>trn + 1
   );

   -- If not found take the max used trn + 1
   IF @ret IS NULL
      SELECT @ret = next_rtn_num
      FROM
      (
         SELECT CONVERT(INT, last_rtn_num)+1 AS next_rtn_num
         FROM
         (
            SELECT MAX(SUBSTRING(rtn_nm, 6,3)) as last_rtn_num 
            FROM SysRtns_vw 
            WHERE 
               schema_nm='test'
               AND ty_code = 'P'
               AND rtn_nm like 'test%'
               AND IIF(SUBSTRING(rtn_nm, 6,3) LIKE '[0-9][0-9][0-9]', CONVERT(int, SUBSTRING(rtn_nm, 6,3)), 0) > 0
         ) X
      ) Y;

   IF @ret IS NULL SET @ret = 0;
   RETURN @ret;
END
/*
PRINT test.fnGetNxtTstRtnNum();
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 05-JUL-2020
-- Description: creates the test helper routine name
-- =============================================
CREATE FUNCTION [test].[fnCreateTestRtnName]
(
       @tstd_rtn_nm  VARCHAR(100)
      ,@tst_rtn_num  INT 
      ,@tst_rtn_ty   VARCHAR(1)-- M: main test, H = helper
)
RETURNS VARCHAR(50)
AS
BEGIN
   RETURN 
      CONCAT
      (
         CASE
            WHEN @tst_rtn_ty = 'M' THEN 'test'
            ELSE 'hlpr'
         END
         ,'_'
        ,CASE
            WHEN @tst_rtn_num IS NOT NULL THEN FORMAT(@tst_rtn_num, '000')
            ELSE ''
         END
         ,'_', @tstd_rtn_nm
      );
END
/*
PRINT test.fnCreateTestRtnName('fnLen',43, 'M');
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================================================================================================
-- Author:      Terry Watts
-- Create date: 20-APR-2024
-- Description: Gets the routine details for the routine @q_rtn_nm
--    Populates
--       PopulatesTest.RtnDetails   with the rtn level details only, not the param specific data like max param length
--       ** Does not populate Test.ParamDetails table
--
-- Responsibilities:
-- Sole populator of the 2 rtn metadata tables: {Test.RtnDetails, Test.RtnParamDetails}

-- Parameters:
-- @q_tstd_rtn the qualified tested routine name <schema>.<routine> optionally wrapped in []
--
-- Preconditions: none
-- PRE 01: @qrn must be specified - not null, empty or just dot or whitespace
--
-- Postconditions:
-- Populates
--       Test.RtnDetails   with the rtn level details
--
------------------------------------------------------------------------------------------------------
-- RULES     Rule                       Ex num  ex msg
------------------------------------------------------------------------------------------------------
-- POST 01: if routine not found and @throw_if_err is true then throw exception 70003, 'Routine [[<@schema_nm>].[<@rtn_nm>]] not found'
-- POST 02: Test.RtnDetails      pop OR 70101,  Could not find the routine   details for <@q_tstd_rtn>
-- POST 03: Test.RtnParamDetails pop OR 70102,  Could not find the parameter details for <@q_tstd_rtn>
-- POST 04: qrn returned fully qualified with schema
-- POST 05: if routine not found and @throw_if_err is false then pop rtnDetails with the rtn name details only
-- POST 06: test.rtnDetails has 1 row or exception 70004, 'failed to populate Test.RtnDetails properly'
--
-- Algorithm:
-- 1. Removes square brackets
-- 2. Validate parameters
-- 2. Pop Test.RtnDetails   with the rtn level details
--
-- Called by: sp_set_rtn_details
--
-- Tests: test.hlpr_034_get_rtn_parameters
--
-- Changes:
-- 240415: redesign, added several fields to make the test rtn creation easier
-- 241111: if @trn not supplied look for the first unused trn
-- 241121: bugfix: qrn with leading space causes rtn not found error. FIX:  trim the qrn after de square bracket
-- 241227: @qrn must be specified - not null, empty or just dot or whitespace
-- ======================================================================================================================================
CREATE PROCEDURE [test].[sp_pop_rtn_details]
    @qrn             VARCHAR(150) OUT
   ,@trn             INT      = NULL
   ,@cora            NCHAR(1) = NULL
   ,@ad_stp          BIT      = NULL -- used in testing to identify a step with a unique name (not an incremental int id)
-- ,@tst_mode        BIT      = 1    -- for testing - copy tmp tables to permananent tables for teting
-- ,@stop_stage      INT      = 12   -- stage 12 for testing - display script
   ,@throw_if_err    BIT      = 1
   ,@display_tables  BIT      = 0
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)   = 'sp_pop_rtn_details'
   ,@schema_nm    VARCHAR(50)
   ,@rtn_nm       VARCHAR(100)
   ,@rtn_ty       VARCHAR(2)
   ,@ty_code      VARCHAR(2)
   ,@cnt          INT
   ,@tst_rtn_nm   VARCHAR(50)
   ,@hlpr_rtn_nm  VARCHAR(50)
   ,@is_clr       BIT
   ,@max_prm_len  INT
   ,@msg          VARCHAR(500)

   EXEC sp_log 2, @fn, '000: starting
@qrn           :[', @qrn           ,']
@trn           :[', @trn           ,']
@cora          :[', @cora          ,']
@ad_stp        :[', @ad_stp        ,']
@throw_if_err  :[', @throw_if_err  ,']
@display_tables:[', @display_tables,']
';
--@tst_mode      :[', @tst_mode      ,']
--@stop_stage    :[', @stop_stage    ,']


   BEGIN TRY
      DELETE FROM Test.RtnDetails;
      DELETE FROM Test.ParamDetails;

      --------------------------------------------------------------------------------------
      -- Validate parameters
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '005: Validating parameters: removing [] brackets';
      SET @qrn = TRIM(dbo.fnDeSquareBracket(@qrn)); -- 241121 bugfix: qrn with leading space causes rtn not found error. FIX:  trim the qrn after de square bracket
      -- PRE 01: @qrn must be specified - not null, empty or just dot or whitespace
      EXEC sp_assert_not_null_or_empty @qrn, ' @qrn not specified', @fn=@fn;
      IF @qrn LIKE '.%' OR @qrn LIKE '%.'
         EXEC sp_raise_exception @msg1='@qrn must be specified - not null, empty or just dot or whitespace';

      --------------------------------------------------------------------------------------
      -- ASSERTION: Validated parameters
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '010: ASSERTION: Validated parameters';

      --------------------------------------------------------------------------------------
      -- Process
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: Process';
      EXEC sp_log 1, @fn, '030: Calling fnGetRtnDetails(', @qrn, ')';

      -- 241227: When qrn is not qualified with a schemqa - we can get it if the routine name is unique accross schemas
      SELECT
          @qrn       = qrn
         ,@schema_nm = schema_nm
         ,@rtn_nm    = rtn_nm
         ,@rtn_ty    = rtn_ty
         ,@ty_code   = ty_code
         ,@is_clr    = is_clr
      FROM dbo.fnGetRtnDetails(@qrn);

      EXEC sp_log 1, @fn, '040: fnGetRtnDetails(',@qrn,') returned
             @qrn       = [@schema_nm = [', @schema_nm, ']
             @rtn_nm    = [', @rtn_nm   , ']
             @rtn_ty    = [', @rtn_ty   , ']
             @ty_code   = [', @ty_code  , ']
             @is_clr    = [', @is_clr   , ']'
      ;

      IF @schema_nm IS NULL
      BEGIN
         -- POST 01: if routine not found and @throw_if_err is true then throw exception 70003, 'Routine [[<@schema_nm>].[<@rtn_nm>]] not found'
         EXEC sp_log 4, @fn, '050: routine ',@qrn, ' does not exist';

         IF @throw_if_err = 1
         BEGIN
            SET @msg = CONCAT('routine [',@schema_nm,'.',@rtn_nm,'] was not found');
            EXEC sp_raise_exception 70003, @msg, @fn=@fn;
         END
         ELSE
            -- POST 05: if routine not found and @throw_if_err is false then pop rtnDetails with the rtn name details only
            EXEC sp_log 4, @fn, '060: routine ',@qrn, ' does not exist. @throw_if_err = 0 so pop table with rtn name details only';
            INSERT INTO test.RtnDetails(qrn, schema_nm, rtn_nm)
            VALUES (@qrn, @schema_nm, @rtn_nm);
      END

      EXEC sp_log 1, @fn, '070:';

      IF @cora IS NULL
         SET @cora = 'C';

      IF @cora NOT IN ('A','C')
      BEGIN
         EXEC sp_log 4, @fn, '080: @cora  NOT IN (''A'',''C''):[',cora, ']';

         IF @throw_if_err = 1
         BEGIN
            EXEC sp_log 4, @fn, '090 : unknown create mode [',@cora, ']';
            EXEC sp_raise_exception 70100, 'Create or alter param must be 1 of {NULL, ''A'' ''C''}', @cora;
         END
         ELSE
         BEGIN
            EXEC sp_log 4, @fn, '100 : unknown create mode [',@cora, ']';
            SET @cora = 'unknown create mode';
         END
      END

      -- Return this to client code
      IF @ad_stp     IS NULL SET @ad_stp     = 1;
      IF @trn        IS NULL SET @trn        = test.fnGetNxtTstRtnNum(); -- this is very slow
--      IF @tst_mode   IS NULL SET @tst_mode   = 1;
--      IF @stop_stage IS NULL SET @stop_stage = 12;

      EXEC sp_log 1, @fn, '110: modified params:
@qrn         :[', @qrn         ,']
@trn         :[', @trn         ,']
@cora        :[', @cora        ,']
@ad_stp      :[', @ad_stp      ,']
';
-- @tst_mode    :[', @tst_mode    ,']
-- @stop_stage  :[', @stop_stage  ,']


      --------------------------------------------------------------------------------------
      -- Validate parameters Complete
      --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '120: ASSERTION Validated set any defaults as needed';

      --------------------------------------------------------------------------------------
      -- Process
      --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '130: Process'

      EXEC sp_log 1, @fn, '140: populating the RtnDetails table   '
      SET @tst_rtn_nm   = test.fnCreateTestRtnName(@rtn_nm, @trn, 'M');
      SET @hlpr_rtn_nm  = test.fnCreateTestRtnName(@rtn_nm, @trn, 'H');

      -- 2. Pop Test.RtnDetails with the rtn level details
      INSERT INTO Test.RtnDetails
           ( schema_nm, rtn_nm, rtn_ty, rtn_ty_code, trn, qrn, cora, ad_stp, /*tst_mode,stop_stage, */ tst_rtn_nm, hlpr_rtn_nm, is_clr, display_tables)
      SELECT schema_nm, rtn_nm, rtn_ty, ty_code    ,@trn,@qrn,@cora,@ad_stp,/*@tst_mode,@stop_stage,*/ @tst_rtn_nm,@hlpr_rtn_nm, is_clr,@display_tables
      FROM SysRtns_vw
      WHERE schema_nm = @schema_nm
      AND   rtn_nm    = @rtn_nm;

      SET @cnt = @@ROWCOUNT;
      EXEC sp_log 1, @fn, '145: imported ', @cnt, ' rows';

      IF @display_tables = 1
      BEGIN
         EXEC sp_log 1, @fn, '147: displaying Test.RtnDetails rows';
         SELECT * FROM Test.RtnDetails;
      END

      --------------------------------------------------------------------------------------
      -- Check postconditions
      --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '150: Checking postconditions   ';
      -- POST 01: find the routine         OR 70100,  Could not find the routine <@q_tstd_rtn>               chd already
      -- POST 02: Test.RtnDetails      pop OR 70101,  Could not find the routine   details for <@q_tstd_rtn> chd already
      -- POST 03: Test.RtnParamDetails pop OR 70102,  Could not find the parameter details for <@q_tstd_rtn> chd already
      -- POST 04: qrn returned fully qualified with schema
      EXEC sp_log 1, @fn, '160: checking results in the RtnDetails table, @cnt:',@cnt, ''

      -- POST 02: Test.RtnDetails      pop OR 70101,  Could not find the routine   details for <@q_tstd_rtn>
      IF @cnt = 0
      BEGIN
         EXEC sp_log 4, @fn, '170: Could not find the routine details for [',@qrn,']';

         IF @throw_if_err = 1
         BEGIN
            EXEC sp_raise_exception 70100, '180: Could not find the routine details for ',@qrn;
         END
         ELSE
         BEGIN
            EXEC sp_log 4, @fn, '190 : continuing process since @throw_if_err = 0';
         END
      END

      EXEC sp_log 1, @fn, '200: checking  RtnDetails table row count = 1'
      EXEC sp_assert_equal 1, @cnt, '[',@cnt,']) rows were returned in the RtnDetails table, should be 1 row', @ex_num=70110;

      SET @cnt = CHARINDEX('.', @qrn);
      EXEC sp_log 1, @fn, '210 dot pos: ', @cnt, ' @qrn: [',@qrn,']';
      EXEC sp_assert_not_equal 0, @cnt ,'Failed: tested routine not qualified';
      EXEC sp_log 1, @fn, '220';
      -- POST 06: test.rtnDetails has 1 row or exception 70004, 'failed to populate Test.RtnDetails properly'
      EXEC sp_assert_tbl_pop 'test.rtnDetails', @exp_cnt =1, @ex_num=70004, @ex_msg='failed to populate Test.RtnDetails properly';
      EXEC sp_log 1, @fn, '230';

      --------------------------------------------------------------------------------------
      -- Process complete
      --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '900: Process complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving';
END
/*
EXEC test.sp_pop_rtn_details 'test.sp_compile_rtn', @display_tables=1;
SELECT * frOM test.rtnDetails;
EXEC sp_set_log_level 0
PRINT DB_NAME()
EXEC tSQLt.Run 'test.test_090_sp_get_rtn_details';
EXEC tSQLt.Run 'test.test_034_sp_pop_param_details';
EXEC tSQLt.RunAll;
SELECT * FROM dbo.fnGetRtnDetails('test.sp_tst_hlpr_st');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- ===================================================================================================
-- Author:      Terry Watts
-- Create date: 03-APR-2024
-- Rtn:         test.sp_set_rtn_details
-- Description: Gets the routine details for the routine @q_rtn_nm
--    Populates
--       Test.RtnDetails   with the rtn level details
--       Test.ParamDetails with the parameter level details
--
-- Responsibilities:
-- Main entry point for the population of the 2 rtn metadata tables: {Test.RtnDetails, Test.RtnParamDetails}

-- Parameters:
-- @q_tstd_rtn the qualified tested routine name <schema>.<routine> optionally wrapped in []
--
-- Preconditions: none
--
-- Postconditions:
-- Populates
--       Test.RtnDetails   with the rtn level details
--       Test.ParamDetails with the parameter level details
------------------------------------------------------------------------------------------------------
-- RULES     Rule                       Ex num  ex msg
------------------------------------------------------------------------------------------------------
-- POST 01: find the routine         OR 70100,  Could not find the routine <@q_tstd_rtn>
-- POST 02: Test.RtnDetails      pop OR 70101,  Could not find the routine   details for <@q_tstd_rtn>
-- POST 03: Test.RtnParamDetails pop OR 70102,  Could not find the parameter details for <@q_tstd_rtn>
-- POST 04: qrn returned fully qualified with schema
--
-- Algorithm:
-- 1. populate test.RtnDetailsn   using sp_pop_rtn_details
-- 2. populate test.ParamDetails using sp_pop_param_details
-- All checks are delegated to the 2 pop rtns
--
-- Tests: test.hlpr_034_get_rtn_parameters
--
-- Changes:
-- 240415: redesign, added several fields to make it eassier to use latter in the test rtn creation
-- 241031: removed @tst_mode param
-- 241111: if @trn not supplied look for the first unused trn
-- ===================================================================================================
CREATE PROCEDURE [test].[sp_set_rtn_details]
    @qrn             VARCHAR(150)
   ,@trn             INT      = NULL
   ,@cora            NCHAR(1) = NULL
   ,@ad_stp          BIT      = NULL -- for teting
   ,@throw_if_err    BIT      = 1
   ,@display_tables  BIT      = 0
AS
BEGIN
   DECLARE
     @fn             VARCHAR(35)   = 'sp_set_rtn_details'
    ,@schema_nm      VARCHAR(50)
    ,@rtn_nm         VARCHAR(100)
    ,@cnt            INT
    ,@tst_rtn_nm     VARCHAR(50)
    ,@hlpr_rtn_nm    VARCHAR(50)
    ,@line           VARCHAR(100)= REPLICATE('-', 100)
   BEGIN TRY
      --------------------------------------------------------------------------------------------------------
      -- Pop the RtnDetails table
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '000: starting
qrn           :[', @qrn           ,']
trn           :[', @trn           ,']
cora          :[', @cora          ,']
ad_stp        :[', @ad_stp        ,']
throw_if_err  :[', @throw_if_err  ,']
display_tables:[', @display_tables,']'
;
      EXEC sp_log 1, @fn, '005: populating the RtnDetails table   ';
      EXEC test.sp_pop_rtn_details
          @qrn          = @qrn         OUT
         ,@trn          = @trn
         ,@cora         = @cora
         ,@ad_stp       = @ad_stp
         ,@throw_if_err = @throw_if_err
            ;

      --------------------------------------------------------------------------------------------------------
      -- Pop the param details
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '010:  populating the ParamDetails table   '
      EXEC test.sp_pop_param_details @throw_if_err = @throw_if_err;

      --------------------------------------------------------------------------------------
      -- Process complete
      --------------------------------------------------------------------------------------

      IF @display_tables = 1
      BEGIN
         SELECT @line;
         PRINT 'test.RtnDetails:'
         SELECT @line;
         SELECT * FROM test.RtnDetails;
PRINT '';
         SELECT @line;
         PRINT 'test.ParamDetails:'
         SELECT @line;
         SELECT * FROM test.ParamDetails;
         SELECT @line;
      END

      EXEC sp_log 1, @fn, '900: Process complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving';
END
/*
EXEC test.sp__crt_tst_rtns 'test].[sp_set_rtn_details'
EXEC test.sp_get_rtn_details 'dbo.sp_class_creator', @display_tables=1;
EXEC tSQLt.Run 'test.test_034_sp_get_param_details';
EXEC tSQLt.Run 'test.test_090_sp_get_rtn_details';
EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==================================================================
-- Author:      Terry Watts
-- Create date: 07-APR-2024
-- Description: Initialises state for both the main and the helper test rtns
--    i.e. populates 2 test tables: RtnDetails, ParamDetails
--
-- Preconditions: none
--
-- Postconditions:
-- POST 01: Test.RtnDetails, Test.ParamDetails tables populated or exception
--          fro exception details see sp_get_rtn_details
--
-- Algorithm
--    Populate Test.RtnDetails, Test.ParamDetails tables
--
-- Changes:
-- 231124: added remove [] brackets to make it easier to set up tests
-- 240415: redesign, rewrite
-- 241031: removed @tst_mode param
-- 241111: if @trn not supplied look for the first unused trn
-- ==================================================================
CREATE PROCEDURE [test].[sp_crt_tst_rtns_init]
    @qrn        VARCHAR(100) -- tested rtn name including the schema - returns it tidied up if necessary
   ,@trn        INT           = NULL
   ,@cora       NCHAR(1)      = 'C'
   ,@ad_stp     BIT           = 0    -- used in testing to identify a step with a unique name (not an incremental int id)
--   ,@stop_stage INT           = 12   -- stage 12 for testing - display script
AS
BEGIN
   DECLARE 
      @fn        VARCHAR(35)   = 'CRT_TST_RTNS_INIT'
     ,@n         INT

   SET NOCOUNT ON;

   EXEC sp_log 2, @fn, '000: starting
@qrn   :[', @qrn,']
@trn   :[', @trn,']
@ad_stp:[', @ad_stp,']'
;

   --  populate the 2 routine details tables
   EXEC test.sp_set_rtn_details @qrn, @trn, @cora, @ad_stp, 1 -- 1: throw if error
   SELECT * FROM [test].[RtnDetails];
   SELECT * FROM [test].[ParamDetails];
   EXEC sp_log 2, @fn, '999: leaving OK';
END
/*
EXEC tSQLt.Run 'test.test_068_sp_crt_tst_rtns';

EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==================================================================================
-- Author:      Terry Watts
-- Create date: 03-MAY-2024
-- Description: 
-- Creates the helper decl bloc for the act params output by teh teted rtn like:
--   ,@act_row_cnt     INT
--   ,@act_file_path   VARCHAR(4000)            -- comma separated
--   ,@act_range       VARCHAR(4000)            -- comma separated
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions: return table with the CoreParams
--
-- Called by: test.fnCrtHlprCodeDecl
-- ==================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeDeclActParams]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
       @tab1           NCHAR(3) = '   '
      ,@tab2           NCHAR(6) = '      '
      ,@rtn_ty_code    VARCHAR(2)
      ,@sc_fn_ret_ty   VARCHAR(20)
      ,@ad_stp         BIT
      ,@max_prm_len    INT
      ;

    SELECT
       @rtn_ty_code  = rtn_ty_code
      ,@ad_stp       = ad_stp
      ,@sc_fn_ret_ty = sc_fn_ret_ty
      ,@max_prm_len  = max_prm_len + 5
   FROM test.RtnDetails;

   IF @ad_stp = 1
      INSERT INTO @t (line) VALUES
      (CONCAT(@tab1, '-- fnCrtHlprCodeDeclActParams'))
      ;

   -- IF a Procedure declare any act out params and set to exp params initially
   INSERT INTO @t (line)
   SELECT
       CONCAT
         (
             @tab1, ',@act_', dbo.fnPadRight(param_nm, @max_prm_len), ' ', dbo.fnPadRight(UPPER(type_nm), 15)
             -- 241219: only assign the expected value if it is an out param, else assing NULL
          --  ,iif( , CONCAT(' = @exp_', param_nm), '')
         )
   FROM test.ParamDetails
   WHERE tst_ty='EXP' AND is_output = 0;
   ;

   -- 241217: this duplicates @act_row_cnt ?? removed - need to test against FN, TF
   -- Add the output cols as act
   IF @rtn_ty_code = 'P'
   BEGIN
      INSERT INTO @t (line)
      SELECT
          CONCAT(@tab1, ',@act_', dbo.fnPadRight(param_nm, @max_prm_len), ' ', dbo.fnPadRight(UPPER(type_nm), 15), ' = @exp_', param_nm)
      FROM test.ParamDetails
      WHERE is_output = 1
      ;
   END

   IF @rtn_ty_code = 'FN'
   BEGIN
      INSERT INTO @t (line)
      SELECT
          CONCAT(@tab1, ',@act_', dbo.fnPadRight(param_nm, @max_prm_len), ' ', dbo.fnPadRight(UPPER(type_nm), 15), ' = @exp_', param_nm)
      FROM test.ParamDetails
      WHERE is_output = 1
      ;
   END

   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeDeclActParams();
SELECT * FROM test.ParamDetails;
EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==================================================================================
-- Author:      Terry Watts
-- Create date: 03-MAY-2024
-- Description: 
-- Creates the helper decl bloc for the  core params as follows:
-- DECLARE
--     @fn          VARCHAR(35) = N'hlpr_093_sp_class_creator'
--    ,@act_row_cnt INT
--    ,@act_ex_num  INT
--    ,@act_ex_msg  VARCHAR(500)
--    ,@error_msg   VARCHAR(1000)
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions: return table with the CoreParams
--
-- Called by: test.fnCrtHlprCodeDecl
-- ==================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeDeclCoreParams]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1               NCHAR(3) = '   '
   ,@tab2               NCHAR(6) = '      '
   ,@rtn_ty_code        VARCHAR(2)
   ,@ad_stp             BIT
   ,@max_prm_len        INT
   ,@tst_proc_hlpr_nm   VARCHAR(60)

    SELECT
       @tst_proc_hlpr_nm= hlpr_rtn_nm
      ,@ad_stp          = ad_stp
      ,@rtn_ty_code     = rtn_ty_code
      ,@max_prm_len     = max_prm_len +10
    FROM test.RtnDetails

   IF @ad_stp = 1
      INSERT INTO @t (line) VALUES
      (CONCAT(@tab1, '-- fnCrtHlprCodeDeclCoreParams'))

   INSERT INTO @t (line) VALUES
       (CONCAT(@tab1, 'DECLARE'))
      ,(CONCAT(@tab1, dbo.fnPadRight(' @fn'        , @max_prm_len+2), 'VARCHAR(35)', '    = N''',@tst_proc_hlpr_nm, ''''))
      ,(CONCAT(@tab1, dbo.fnPadRight(',@error_msg' , @max_prm_len+2), 'VARCHAR(1000)'))

   --IF @rtn_ty_code = 'P'
   -- INSERT INTO @t (line) VALUES (CONCAT(@tab1, dbo.fnPadRight(',@act_RC', @max_prm_len+1), ' INT'))

   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeDeclCoreParams();
EXEC test.sp_get_rtn_details 'dbo].AsInt', @display_tables = 1;
SELECT * FROM test.RtnDetails;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================
-- Author:      Terry Watts
-- Create date: 03-MAY-2024
-- Description:
-- Creates the helper decl bloc
-- -- ==================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeDecl]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
     @tab1              NCHAR(3) = '   '
    ,@ad_stp            BIT

    SELECT
      @ad_stp           = ad_stp
    FROM test.RtnDetails

IF @ad_stp = 1
      INSERT INTO @t (line) VALUES
      (CONCAT(@tab1, '-- fnCrtHlprCodeDecl'))

   INSERT INTO @t (line)
   SELECT line
   FROM test.fnCrtHlprCodeDeclCoreParams();

   INSERT INTO @t (line)
   SELECT line
   FROM test.fnCrtHlprCodeDeclActParams();

   RETURN;
END
/*
SELECT line from test.fnCrtHlprCodeDecl();
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================
-- Author:      Terry Watts
-- Create date: 17-Apr-2024
-- Description: creates the log parameter list for a test helper
-- when listing the paramaters intially with sp_log
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions: return table with the tst, inp and exp prms
-- =============================================================
CREATE FUNCTION [test].[fnCrtHlprLogParams]()
RETURNS @t TABLE
(
    id    INT
   ,line  VARCHAR(80)
)
AS
BEGIN
   DECLARE
    @fn                 VARCHAR(35)= 'fnCrtHlprLogParams'
   ,@tab                VARCHAR(3) = '   '
   ,@rtn_ty_code        NCHAR(2)
   ,@tst_proc_hlpr_nm   VARCHAR(60)
   ,@detld_rtn_ty_code  VARCHAR(2)
   ,@qrn                VARCHAR(100)
   ,@sc_fn_ret_ty       VARCHAR(50)
   ,@ad_stp             BIT         = 0
   ,@tst_rtn_nm         VARCHAR(60)
   ,@max_prm_len        INT

   SELECT
       @tst_rtn_nm   = tst_rtn_nm
      ,@ad_stp       = ad_stp
      ,@rtn_ty_code  = rtn_ty_code
      ,@max_prm_len  = max_prm_len
   FROM test.RtnDetails;

   ------------------------------------------
   -- Create the input params
   ------------------------------------------
   SELECT @max_prm_len = MAX(dbo.fnLen(param_nm)) FROM test.paramDetails
   --INSERT INTO @t (line) SELECT @max_prm_len as max_prm_len;

   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          dbo.fnPadRight(lower(param_nm), @max_prm_len+4)
         ,':['', @'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len+4)
         ,','']', iif(@ad_stp = 1, ' -- TST', '')
       --  ,iif(ordinal = 1, CONCAT('-- ', @fn), '')
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'TST'
   ;

   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          'inp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,':['', @inp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,','']', iif(@ad_stp = 1, ' -- INP', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'INP'
   ;

   ------------------------------------------
   -- Create the exp paams
   ------------------------------------------
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          'exp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,':['', @exp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,','']', iif(@ad_stp = 1, ' -- EXP 1', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty ='EXP' AND is_exception = 0
   ;

   ----------------------------------------------------
   -- Add @exp_RC param if tstd rtn is a procedure
   ----------------------------------------------------
   IF(@rtn_ty_code = 'P')
   INSERT INTO @t (line) VALUES
   (
      CONCAT
      (
          dbo.fnPadRight('exp_RC', @max_prm_len + 4)
         ,':['', @exp_'
         ,dbo.fnPadRight('RC', @max_prm_len)
         ,','']', iif(@ad_stp = 1, ' -- SP', '')
      )
   )

   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          dbo.fnPadRight(lower(param_nm), @max_prm_len+4)
         ,':['', @exp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,','']', iif(@ad_stp = 1, ' -- EXP 2', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty ='EXP' AND is_exception = 1
   ;

   INSERT INTO @t (line) VALUES
    (''';')
    ;

   RETURN;
END
/*
   EXEC tSQLt.Run 'test.test_056_fnCrtHlprLogParams';
select line FROM test.fnCrtHlprLogParams()

EXEC tSQLt.Run 'test.test_051_fnCrtHlprLogParams';
EXEC test.sp__crt_tst_rtns 'dbo].[fnSplitKeyValuePairs'
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 17-Dec-2023
-- Description: creates the scriptlet for stage 07 of test.sp_crt_tst_hlpr
--
-- POSTCONDITIONS:
-- RETURNS: @rtnDef
-- POST 01:
--
-- 241205: added sp_lop starting with parameter list
--         simplified logic and sorted tab issues
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeBegin]()
RETURNS @t TABLE 
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1           VARCHAR(3) = '   '
   ,@tab2           VARCHAR(6) = '      '
   ,@ad_stp         BIT
   ,@rtn_ty         VARCHAR(2)
   ,@max_prm_len    INT

   SELECT
       @rtn_ty       = rtn_ty
      ,@max_prm_len  = max_prm_len
      ,@ad_stp       = ad_stp
   FROM
      test.RtnDetails;

   ------------------------------------------------------------------------------------------------
   -- Add the As - BEGIN-DECL
   ------------------------------------------------------------------------------------------------
   INSERT INTO @t (line) VALUES
    (CONCAT('AS', IIF(@ad_stp = 1 ,' -- fnCrtHlprCodeBegin', '')))
   ,('BEGIN')

   INSERT INTO @t(line)
   SELECT line
   FROM test.fnCrtHlprCodeDecl();

   INSERT INTO @t (line) VALUES
    ('')
   ,(CONCAT(@tab1,'BEGIN TRY'))
   ,(CONCAT(@tab2,'EXEC test.sp_tst_hlpr_st @tst_num;'))
   ,('')
   ,(CONCAT(@tab2,'EXEC sp_log 1, @fn ,'' starting'))
   ;

   INSERT INTO @t (line) SELECT line FROM test.fnCrtHlprLogParams();

   INSERT INTO @t (line) VALUES
    ('')
   ,(CONCAT(@tab2,'-- SETUP: ??'))
   ,('')
   ;

   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeBegin();
EXEC test.sp_get_rtn_details 'dbo.sp_class_creator', @ad_stp=1, @display_tables = 1;
EXEC tSQLt.Run 'test.test_025_sp_crt_tst_hlpr_script';

EXEC tSQLt.RunAll;
SELECT * FROM test.RtnDetails;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================    
-- Author:      Terry Watts
-- Create date: 22-MAR-2020
-- Description: Pads Left
-- =============================================    
CREATE FUNCTION [dbo].[fnPadLeft2]( @s VARCHAR(500), @width INT, @pad VARCHAR(1)=' ')
RETURNS VARCHAR (1000)
AS
BEGIN
   DECLARE 
    @ret  VARCHAR(1000)
   ,@len INT

   IF @s IS null
      SET @s = '';

   SET @len = dbo.fnLen(@s);

   RETURN iif(@len < @width
      , RIGHT( CONCAT( REPLICATE( @pad, @width-@len), @s), @width)
      , RIGHT(@s, @width))
END
/*
SELECT CONCAT('[', dbo.fnPadLeft2('', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadLeft2(NULL, 25, '.'), ']  ');
PRINT CONCAT('[', dbo.fnPadLeft2(NULL, 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('', 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('asdfg', 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('asdfg', 3, 'x'),']')
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 22-MAR-2020
-- Description: Pads Left
-- =============================================    
CREATE FUNCTION [dbo].[fnPadLeft]( @s VARCHAR(500), @width INT)
RETURNS VARCHAR (4000)
AS
BEGIN
   RETURN dbo.fnPadLeft2(@s, @width, ' ');
END
/*
PRINT CONCAT('[', dbo.fnPadLeft('abcd', 10), ']');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ================================================================================================
-- Author:      Terry watts
-- Create date: 24-APR-2024
-- Description: returns:
--   a string of n tabs (3 spcs each)
--
-- Test: test.test_086_sp_crt_tst_hlpr_script
-- ================================================================================================
CREATE FUNCTION [dbo].[fnGetNTabs]( @n    INT)
RETURNS VARCHAR(50)
AS
BEGIN
   RETURN REPLICATE(' ', @n*3);
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';

  PRINT CONCAT('[',dbo.fnGetNTabs(NULL),']');
  PRINT CONCAT('[',dbo.fnGetNTabs(-1),']');
  PRINT CONCAT('[',dbo.fnGetNTabs(0),']');
  PRINT CONCAT('[',dbo.fnGetNTabs(1),']');
  PRINT CONCAT('[',dbo.fnGetNTabs(3),']');
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
-- Description: creates the test helper code to call a stored procedure

-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- POSTCONDITIONS:
-- POST 01:
--
-- Called by: fnCrtHlprCodeCallBloc
--
-- Changes:
-- 241126: now that we have added @display tables as a parameter to test helper fns for P and TF
--          but not FN then the first rtn param ordinal position will b 3 if FNs else 4
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCallProc]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1) NOT NULL
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @qrn          VARCHAR(100)
   ,@tab1         VARCHAR(3) = dbo.fnGetNTabs(1)
   ,@tab2         VARCHAR(6) = dbo.fnGetNTabs(2)
   ,@tab3         NCHAR(9)    = dbo.fnGetNTabs(3)
   ,@tab4         NCHAR(12)   = dbo.fnGetNTabs(4)
   ,@tab5         NCHAR(15)   = dbo.fnGetNTabs(5)
   ,@rtn_ty_code  NCHAR(2)
   ,@ad_stp       BIT
   ,@max_prm_len  INT
   ,@line         VARCHAR(60) = REPLICATE('-', 60)
   ,@first_exp_prm_ndx  INT
   ,@rtn_ty       VARCHAR(2)

   SELECT
       @qrn          = qrn
      ,@ad_stp       = ad_stp
      ,@max_prm_len  = max_prm_len
      ,@rtn_ty       = rtn_ty
   FROM test.RtnDetails;

   SET @first_exp_prm_ndx =
   (
      SELECT TOP 1 ordinal
      FROM test.ParamDetails
      WHERE is_output=1
      ORDER BY ordinal
   )

   INSERT INTO @t (line) VALUES  (CONCAT(@tab4, 'EXEC @act_RC = ', @qrn, iif( @ad_stp = 1, '-- fnCrtHlprCodeCallProc', '')));

   INSERT INTO @t (line)
      SELECT
         CONCAT
         (
             @tab5
            ,dbo.fnPadRight
             (
               CONCAT
               (
               -- 241116: display tables affects the first ordinal as it depends on rtn type
               -- P and TF have the extra display tables parameter, FNs do not
                   iif(ordinal >iif(@rtn_ty = 'FN',3, 3),',',' ')
               ,'@'
               ,param_nm
             )
             ,@max_prm_len+3)
             ,' = @', IIF(is_output=1, 'act', 'inp'), '_'
             ,param_nm
             ,iif(is_output=1, dbo.fnPadLeft(' OUTPUT', @max_prm_len-len(param_nm)+8), '')
          )
      FROM test.ParamDetails
      WHERE tst_ty='INP';

   INSERT INTO @t (line) VALUES
     (CONCAT(@tab5,';'))
   ;
   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeCallProc()
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';

EXEC tSQLt.RunAll;

EXEC test.sp_set_rtn_details 'test.sp_pop_param_details', 41, @display_tables = 1
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===========================================================================
-- Author:      Terry Watts
-- Create date: 24-APRE-2024
-- Description: creates the scriptlet for stage 10 of test.sp_crt_tst_hlpr
-- ===========================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeChkExps]()
RETURNS @rtnDef TABLE 
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @qrn          VARCHAR(100)
   ,@tab          NCHAR(3)  = '   '
   ,@tab2         NCHAR(6)  = dbo.fnGetNTabs(2)
   ,@tab3         NCHAR(9)  = dbo.fnGetNTabs(3)
   ,@tab4         NCHAR(12) = dbo.fnGetNTabs(4)
   ,@rtn_ty_code  NCHAR(2)
   ,@ad_stp       BIT
   ,@max_prm_len  INT
   ,@line         VARCHAR(60) = REPLICATE('-', 60)
   ,@st_ordinal   INT

   SELECT
       @qrn          = qrn
      ,@ad_stp       = ad_stp
      ,@max_prm_len  = max_prm_len
   FROM test.RtnDetails;

   SELECT 
      @max_prm_len = MAX(dbo.fnLen(param_nm))
     ,@st_ordinal  = MIN(ordinal)-1
   FROM test.ParamDetails
   WHERE tst_ty = 'EXP';

   IF @ad_stp = 1
      INSERT INTO @rtnDef (line) VALUES
      (CONCAT(@tab3, '-- fnCrtHlprCodeChkExps',''))

   ----------------------------------------------
   -- Row count chk setup
   ----------------------------------------------
    --INSERT INTO @rtnDef (line) VALUES
    --(CONCAT(@tab3, '--IF @exp_', dbo.fnPadRight('row_cnt', @max_prm_len),' IS NOT NULL SELECT @act_row_cnt = COUNT(*) FROM [<TODO: enter table name here>]'));

   ----------------------------------------------
   -- Add the exp checks not exp exception chks
   ----------------------------------------------
   INSERT INTO @rtnDef (line) SELECT
      CONCAT
      (
          @tab3
         ,'IF @exp_', dbo.fnPadRight(param_nm, @max_prm_len)
         ,' IS NOT NULL EXEC tSQLt.AssertEquals'
         , ' @exp_' , dbo.fnPadRight(param_nm, @max_prm_len)
         ,', @act_' , dbo.fnPadRight(param_nm, @max_prm_len)
         , ',''',FORMAT(ordinal+80 - - @st_ordinal, '000'), ' ',param_nm, ''';'
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'EXP' AND is_exception = 0;

   RETURN;
END
/*
EXEC test.sp_set_rtn_details 'test.sp_crt_tst_mn'
SELECT * FROM test.fnCrtHlprCodeChkExps();

         -- fnCrtHlprCodeChkExps
         IF @exp_row_cnt IS NOT NULL EXEC tSQLt.AssertEquals @exp_row_cnt, @act_row_cnt,'087row_cnt';
         IF @exp_id      IS NOT NULL EXEC tSQLt.AssertEquals @exp_id     , @act_id     ,'088id';
         IF @exp_line    IS NOT NULL EXEC tSQLt.AssertEquals @exp_line   , @act_line   ,'089line';
EXEC tSQLt.RunAll;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
-- Description: creates the test helper code for a scalar fn

-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- POSTCONDITIONS:
-- POST 01:
--
-- Called by: fnCrtHlprCodeCallBloc
--
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCallTF]()
RETURNS @t TABLE
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1            VARCHAR(3) = dbo.fnGetNTabs(1)
   ,@tab2            VARCHAR(6) = dbo.fnGetNTabs(2)
   ,@tab3            NCHAR(9)    = dbo.fnGetNTabs(3)
   ,@tab4            NCHAR(12)   = dbo.fnGetNTabs(4)
   ,@tab5            NCHAR(15)   = dbo.fnGetNTabs(5)
   ,@line            VARCHAR(1000)
   ,@qrn             VARCHAR(100)
   ,@ad_stp          BIT
   ,@st_inp_ordinal  INT
   ,@inp_prm_cnt     INT = 0
   ,@display_tables  BIT
   ;

   SELECT
       @qrn            = qrn
      ,@ad_stp         = ad_stp
      ,@display_tables = display_tables
   FROM test.RtnDetails;

   SELECT @inp_prm_cnt = COUNT(*) FROM test.ParamDetails
   WHERE tst_ty='INP'
   ;

   INSERT INTO @t (line) VALUES
    (CONCAT(@tab4,'DROP TABLE IF EXISTS test.results', IIF(@ad_stp = 1 ,' -- fnCrtHlprCodeCallTF', '')))
   ,('')
   ;

   SELECT @st_inp_ordinal = MIN(ordinal)
   FROM test.ParamDetails
   WHERE tst_ty='INP'
   ;

   --------------------------------
   -- Handle 0 or 1 params inline
   --------------------------------
   IF @inp_prm_cnt = 0
   BEGIN
      SET @line = CONCAT(@tab4, 'SELECT * INTO test.Results FROM ', @qrn, '();');
      INSERT INTO @t (line) VALUES (@line);
   END
   IF @inp_prm_cnt = 1
   BEGIN
      SET @line = CONCAT(@tab4, 'SELECT * INTO test.Results FROM ', @qrn, '(');

      SET  @line =
      (
         SELECT TOP 1 CONCAT( @line, '@inp_', param_nm)
         FROM test.ParamDetails
         WHERE tst_ty ='INP'
      );

      SET  @line = CONCAT(@line, ');');
      INSERT INTO @t (line) VALUES (@line);
   END
   IF @inp_prm_cnt > 1
   BEGIN
      -------------------------------------
      -- Handle multiple params 1 per line
      -------------------------------------
      INSERT INTO @t (line) VALUES
          (CONCAT(@tab4, 'SELECT * INTO test.Results FROM ', @qrn))
         ,(CONCAT(@tab4, '('))
      ;

      -- Add params 1per line
      INSERT INTO @t (line)
      SELECT CONCAT( @tab5, iif(ordinal = @st_inp_ordinal,' ',',') , '@inp_', param_nm)
      FROM test.ParamDetails
      WHERE tst_ty ='INP';

      -- Close off fn ()
      INSERT INTO @t (line) VALUES
       (CONCAT(@tab4, ');'))
      ,('')
      ;
   END

   -- If not inline separate rtn call from next by 1 blnk line
   IF @inp_prm_cnt <2
      INSERT INTO @t (line) VALUES ('');

   -- If display tables then display tables
   INSERT INTO @t (line) VALUES (CONCAT(@tab4, 'IF @display_tables=1 SELECT * FROM test.results'));

   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeCallTF();
EXEC test.sp__crt_tst_rtns 'test].[fnCrtHlprCodeCallTF', @ad_stp=1
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
-- Description: creates the test helper code for a scalar fn

-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- POSTCONDITIONS:
-- POST 01:
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCallFn]()
RETURNS @t TABLE 
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @qrn          VARCHAR(100)
   ,@rtn_ty_code  NCHAR(2)
   ,@ad_stp       BIT
   ,@prm_cnt      INT
   ,@tab1         VARCHAR(3) = dbo.fnGetNTabs(1)
   ,@tab2         VARCHAR(6) = dbo.fnGetNTabs(2)
   ,@tab3         NCHAR(9)    = dbo.fnGetNTabs(3)
   ,@tab4         NCHAR(12)   = dbo.fnGetNTabs(4)
   ,@tab5         NCHAR(15)   = dbo.fnGetNTabs(5)
   ,@tab6         NCHAR(18)   = dbo.fnGetNTabs(6)

   SELECT
       @qrn    = qrn
      ,@ad_stp = ad_stp
      ,@prm_cnt= prm_cnt
   FROM test.RtnDetails;

   INSERT INTO @t (line) VALUES     (IIF(@ad_stp = 1 ,'-- fnCrtHlprCodeCallFn', ''));

   -------------------------------------------------------------------------
   -- Handle single parameter inline, but multiple parameters on separate lines
   -------------------------------------------------------------------------
   IF @prm_cnt = 1
   BEGIN
      -- Handle single parameter  inline
      INSERT INTO @t (line) SELECT
      (CONCAT(@tab4, 'SET @act_out_val = ', @qrn, '( @inp_,',param_nm,')'))
      FROM test.ParamDetails
      WHERE tst_ty='INP'
      ;
   END
   ELSE
   BEGIN
      -- Handle multiple parameters on separate lines
      INSERT INTO @t (line) VALUES
      (CONCAT(@tab4, 'SET @act_out_val = ', @qrn))
     ,(CONCAT(@tab4, '('))

   -- Add the parameters
   INSERT INTO @t (line) SELECT
      CONCAT( @tab5, STRING_AGG(CONCAT('@inp_',param_nm), ', '))
      FROM test.ParamDetails
      WHERE tst_ty='INP';

   INSERT INTO @t (line) VALUES
    (CONCAT(@tab4, ');'))
   ;

   END
      INSERT INTO @t (line) VALUES ('');

   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeCallFn();
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_??';
    @inp_input_str,  @inp_sep,  @inp_ndx
   SELECT * FROM test.RtnDetails
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 18-Apr-2024
-- Description: creates the tested rtn call dependant on the rtn type code
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions:
-- Returns: lines of detailed test
--
-- Method:
-- delegate to a specific rtn based on rtn type
--
-- Called by: sp_crt_tst_hlpr_script
--
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCallBloc]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1         VARCHAR(3)  = dbo.fnGetNTabs(1)
   ,@tab2         VARCHAR(6)  = dbo.fnGetNTabs(2)
   ,@tab3         CHAR(9)     = dbo.fnGetNTabs(3)
   ,@tab4         CHAR(12)    = dbo.fnGetNTabs(4)
   ,@tab5         NCHAR(15)   = dbo.fnGetNTabs(5)
   ,@line         VARCHAR(60) = REPLICATE('-', 60)
   ,@line_star    VARCHAR(100)= N' --' + REPLICATE('*', 60)
   ,@qrn          VARCHAR(100)
   ,@rtn_ty_code  VARCHAR(2)
   ,@ad_stp       BIT
   ,@nl           VARCHAR(2) = CHAR(13)+CHAR(10)

   SELECT
       @qrn         = qrn
      ,@rtn_ty_code = rtn_ty_code
      ,@ad_stp      = ad_stp
   FROM test.RtnDetails

   IF @ad_stp = 1 INSERT INTO @t (line) VALUES (CONCAT(@tab2,'-- fnCrtHlprCodeCallBloc rtn ty:', @rtn_ty_code));

   WHILE 1=1
   BEGIN
      -- Add the rtn type if debugging
 --     IF @ad_stp = 1 INSERT INTO @t (line) VALUES( CONCAT(@tab2, '-- @rtn_ty_code:', @rtn_ty_code));

      INSERT INTO @t (line) VALUES
        (CONCAT(@tab2, 'WHILE 1 = 1'))
       ,(CONCAT(@tab2, 'BEGIN'))
       ,(CONCAT(@tab3, 'BEGIN TRY'))
       ,(CONCAT(@tab4, 'EXEC sp_log 1, @fn, ''010: Calling the tested routine: ', @qrn, ''';'))
       ,(CONCAT(@tab4, @line))

      IF @rtn_ty_code = 'P'
      BEGIN
         INSERT INTO @t (line)
            SELECT line FROM test.fnCrtHlprCodeCallProc();
            -- 250403: get the act row count 
         INSERT INTO @t (line) VALUES
         (@nl)
        ,(CONCAT(@tab4,'SELECT @act_row_cnt = @@ROWCOUNT;'))
         BREAK;
      END

      IF @rtn_ty_code = 'FN'
      BEGIN
         INSERT INTO @t (line)
            SELECT line FROM test.fnCrtHlprCodeCallFn();
         BREAK;
      END

      IF @rtn_ty_code = 'TF'
      BEGIN
         INSERT INTO @t (line)
            SELECT line FROM test.fnCrtHlprCodeCallTF();
         BREAK;
      END

      -- If here then unrecognised @rtn_ty_code
      INSERT INTO @t (line) VALUES( CONCAT('-- Unrecognised @rtn_ty_code:', @rtn_ty_code));
      BREAK;
   END -- while

   INSERT INTO @t (line) VALUES
       (CONCAT(@tab4, @line))
      ,(CONCAT(@tab4, 'EXEC sp_log 1, @fn, ''020: returned from ', @qrn, ''';'))
      ,('')
      ,(CONCAT(@tab4,'IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL'))
      ,(CONCAT(@tab4,'BEGIN'))
      ,(CONCAT(@tab5,'EXEC sp_log 4, @fn, ''030: oops! Expected exception was not thrown'';'))
      ,(CONCAT(@tab5, 'THROW 51000, '' Expected exception was not thrown'', 1;'))
      ,(CONCAT(@tab4,'END'))
      ,(CONCAT(@tab3,'END TRY'))
      ,(CONCAT(@tab3,'BEGIN CATCH'))
      ,(CONCAT(@tab4, 'SET @act_ex_num = ERROR_NUMBER();'))
      ,(CONCAT(@tab4, 'SET @act_ex_msg = ERROR_MESSAGE();'))
      ,(CONCAT(@tab4, 'EXEC sp_log 1, @fn, ''040: caught  exception: '', @act_ex_num, '' '',      @act_ex_msg;'))
      ,(CONCAT(@tab4, 'EXEC sp_log 1, @fn, ''050: check ex num: exp: '', @exp_ex_num, '' act: '', @act_ex_num;'))
      ,('')
      ,(CONCAT(@tab4, 'IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL'))
      ,(CONCAT(@tab4, 'BEGIN'))
      ,(CONCAT(@tab5, 'EXEC sp_log 4, @fn, ''060: an unexpected exception was raised'';'))
      ,(CONCAT(@tab5, 'THROW;'))
      ,(CONCAT(@tab4, 'END'))
      ,('')
      ,(CONCAT(@tab4, @line))
      ,(CONCAT(@tab4, '-- ASSERTION: if here then expected exception'))
      ,(CONCAT(@tab4, @line))
      ,(CONCAT(@tab4, 'IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, ''ex_num mismatch'';'))
      ,(CONCAT(@tab4, 'IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, ''ex_msg mismatch'';'))
      ,(CONCAT(@tab4, ''))
      ,(CONCAT(@tab4,'EXEC sp_log 2, @fn, ''070 test# '',@tst_num, '': exception test PASSED;'''))
      ,(CONCAT(@tab4, 'BREAK'))
      ,(CONCAT(@tab3, 'END CATCH'))
      ,('')
      ,(CONCAT(@tab3, '-- TEST:'))
      ,(CONCAT(@tab3,'EXEC sp_log 2, @fn, ''080: running tests   '';'))
   ;

    INSERT INTO  @t (line) 
    SELECT line FROM test.fnCrtHlprCodeChkExps();

    INSERT INTO  @t (line) VALUES
     ('')
    ,(CONCAT(@tab3, @line))
    ,(CONCAT(@tab3, '-- Passed tests'))
    ,(CONCAT(@tab3, @line))
    ,(CONCAT(@tab3, 'BREAK'))
    ,(CONCAT(@tab2, 'END --WHILE'))
   ;

   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';

EXEC tSQLt.RunAll
SELECT * FROM test.fnCrtHlprCodeCall('SP',1);
SELECT * FROM test.fnCrtHlprCodeCall('F',1);
SELECT * FROM test.fnCrtHlprCodeCall('TF',1);
SELECT * FROM test.RtnDetails;
EXEC test.sp__crt_tst_rtns 'dbo.sp_Import_Role', @trn=26, @ad_stp=1;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ============================================================================================================================
-- Author:      Terry Watts
-- Create date: 11-NOV-2023
-- Description: take off of MS sp_helptext
-- gets the routine definition
--
-- PRECONDITIONS:
-- test.RtnDetails table pop'd
--
-- POSTCONDITIONS:
--  POST 01: if successful returns the script
--  POST 02: if not successful returns the appropriate error message along with 
--           the corresponding negatated MS error code as follows:
--    .1: if rtn is not in the current database:                     -15250, 'Error 01: rtn is not in the current database'
--    .2: if rtn does not exist:                                     -15009, 'Error 02: rtn does not exist'
--    .3: if a system object and it is not in MASTER.sys.syscomments -15197, 'Error 03: system-object check failed'
--    .4: if rtn has no script rows:                                 -15197, 'Error 04: rtn has no lines'
--    .5: if rtn has no script rows*:                                -15471, 'Error 05: rtn has no lines*'
--
-- CHANGES:
-- 17-DEC-2024: now gets the rtn details from  test.RtnDetails table
-- ============================================================================================================================
CREATE FUNCTION [dbo].[fnGetRtnDef]()
RETURNS
@rtnDef TABLE
(
    id   INT
   ,line VARCHAR(255) --collate catalog_default
)

AS
BEGIN
   DECLARE
    @qrn VARCHAR(120) -- can be [db_nm.][schema_nm.][rtn_nm]
   ,@dbname          SYSNAME
   ,@objid           INT
   ,@BlankSpaceAdded INT
   ,@BasePos         INT
   ,@CurrentPos      INT
   ,@TextLength      INT
   ,@LineId          INT
   ,@AddOnLen        INT
   ,@LFCR            INT --Lengths of line feed carriage return
   ,@DefinedLength   INT
   ,@schema_nm       VARCHAR(50)
   ,@ad_stp          BIT            = 0
   ,@tstd_rtn        VARCHAR(100)
   ,@n               INT
   ,@SyscomText      VARCHAR(4000)
   ,@Line            VARCHAR(255)

   SELECT
       @qrn       = qrn
      ,@schema_nm = schema_nm
      ,@tstd_rtn  = rtn_nm
      ,@ad_stp    = ad_stp
   FROM test.RtnDetails;

   /* NOTE: Length of @SyscomText is 4000 to replace the length of
   ** text column in syscomments.
   ** lengths on @Line, #CommentText Text column and
   ** value for @DefinedLength are all 255. These need to all have
   ** the same values. 255 was selected in order for the max length
   ** display using down level clients
   */

   SELECT @DefinedLength = 255
   SELECT @BlankSpaceAdded = 0 --Keeps track of blank spaces at end of lines. Note Len function ignores  trailing blank spaces*/

   -- Make sure the @objname is local to the current database.
   SELECT @dbname = parsename(@qrn, 3); -- 1 = Object name, 2 = Schema name, 3 = Database name, 4 = Server name

   IF @dbname IS NULL
      SELECT @dbname = db_name();
   ELSE IF @dbname <> db_name()
   BEGIN
      -- raiserror(15250,-1,-1);
     INSERT INTO @rtnDef(id, line)  VALUES (-15250, 'Error 01: rtn is not in the current database');
     RETURN;
   END

   -- See if @objname exists.
   SELECT @objid = object_id(@qrn)
   IF (@objid IS NULL)
   BEGIN
     INSERT INTO @rtnDef(id, line)  VALUES (-15009, 'Error 02: rtn does not exist');
     RETURN;
   END

   IF @objid < 0 -- Handle system-objects
   BEGIN
      -- Check count of rows with text data
      IF (SELECT count(*) from MASTER.sys.syscomments WHERE id = @objid AND text IS NOT null) = 0
      BEGIN
         --raiserror(15197,-1,-1,@objname)
         INSERT INTO @rtnDef(id, line)  VALUES (-15197, 'Error 03: system-object check failed');
         RETURN;
      END

      DECLARE ms_crs_syscom CURSOR LOCAL FOR SELECT text FROM master.sys.syscomments WHERE id = @objid
      ORDER BY number, colid FOR READ ONLY
   END
   ELSE
   BEGIN
      -- Find out how many lines of text are coming back, and return if there are none.
      IF
      (
         SELECT count(*) 
         FROM syscomments c, sysobjects o 
         WHERE ((o.xtype NOT IN ('S', 'U')) AND (o.id = c.id AND o.id = @objid))
      ) = 0
      BEGIN
         --RAISERROR(15197,-1,-1,@objname)
         INSERT INTO @rtnDef(id, line)  VALUES (-15197, 'Error 04: rtn has no lines')
         RETURN;
      END

      IF (SELECT count(*) FROM syscomments WHERE id = @objid AND encrypted = 0) = 0
      BEGIN
         -- RAISERROR(15471,-1,-1,@objname)
         INSERT INTO @rtnDef(id, line)  VALUES (-15471, 'Error 05: rtn has no lines*')
         RETURN;
      END

      DECLARE ms_crs_syscom  CURSOR LOCAL
      FOR SELECT text FROM syscomments WHERE id = @objid AND encrypted = 0
      ORDER BY number, colid
      FOR READ ONLY
   END

   -- ASSERTION: Parameters validated

   -- else get the text
   SELECT @LFCR   = 2;
   SELECT @LineId = 1;
   OPEN ms_crs_syscom;
   FETCH NEXT from ms_crs_syscom into @SyscomText;

   WHILE @@fetch_status >= 0
   BEGIN
      SELECT  @BasePos    = 1;
      SELECT  @CurrentPos = 1;
      SELECT  @TextLength = LEN(@SyscomText);

      WHILE @CurrentPos != 0
      BEGIN
         --Looking for end of line followed by carriage return
         SELECT @CurrentPos = CHARINDEX(CHAR(13)+CHAR(10), @SyscomText, @BasePos);

         --If carriage return found
         IF @CurrentPos != 0
         BEGIN
            -- If new value for @Lines length will be > then set the length 
            -- then insert current contents of @line and proceed.
            WHILE (isnull(LEN(@Line),0) + @BlankSpaceAdded + @CurrentPos - @BasePos + @LFCR) > @DefinedLength
            BEGIN
               SELECT @AddOnLen = @DefinedLength - (ISNULL(LEN(@Line),0) + @BlankSpaceAdded);

               INSERT @rtnDef (id, line) VALUES
               (
                  @LineId
                  ,ISNULL(@Line, N'') + ISNULL(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N'')
               );

               SELECT
                   @Line            = NULL
                  ,@LineId          = @LineId + 1
                  ,@BasePos         = @BasePos + @AddOnLen
                  ,@BlankSpaceAdded = 0;

            END -- WHILE (isnull(LEN

            SELECT @Line    = ISNULL(@Line, N'') + ISNULL(SUBSTRING(@SyscomText, @BasePos, @CurrentPos-@BasePos + @LFCR), N'')
            SELECT @BasePos = @CurrentPos+2;
            INSERT @rtnDef (id, line) VALUES( @LineId, @Line);
            SELECT @LineId  = @LineId + 1;
            SELECT @Line    = NULL;
         END  -- IF @CurrentPos != 0
         ELSE --else carriage return not found
         BEGIN
            IF @BasePos <= @TextLength
            BEGIN
               --If new value for @Lines length will be > then the defined length
               WHILE (ISNULL(LEN(@Line),0) + @BlankSpaceAdded + @TextLength-@BasePos+1 ) > @DefinedLength
               BEGIN
                  SELECT @AddOnLen = @DefinedLength - (ISNULL(LEN(@Line),0) + @BlankSpaceAdded)
                  INSERT @rtnDef (id, line) VALUES
                  (
                     @LineId
                     ,ISNULL(@Line, N'') + ISNULL(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N'')
                  );

                  SELECT @Line = NULL, @LineId = @LineId + 1,
                  @BasePos = @BasePos + @AddOnLen, @BlankSpaceAdded = 0
               END

               SELECT @Line = isnull(@Line, N'') + ISNULL(SUBSTRING(@SyscomText, @BasePos, @TextLength-@BasePos+1 ), N'')

               IF LEN(@Line) < @DefinedLength and CHARINDEX(' ', @SyscomText, @TextLength+1 ) > 0
               BEGIN
                  SELECT @Line = @Line + ' ', @BlankSpaceAdded = 1
               END
            END
         END -- -- IF @CurrentPos != 0 ELSE
      END -- WHILE @CurrentPos != 0

      FETCH NEXT FROM ms_crs_syscom INTO @SyscomText
   END -- WHILE @@fetch_status >= 0

   IF @Line IS NOT NULL
      INSERT @rtnDef (id, line) VALUES( @LineId, @Line )

   --SELECT Text FROM CommentText ORDER BY LineId
   CLOSE       ms_crs_syscom;
   DEALLOCATE  ms_crs_syscom;
   --DROP TABLE  #CommentText
   RETURN;-- (0) -- sp_helptext
END
/*
   SELECT * FROM dbo.fnGetRtnDef();
   SELECT * FROM dbo.fnGetRtnDef('dbo.AsFloat');
   EXEC test.sp_crt_tst_rtns 'dbo.fnGetRtnDef'
   EXE tSQLt.Run 'test.test_015_fnGetRtnDesc';
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry Watts
-- Create date: 10-NOV-2023
-- Description: gets the rtn description from its meta data
--
-- PRECONDITIONS:
-- PRE 01: the tested rtn details are set
--
-- POSTCONDITIONS:
-- POST01: some rows must be returned or exception 54321
--
-- CHANGES:
--231112: renamed this rtn from and moved to test:
--        dbo.sp_get_rtn_description -> test.sp_get_rtn_desc
-- ===============================================================
CREATE FUNCTION [test].[fnGetRtnDesc]()
RETURNS @t TABLE
(
    id   INT            IDENTITY(1,1)
   ,line VARCHAR(MAX)  NULL
)
AS
BEGIN
   DECLARE
    @fn VARCHAR(35) = 'fnGetRtnDesc'
   ,@desc_st_row     INT = NULL
   ,@desc_end_row    INT = NULL
   ,@schema_nm       VARCHAR(50)
   ,@ad_stp          BIT            = 0
   ,@tstd_rtn        VARCHAR(100)
   ,@qrn             VARCHAR(100)
   ;

   SELECT
       @qrn       = qrn
      ,@schema_nm = schema_nm
      ,@tstd_rtn  = rtn_nm
      ,@ad_stp    = ad_stp
   FROM test.RtnDetails;

   if(@ad_stp=1) INSERT INTO @t(line) VALUES(CONCAT('-- ', @fn));

   INSERT INTO @t(line) 
   SELECT line
   FROM dbo.fnGetRtnDef();

   SET @desc_st_row = (SELECT TOP 1 id FROM @t WHERE line LIKE '--%Description%');
   SET @desc_end_row= (SELECT TOP 1 id FROM @t WHERE line LIKE '%====%' AND id>@desc_st_row);
   DELETE FROM @t WHERE id NOT BETWEEN @desc_st_row AND @desc_end_row-1;

   UPDATE @t
   SET line = dbo.fnTrim(REPLACE(line, '-- Description:', '--'));
   RETURN;
END
/*
SELECT * from Test.RtnDetails;
SELECT * from Test.ParamDetails;
SELECT * FROM test.fnGetRtnDesc();
SELECT * FROM dbo.fnGetRtnDef();
EXEC tSQLt.RunAll;
SELECT * FROM test.RtnDetails;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================
-- Author:      Terry Watts
-- Create date: 16-Dec-2023
-- Description: encapsulates the helper header comment
-- 05 Create the test rtn Header->fnCrtHlprCodeTstHdr
--
-- PRECONDITIONS: test.RtnDetails pop'd
-- ======================================================
CREATE FUNCTION [test].[fnCrtCodeTstHdr]( @is_hlpr      BIT = 1)
RETURNS 
@t TABLE 
(
    id      INT IDENTITY(1,1) NOT NULL
   ,line    VARCHAR(500)
)
AS
BEGIN
   DECLARE 
       @line         VARCHAR(500)
      ,@qrn          VARCHAR(500)
      ,@tst_rtn_nm   VARCHAR(50)
      ,@dt           DATE = GetDate()
      ,@ad_stp       BIT
      ,@maxLineLen   INT

   SELECT
       @qrn       = qrn
      ,@tst_rtn_nm= iif(@is_hlpr = 1, hlpr_rtn_nm, tst_rtn_nm)
      ,@ad_stp    = ad_stp
    FROM test.RtnDetails;

   SELECT @maxLineLen = MAX(dbo.fnLen(dbo.fnTrim(line)))
   FROM test.fnGetRtnDesc(); -- @qrn, @ad_stp)

   SET @line = CONCAT('--',REPLICATE('=', @maxLineLen));

   INSERT INTO @t( line) VALUES
    ('SET ANSI_NULLS ON')
   ,('GO')
   ,('SET QUOTED_IDENTIFIER ON')
   ,('GO')
   ;

/*
      INSERT INTO @t( line) 
      SELECT line 
      FROM 
         test.fnCrtCodeDropRtn(@is_hlpr);
*/
   INSERT INTO @t( line) VALUES
    (@line)
   ,('-- Author:           Terry Watts')
   ,(CONCAT('-- Create date:      ', FORMAT(@dt, 'dd-MMM-yyyy')))
   ,(CONCAT('-- Rtn:              test.',@tst_rtn_nm))
   ,(CONCAT('-- Description: ',iif(@is_hlpr=1,'test helper','main test routine'),' for the ',@qrn, ' routine ',iif(@is_hlpr=1,'tests ', '')))
   ,('--')
   ,('-- Tested rtn description:')

   INSERT INTO @t(line)
   SELECT line FROM test.fnGetRtnDesc(); -- @qrn, @ad_stp

   INSERT INTO @t( line) VALUES (@line)

   -- Reset the comment line length to be long enough to cover the new lines from the tested rtn desc
   SELECT @maxLineLen = MAX(dbo.fnLen(dbo.fnTrim(line))) FROM @t;
   SET @line =  CONCAT('--', REPLICATE('=', @maxLineLen));
   UPDATE @t SET line = @line where line like '--===%'

   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
   SELECT line FROM test.fnCrtCodeTstHdr('test.test_086_sp_crt_tst_hlpr_script', 1)

   SELECT * FROM test.fnCrtCodeTstHdr('dbo.fnSysRtnCfg', 1)
   SELECT * FROM test.fnCrtCodeTstHdr('test.sp_crt_tst_hlpr_script', 0)
   SELECT * FROM test.fnCrtCodeTstHdr('test.sp_crt_tst_hlpr_script', 1)
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================
-- Author:        Terry Watts
-- Create date:   17-Apr-2024
-- Description:   creates the helper sig parameter list
-- Design:        
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
-- Postconditions: return table with the tst, inp and exp prms
-- Tests:
--    test_042_sp_pop_param_details
--    test_041_fnCrtHlprSigParams
-- =============================================================
CREATE FUNCTION [test].[fnCrtHlprSigParams]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab                VARCHAR(3) = '   '
   ,@rtn_ty_code        NCHAR(2)
   ,@tst_proc_hlpr_nm   VARCHAR(60)
   ,@detld_rtn_ty_code  VARCHAR(2)
   ,@qrn                VARCHAR(100)
   ,@sc_fn_ret_ty       VARCHAR(50)
   ,@ad_stp             BIT         = 0
   ,@tst_rtn_nm         VARCHAR(60)
   ,@max_prm_len        INT

   SELECT
       @tst_rtn_nm   = tst_rtn_nm
      ,@ad_stp       = ad_stp
      ,@rtn_ty_code  = rtn_ty_code
      ,@max_prm_len  = max_prm_len
   FROM test.RtnDetails;

   SELECT @max_prm_len = MAX(dbo.fnLen(param_nm)) + 5 
   FROM test.ParamDetails;

   ------------------------------------------
   -- Create the input paams
   ------------------------------------------

   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          @tab
         ,iif(param_nm = 'tst_num' AND tst_ty='TST', ' ',',')
         ,'@',IIF(tst_ty = 'INP', 'inp_',IIF(tst_ty = 'EXP', 'exp_',''))
         ,dbo.fnPadRight(lower(param_nm), IIF(tst_ty IN ('INP', 'EXP'), @max_prm_len, @max_prm_len+4))
         ,' ', type_nm
         ,iif(@ad_stp = 1 AND param_nm = 'tst_num', ' -- fnCrtHlprSigParams', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty IN ('TST', 'INP')
   ;

   ------------------------------------------
   -- Create the exp paams
   ------------------------------------------

   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          @tab
         ,iif(param_nm = 'tst_num', ' ',',')
         ,'@',IIF(tst_ty = 'INP', 'inp_',IIF(tst_ty = 'EXP', 'exp_',''))
         ,dbo.fnPadRight(lower(param_nm)
         ,IIF(tst_ty IN ('INP', 'EXP'), @max_prm_len, @max_prm_len+4))
         ,' ', type_nm
         ,iif(tst_ty = 'EXP', dbo.fnPadLeft('= NULL', 22 - dbo.fnLen(type_nm)),'')
         ,iif(param_nm = 'tst_num', CONCAT(' -- fnCrtHlprSigParams ',@max_prm_len+6), '')
      )
   FROM test.ParamDetails
   WHERE tst_ty ='EXP' AND is_exception = 0
   ;

   ----------------------------------------------------
   -- If tstd rtn is a procedure then add @exp_RC param
   ----------------------------------------------------
   /*IF(@rtn_ty_code = 'P')
   INSERT INTO @t (line) VALUES
   (CONCAT(@tab, dbo.fnPadRight(',@exp_RC', @max_prm_len + 6), ' INT'))
   */

   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          @tab
         ,iif(param_nm = 'tst_num', ' ',',')
         ,'@',IIF(tst_ty = 'INP', 'inp_',IIF(tst_ty = 'EXP', 'exp_',''))
         ,dbo.fnPadRight(lower(param_nm), IIF(tst_ty IN ('INP', 'EXP'), @max_prm_len, @max_prm_len+4))
         , ' ', type_nm
         ,iif(tst_ty = 'EXP', dbo.fnPadLeft('= NULL', 22 - dbo.fnLen(type_nm)),'')
         ,iif(param_nm = 'tst_num', CONCAT(' -- fnCrtHlprSigParams ',@max_prm_len+6), '')
      )
   FROM test.ParamDetails
   WHERE tst_ty ='EXP' AND is_exception = 1
   ;

   RETURN;
END
/*
EXEC test.test_041_fnCrtHlprSigParams;

EXEC test.sp_set_rtn_details 'test.sp_tst_hlpr_st', @display_tables=1;
SELECT * FROM test.RtnDetails;
SELECT * FROM test.ParamDetails;
SELECT * FROM test.fnCrtHlprSigParams()

*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
--
-- Description: creates the test helper signature line for the hlpr script like:
-- ALTER PROCEDURE test.hlpr_106_fnGetParams
--    @qrn       VARCHAR(120)
--   ,@ordinal   INT
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- Test rtn: test.test_086_sp_crt_tst_hlpr_script
--
-- ====================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeHlprSig]()
RETURNS @t TABLE
(
    id    INT IDENTITY (1,1)
   ,line  VARCHAR(1000)
)
AS
BEGIN
   DECLARE
    @qrn          VARCHAR(120)
   ,@schema_nm    VARCHAR(50)
   ,@rtn_nm       VARCHAR(60)
   ,@rtn_ty       NCHAR(1)
   ,@trn          VARCHAR(90)
   ,@tst_rtn_nm   VARCHAR(50)
   ,@hlpr_rtn_nm  VARCHAR(50)
   ,@ad_stp       BIT
   ,@cora         NCHAR(1)
   ,@tab          VARCHAR(3) = '   '

   SELECT
       @qrn       = qrn
      ,@schema_nm = schema_nm
      ,@rtn_nm     = rtn_nm
      ,@trn        = trn
      ,@tst_rtn_nm = tst_rtn_nm
      ,@hlpr_rtn_nm= hlpr_rtn_nm
      ,@ad_stp     = ad_stp
      ,@cora       = cora
   FROM test.RtnDetails;

   SELECT @rtn_ty = rtn_ty
   FROM test.RtnDetails;

   INSERT INTO @t( line)
   VALUES
       (CONCAT(iif(@cora='C','CREATE','ALTER'),' PROCEDURE test.', @hlpr_rtn_nm, IIF(@ad_stp=1,' -- fnCrtHlprCodeHlprSig','')))

   -- Add the rtn params
   INSERT INTO @t( line)
   SELECT line
   FROM test.fnCrtHlprSigParams();

   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
EXEC tSQLt.Run 'test.test_057_sp_crt_tst_hlpr';

EXEC tSQLt.RunAll;

EXEC test.sp_get_rtn_details 'dbo.fnEatWhitespace';
SELECT * FROM test.fnCrtHlprCodeHlprSig();

EXEC test.sp_get_rtn_details 'dbo.sp_get_excel_data';
SELECT * FROM test.fnCrtHlprCodeHlprSig();
SELECT * FROM test.fnEatWhitespace();
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================
-- Author:      Terry Watts
-- Create date: 16-Apr-2024
-- Description: creates the helper close bloc
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions:
-- =============================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCloseBloc]()
RETURNS @t TABLE 
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1               VARCHAR(3) = '   '
   ,@tab2               VARCHAR(6) = '      '
   ,@rtn_ty_code        NCHAR(2)
   ,@tst_proc_hlpr_nm   VARCHAR(60)
   ,@detld_rtn_ty_code  VARCHAR(2)
   ,@qrn                VARCHAR(100)
   ,@sc_fn_ret_ty       VARCHAR(50)
   ,@ad_stp             BIT = 0
   ,@tst_rtn_nm         VARCHAR(60)

   SELECT
       @tst_rtn_nm = tst_rtn_nm
      ,@ad_stp     = ad_stp
   FROM test.RtnDetails;

   INSERT INTO @t (line)
   VALUES
    ('')
   ,(CONCAT(@tab2,'-- CLEANUP: ??', IIF(@ad_stp=1, ' -- fnCrtHlprCodeCloseBloc','')))
   ,('')
   ,(CONCAT(@tab2,'EXEC sp_log 1, @fn, ''990: all subtests PASSED'';'))
   ,(CONCAT(@tab1,'END TRY'))
   ,(CONCAT(@tab1,'BEGIN CATCH'))
   ,(CONCAT(@tab2,'EXEC test.sp_tst_hlpr_hndl_failure;'))
   ,(CONCAT(@tab2,'THROW;'))
   ,(CONCAT(@tab1,'END CATCH'))
   ,('')
   ,(CONCAT(@tab1,'EXEC test.sp_tst_hlpr_hndl_success;'))
   ,('END')
   ,('/*')
   ,('EXEC tSQLt.RunAll;')
   ,(CONCAT('EXEC tSQLt.Run ''test.', @tst_rtn_nm, ''';'))
   ,('*/')
   ;

   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [test].[HlprDef](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[line] [varchar](4000) NULL,
 CONSTRAINT [PK_test.HlprDef] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ============================================================
-- Author:      Terry Watts
-- Create date: 06-APR-2024
-- Description: creates the script for a test helper routine
--    populates test.HlprDef table
--
-- Design: see EA ut/Use Case Model/Test Automation/Create Helper rotine Use case/Create the Helper routine_ActivityGraph
--
-- Algorithm:
-- Create the text header
-- Create the Helper routine
-- Create the test helper signature
-- Create As-begin-decl-log-st bloc for the helper
-- Add the test setup and call tested routine comments
-- Create the if @exp_ex_num IS null bloc
-- Create the if @exp_ex_nm is NOT null bloc
-- Create the test bloc
-- Create the close bloc
--
-- OUTPUTS:
-- 1: populates table: test.tstActDefHlpr with the hlper creation sql script
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated

-- Algorithm:
--
-- Changes:
-- 231115: helper should have same defaults as the tstd rtn
-- 231121: @qrn must exist or exception 56472, '<@@qrn> does not exist'
-- 231121: added a try catch handler to log errors
-- 231201: better tested exception handling
-- 231213: handle wonky []
-- 231216: add check for expected line for the given step id
-- 240402: refactor - split into subroutines
-- ============================================================
CREATE PROCEDURE [test].[sp_crt_tst_hlpr_script]
AS
BEGIN
   DECLARE 
    @fn                 VARCHAR(35)   = 'sp_crt_tst_hlpr_script'
   ,@qrn                VARCHAR(100) -- including schema
   ,@trn                INT
   ,@ad_stp             BIT            = 0    -- used in testing to identify a step with a unique name (not an incremental int id)
   ,@cora               NCHAR(1)       = 'C'
   ,@crse_rtn_ty_code   VARCHAR(1)          -- coarse grained type one of {'F','P'}
   ,@detld_rtn_ty_code  NCHAR(2)       = '?' -- detailed type code: can be 1 of {'P', 'FN', 'IF','TF'}like TF for a table function
   ,@hlpr_rtn_nm        VARCHAR(120)        -- hlpr_<@trn 000>_
   ,@schema_nm          VARCHAR(50)
   ,@stop_stage         INT            = 12   -- stage 12 for testing - display script
   ,@tst_mode           BIT            = 1    -- for testing - copy tmp tables to permananent tables for teting
   ,@tst_proc_mn_nm     VARCHAR(120)
   ,@rtn_ty_code        VARCHAR(25)
   ,@rtn_ty_nm          VARCHAR(25)
   ,@rtn_nm             VARCHAR(100)
   ,@tstd_rtn_call      VARCHAR(250)
   ,@params             VARCHAR(MAX)  = '/*params: <TBD>*/'
   ,@hlpr_params        VARCHAR(MAX)  = '/*hlpr params: <TBD>*/'
   ,@max_param_len      INT            = -1
   ,@n                  INT
   ,@act_@qrn           VARCHAR(100)
   ,@row_cnt            INT
   ,@act_tst_rtn_num    INT
   ,@error_num          INT
   ,@error_msg          VARCHAR(500)
   ,@stage              INT = 1
   ,@msg                VARCHAR(500)
   ,@txt                VARCHAR(500)
   ,@tab                VARCHAR(4)    = '   '
   ;

   BEGIN TRY
--      EXEC sp_log 2, @fn, '';
--      EXEC sp_log 2, @fn, @line2;

      ----------------------------------------------------------------------------------------------------------------------------
      -- Log paramaters
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '000: starting';

      SELECT
          @qrn          = qrn
         ,@schema_nm    = schema_nm
         ,@rtn_nm       = rtn_nm
         ,@trn          = trn
         ,@cora         = cora
         ,@ad_stp       = ad_stp
--         ,@tst_mode     = tst_mode
--         ,@stop_stage   = stop_stage
         ,@hlpr_rtn_nm  = hlpr_rtn_nm
         ,@rtn_ty_nm    = rtn_ty
         ,@rtn_ty_code  = rtn_ty_code
      FROM test.RtnDetails;

      EXEC sp_log 1, @fn, '005: params
qrn        :[',@qrn         ,']
trn        :[',@trn         ,']
cora       :[',@cora        ,']
ad_stp     :[',@ad_stp      ,']
tst_mode   :[',@tst_mode    ,']
stop_stage :[',@stop_stage  ,']
hlpr_rtn_nm:[', @hlpr_rtn_nm,']
ty_code    :[', @rtn_ty_code,']
rtn_ty_nm  :[', @rtn_ty_nm     ,']'
;

      SET @stage = 1;
      EXEC sp_log 1, @fn, '010: truncate HlprDef';
      TRUNCATE TABLE test.HlprDef;

      if(@ad_stp=1) INSERT INTO HlprDef(line) VALUES(CONCAT('-- ', @fn));

      --------------------------------------------------------------------
      -- Create the text header
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn, '015: creating the text header';
      INSERT INTO test.HlprDef (line)
      SELECT line FROM test.fnCrtCodeTstHdr(1);

      --------------------------------------------------------------------
      -- Create the test helper signature
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: creating the helper signature';
      INSERT INTO test.HlprDef (line)
      SELECT line from test.fnCrtHlprCodeHlprSig();

      --------------------------------------------------------------------
      -- Create As-begin-decl-log-st bloc-test setup for the helper
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn, '025: creating the as-begin-decl-log-st bloc-test setup';
      -- AS-BGN-ST, TF-DECL-ACTRTNDEF-TV,  BGN-TRY
      INSERT INTO test.HlprDef (line)
      SELECT line FROM test.fnCrtHlprCodeBegin();

      -------------------------------------------------------------------------------------------------
      --  Create the tested rtn call
      -------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: creating the call tested routine bloc';
      INSERT INTO test.HlprDef (line)
      SELECT line FROM test.fnCrtHlprCodeCallBloc();--@rtn_ty_code, @ad_stp);

      -------------------------------------------------------------------------------
      -- Create the test bloc dependant on rtn type
      ------------------------------------------------- ------------------------------
      --EXEC sp_log 1, @fn, '035: creating the test bloc dependant on rtn ty';
      --INSERT INTO test.HlprDef (line)
      --SELECT line FROM test.fnCrtHlprCodeTestBloc(@rtn_ty_code, @ad_stp);

      -------------------------------------------------------------------------------
      -- Create the close bloc
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '045 creating the close bloc';
      INSERT INTO test.HlprDef (line)
      SELECT line FROM test.fnCrtHlprCodeCloseBloc()

      -------------------------------------------------------------------------------
      -- Script completed
      -------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '900 script completed';
      EXEC sp_log 2, @fn, '910 displaying hlpr script   ';
      SELECT * FROM test.HlprDef;
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, '950: Stage: ', @stage;
      THROW;
   END CATCH

  
   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry Watts
-- Create date: 30-MAR-2020
-- Description: returns true if the file exists, false otherwise
-- ===============================================================
CREATE FUNCTION [dbo].[fnFileExists](@path varchar(512))
RETURNS BIT
AS
BEGIN
     DECLARE @result INT
     EXEC master.dbo.xp_fileexist @path, @result OUTPUT
     RETURN cast(@result as bit)
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- =============================================
-- Author:      Terry watts
-- Create date: 30-MAR-2020
-- Description: assert the given file exists or throws exception @ex_num* 'the file[<@file>] does not exist', @state
-- * if @ex_num default: 53200, state=1
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_file_exists]
    @file      VARCHAR(500)
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@ex_num    INT             = 53200
   ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE
       @fn_       VARCHAR(35)   = N'ASSERT_FILE_EXISTS'
      ,@msg       VARCHAR(MAX)

   EXEC sp_log @log_level, @fn_, '000: checking file [', @file, '] exists';

   IF dbo.fnFileExists( @file) = 1
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fn, '010: OK,File [',@file,'] exists';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   SET @msg = CONCAT('File [',@file,'] does not exist');
   EXEC sp_log 3, @fn, '020:', @msg, ' raising exception';

   EXEC sp_raise_exception
       @ex_num = @ex_num
      ,@msg1   = @msg
      ,@msg2   = @msg1
      ,@msg3   = @msg2 
      ,@msg4   = @msg3 
      ,@msg5   = @msg4 
      ,@msg6   = @msg5 
      ,@msg7   = @msg6 
      ,@msg8   = @msg7 
      ,@msg9   = @msg8 
      ,@msg10  = @msg9 
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@fn     = @fn
   ;
END
/*
EXEC sp_assert_file_exists 'non existant file', ' second msg',@fn='test fn', @state=5  -- expect ex: 53200, 'the file [non existant file] does not exist', ' extra detail: none', @state=1, @fn='test fn';
EXEC sp_assert_file_exists 'C:\bin\grep.exe'   -- expect OK
*/




GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =======================================================================================
-- Author:     Terry Watts
-- Create date: 19-MAY-2024
-- Description:exports the test.HlprDef table to file specified by @file_path param
-- Preconditions:
-- PRE 01: test.HlprDef table populated 
-- Postconditions:                     EX
-- POST 01: the file exists OR EX 63201, 'The output file: [@file_path] does not exist
-- POST 02: write to file OK or  OR EX 63202, ''
-- =======================================================================================
CREATE PROCEDURE [test].[sp_crt_hlpr_script_file]
   @file_path VARCHAR(MAX)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
       @fn           VARCHAR(35)   = N'sp_crt_hlpr_script_file'
      ,@ret_code     INT
      ,@file_system  INT
      ,@file_exists_ VARCHAR(35)
      ,@file_handle  INT
      ,@file_exists  BIT
      ,@line_cnt     INT = 0
      ,@line         VARCHAR(MAX)
      ,@NL           NCHAR(2)=NCHAR(13)+NCHAR(10)

   BEGIN TRY
      EXEC sp_log 2, @fn,'000: starting, params:
file  :[',@file_path,']'
;

      ----------------------------------------------------------------------------------------------------------------------------
      -- Create Scripting.FileSystemObject
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'005: creating Scripting.FileSystemObject';
      EXECUTE @ret_code = sp_OACreate 'Scripting.FileSystemObject' , @file_system OUTPUT;

      IF (@@ERROR|@ret_code > 0 Or @file_system < 0)
      BEGIN
         EXEC sp_log 4, @fn,'010: could not create FileSystemObject';
         RAISERROR ('could not create FileSystemObject',16,1)
      END

      ----------------------------------------------------------------------------------------------------------------------------
      -- Open a new file for (over)writing
      ----------------------------------------------------------------------------------------------------------------------------
      --1 = for reading, 2 = for writing (will overwrite contents), 8 = for appending
      EXEC sp_log 1, @fn,'020: creating sql file to write rtn to';
      EXEC @ret_code = sp_OAMethod @file_system , 'OpenTextFile' , @file_handle OUTPUT , @file_path, 2, 1;

      IF (@@ERROR|@ret_code > 0 Or @file_handle < 0)
      BEGIN
         EXEC sp_log 4, @fn,'025: could not create sql file';
         RAISERROR ('could not create sql file',16,1);
      END

      ----------------------------------------------------------------------------------------------------------------------------
      -- Write the HlprDef table to the file line by line
      ----------------------------------------------------------------------------------------------------------------------------
      DECLARE row_cursor CURSOR READ_ONLY FOR
         SELECT line FROM test.HlprDef;

      EXEC sp_log 1, @fn,'030: opening cursor';
      OPEN row_cursor;
      FETCH NEXT FROM row_cursor INTO @line;

      ----------------------------------------------------------------------------------------------------------------------------
      -- Main loop: reads each line from the table and writes to file
      ----------------------------------------------------------------------------------------------------------------------------
      WHILE (@@fetch_status = 0)
      BEGIN
         SET @line = CONCAT(@line, @NL);
         EXECUTE @ret_code = sp_OAMethod @file_handle , 'Write' , NULL , @line;

         IF (@@ERROR|@ret_code > 0)
         BEGIN
           -- POST 02: write to file OK or  OR EX 63202, ''

            EXEC sp_log 4, @fn,'040: could not write to file: @@ERROR ',@@ERROR,' @ret_code: ', RetCode;
            THROW 63202, 'could not write to file',1;
         END

         SET @line_cnt = @line_cnt + 1;
         FETCH NEXT FROM row_cursor INTO @line
      END

      CLOSE row_cursor
      DEALLOCATE row_cursor
      EXEC sp_log 1, @fn,'050: exported ', @line_cnt, ' procedure lines';

      EXEC @ret_code = sp_OAMethod @file_handle , 'Close' , NULL;

      IF (@@ERROR|@ret_code > 0) RAISERROR ('Could not close file',16,1);

      EXEC sp_OADestroy @file_system;

      --------------------------------------------------------------------------------------
      -- Check post conditions
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'900: checking post conditions   ';
      -- POST 01: the file exists OR EX 63201, 'The output file: [@file_path] does not exist
      EXEC sp_assert_file_exists @file_path, @ex_num=63201;

      ----------------------------------------------------------------------------------------
      --    Completed processing
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: Completed processing'
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
EXEC tSQLt.Run 'test.test_012_sp_crt_tst_mn_compile';

EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- ================================================================================================================================
-- Author:      Terry Watts
-- Create date: 09-Nov-2023
-- Description: creates a tSQLt test helper procedure from the data in test.RtnDetails and test.ParamDetails tables
--
-- Design: see EA ut/Use Case Model/Test Automation/Create Helper rotine Use case/Create the Helper routine_ActivityGraph
--
-- Algorithm:
-- Create the Helper script in the TstHlpr table
-- 
-- Create the helper procedure from the script 
--
-- OUTPUTS:
-- 1: populates table: test.tstActDefHlpr with the hlper creation sql script
--
-- Preconditions:
--    PRE01: test rtn details and param details tables populated
--
-- Algorithm:
-- Create the Helper script in a table
-- Create the Helper script file from the lines in teh tables
-- Compile the procedure from the script
--
-- Changes:
-- 231115: helper should have same defaults as the tstd rtn
-- 231121: @q_tstd_rtn must exist or exception 56472, '<@q_tstd_rtn> does not exist'
-- 231121: added a try catch handler to log errors
-- 231201: better tested exception handling
-- 231213: handle wonky []
-- 231216: add check for expected line for the given step id
-- 240402: refactor - split into subroutines
-- 240724: removed the compile feature as have difficulty in getting this to work programmatically
--         now manually copy paste from the test.TstHlpr table
-- ================================================================================================================================
CREATE PROCEDURE [test].[sp_crt_tst_hlpr]
   @folder    VARCHAR(500)
AS
BEGIN
   DECLARE 
    @fn                 VARCHAR(35)   = 'sp_crt_tst_hlpr'
   ,@hlpr_rtn_nm        VARCHAR(100)
   ,@script_file_path   VARCHAR(500) 
   ,@bckslsh            VARCHAR(1) = NCHAR(92)

   SET NOCOUNT ON;

   BEGIN TRY
      ----------------------------------------------------------------------------------------------------------------------------
      -- Init
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'000: starting';
      TRUNCATE TABLE Test.HlprDef;

      SELECT
         @hlpr_rtn_nm = hlpr_rtn_nm
      FROM test.RtnDetails;

      SET @script_file_path = CONCAT(@folder, @bckslsh, @hlpr_rtn_nm, '.sql');

      ---------------------------------------------------------------------------------
      -- Create the Helper script in the TstHlpr table
      ----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '010: Creating the script in the TstHlpr table: calling sp_crt_tst_hlpr_script';
      EXEC test.sp_crt_tst_hlpr_script;

      ----------------------------------------------------------------------------------
      -- Save the script to file
      ----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '020: Create the Helper script file';
      EXEC test.sp_crt_hlpr_script_file @script_file_path;

      ----------------------------------------------------------------------------------
      -- Processing complete 
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'800: Processing complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
TRUNCATE TABLE APPLog
EXEC tSQLt.Run 'test.test_081_sp_crt_tst_hlpr';
EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [test].[TstDef](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[line] [varchar](4000) NULL,
 CONSTRAINT [PK_test.rtnDefTable] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =======================================================================================
-- Author:     Terry Watts
-- Create date: 24-APR-2024
-- Description: saves the test.TstDef table to file specified by @file_path param
-- Preconditions:
-- PRE 01: test.TestDef table populated 
-- Postconditions:                     EX
-- POST 01: the file exists OR EX 63201, 'The output file: [@file_path] does not exist
-- POST 02: write to file OK or  OR EX 63202, ''
-- =======================================================================================
CREATE PROCEDURE [test].[sp_save_mn_script_file]
   @file_path VARCHAR(MAX)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
       @fn           VARCHAR(35)   = N'sp_save_mn_script_file'
      ,@ret_code     INT
      ,@file_system  INT
      ,@file_exists_ VARCHAR(35)
      ,@file_handle  INT
      ,@file_exists  BIT
      ,@line_cnt     INT = 0
      ,@line         VARCHAR(MAX)
      ,@NL           NCHAR(2)=NCHAR(13)+NCHAR(10)

   BEGIN TRY
      EXEC sp_log 2, @fn,'000: starting, params:
file  :[',@file_path,']'
;

      ----------------------------------------------------------------------------------------------------------------------------
      -- Create Scripting.FileSystemObject
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'005: creating Scripting.FileSystemObject';
      EXECUTE @ret_code = sp_OACreate 'Scripting.FileSystemObject' , @file_system OUTPUT;

      IF (@@ERROR|@ret_code > 0 Or @file_system < 0)
      BEGIN
         EXEC sp_log 4, @fn,'010: could not create FileSystemObject';
         RAISERROR ('could not create FileSystemObject',16,1)
      END

      ----------------------------------------------------------------------------------------------------------------------------
      -- Open a new file for (over)writing
      ----------------------------------------------------------------------------------------------------------------------------
      --1 = for reading, 2 = for writing (will overwrite contents), 8 = for appending
      EXEC sp_log 1, @fn,'020: creating sql file to write rtn to';
      EXEC @ret_code = sp_OAMethod @file_system , 'OpenTextFile' , @file_handle OUTPUT , @file_path, 2, 1;

      IF (@@ERROR|@ret_code > 0 Or @file_handle < 0)
      BEGIN
         EXEC sp_log 4, @fn,'025: could not create sql file';
         RAISERROR ('could not create sql file',16,1);
      END

      ----------------------------------------------------------------------------------------------------------------------------
      -- Write the HlprDef table to the file line by line
      ----------------------------------------------------------------------------------------------------------------------------
      DECLARE row_cursor CURSOR READ_ONLY FOR
         SELECT line FROM test.TstDef;

      EXEC sp_log 1, @fn,'030: opening cursor';
      OPEN row_cursor;
      FETCH NEXT FROM row_cursor INTO @line;

      ----------------------------------------------------------------------------------------------------------------------------
      -- Main loop: reads each line from the table and writes to file
      ----------------------------------------------------------------------------------------------------------------------------
      WHILE (@@fetch_status = 0)
      BEGIN
         SET @line = CONCAT(@line, @NL);
         EXECUTE @ret_code = sp_OAMethod @file_handle , 'Write' , NULL , @line;

         IF (@@ERROR|@ret_code > 0)
         BEGIN
           -- POST 02: write to file OK or  OR EX 63202, ''

            EXEC sp_log 4, @fn,'040: could not write to file: @@ERROR ',@@ERROR,' @ret_code: ', RetCode;
            THROW 63202, 'could not write to file',1;
         END

         SET @line_cnt = @line_cnt + 1;
         FETCH NEXT FROM row_cursor INTO @line
      END

      CLOSE row_cursor
      DEALLOCATE row_cursor
      EXEC sp_log 1, @fn,'050: exported ', @line_cnt, ' procedure lines';

      EXEC @ret_code = sp_OAMethod @file_handle , 'Close' , NULL;

      IF (@@ERROR|@ret_code > 0) RAISERROR ('Could not close file',16,1);

      EXEC sp_OADestroy @file_system;

      --------------------------------------------------------------------------------------
      -- Check post conditions
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'900: checking post conditions   ';
      -- POST 01: the file exists OR EX 63201, 'The output file: [@file_path] does not exist
      EXEC sp_assert_file_exists @file_path, @ex_num=63201;

      ----------------------------------------------------------------------------------------
      --    Completed processing
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: Completed processing'
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
EXEC tSQLt.Run 'test.test_012_sp_crt_tst_mn_compile';

EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ============================================================================================================================
-- Author:      Terry Watts
-- Create date: 03-MAY-2024
-- Description: provides teh suffix for a pparameter based on its test ty in Test.ParamDetails
--
-- PRECONDITIONS:
-- test.ParamDetails pop'd
--
-- POSTCONDITIONS:
-- POST 01:
--
-- Tests:
-- ============================================================================================================================
CREATE FUNCTION [test].[fnGetParamWithSuffix](@param_nm      VARCHAR(20))
RETURNS VARCHAR(50)
AS
BEGIN
   DECLARE
       @rtn_nm      VARCHAR(4000)
      ,@tst_ty      VARCHAR(3)

   SELECT
        @tst_ty  = tst_ty
   FROM test.ParamDetails
   WHERE
      param_nm=@param_nm;

   RETURN LOWER(CONCAT('@', IIF(@tst_ty='TST', '',CONCAT(@tst_ty, '_')), @param_nm));
END
/*
EXEC test.sp_get_rtn_details 'dbo.sp_grep_rtns', @display_tables=1;
PRINT test.fnGetParamWithSuffix('ss_principal_id');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2024
-- Description: creates the parameter list for
-- the helper call in the mn tst rtn
-- =============================================
CREATE FUNCTION [test].[fnCrtMnCodeCallHlprPrms]()
RETURNS
@t TABLE
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1         VARCHAR(3) = '   '
   ,@tab2         VARCHAR(6) = '      '
   ,@max_prm_len  INT
   ,@ad_stp       BIT        = 0
   ,@rtn_ty_code  NCHAR(2)
   ,@tst_rtn_nm   VARCHAR(60)

   SELECT
       @tst_rtn_nm   = tst_rtn_nm
      ,@ad_stp       = ad_stp
      ,@rtn_ty_code  = rtn_ty_code
      ,@max_prm_len  = max_prm_len
   FROM test.RtnDetails;

   -----------------------------------------------------------------
   -- Add the hdr parameters @tst_num, @tst_key
   -----------------------------------------------------------------
   INSERT INTO @t (line) 
   SELECT
      CONCAT
      (
         @tab2, iif(ordinal=1, ' ', ',')
        ,dbo.fnPadRight
               (
                  iif(param_nm = 'display_tables' AND tst_ty='TST', CONCAT('@', param_nm), test.fnGetParamWithSuffix(param_nm))
                 , @max_prm_len+5
               ) 
            , ' = '
        , iif(is_chr_ty=1, iif(ordinal=1, '''001''',''''''), '0')
        , iif(ordinal=1 AND @ad_stp = 1, ' -- fnCrtMnCodeCallHlprPrms', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'TST';

   -----------------------------------------------------------------
   -- Add the tested rtn parameters
   -----------------------------------------------------------------
   INSERT INTO @t (line) 
   SELECT
      CONCAT
      (
         @tab2, iif(ordinal=1, ' ', ',')
      , dbo.fnPadRight(test.fnGetParamWithSuffix(param_nm), @max_prm_len+5), ' = ', iif(is_chr_ty=1, '''''', '0'))
   FROM test.ParamDetails
   WHERE tst_ty = 'INP';

   -----------------------------------------------------------------
   -- Add the expected parameters
   -----------------------------------------------------------------
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          @tab2, iif(ordinal=1, ' ', ',')
         ,dbo.fnPadRight(test.fnGetParamWithSuffix(param_nm), @max_prm_len+5), ' = NULL'
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'EXP' AND is_exception = 0;

   INSERT INTO @t (line) 
   SELECT
      CONCAT
      (
          @tab2, iif(ordinal=1, ' ', ',')
         ,dbo.fnPadRight(test.fnGetParamWithSuffix(param_nm), @max_prm_len+5), ' = NULL'
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'EXP' AND is_exception = 1;

   -----------------------------------------------------------------
   -- Close the Decl statement
   -----------------------------------------------------------------
   INSERT INTO @t (line) VALUES(CONCAT(@tab1, ';'));
   RETURN;
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 16-Apr-2024
-- Description: Add the EXEC test.<test helper proc> call and params
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions:
-- Returns: @rtnDef
-- Post 01:
--
-- Called By: sp_crt_tst_mn_script
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtMnCodeCallHlpr]()
RETURNS @t TABLE
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1               VARCHAR(3) = '   '
   ,@trn                INT
   ,@tst_proc_hlpr_nm   VARCHAR(60)
   ,@rtn_nm             VARCHAR(60)
   ,@ad_stp             BIT = 0
   ;

   SELECT
       @tst_proc_hlpr_nm = hlpr_rtn_nm
      ,@ad_stp           = ad_stp
      ,@trn              = trn
      ,@rtn_nm           = rtn_nm
   FROM test.RtnDetails
   ;

   -----------------------------------------------------------------
   -- Add the EXEC test.<test helper proc> call
   -----------------------------------------------------------------
   INSERT INTO @t (line) VALUES (CONCAT(@tab1, 'EXEC test.',@tst_proc_hlpr_nm, iif(@ad_stp=1, '  -- fnCrtMnCodeCallHlpr','')));

   -----------------------------------------------------------------
   -- Add the helper parameters
   -----------------------------------------------------------------
    INSERT INTO @t (line)
    SELECT line FROM test.fnCrtMnCodeCallHlprPrms();
   RETURN;
END
/*
SELECT * FROM test.fnCrtMnCodeCallHlpr();
EXEC tSQLt.Run 'test.test_067_sp_crt_tst_mn';
SELECT * FROM test.RtnDetails
SELECT * FROM test.ParamDetails
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
--
-- Description: creates the test helper signature line for the hlpr script like:
-- ALTER PROCEDURE test.hlpr_106_fnGetParams
--    @qrn       VARCHAR(120)
--   ,@ordinal   INT
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- Test rtn: test.test_086_sp_crt_tst_hlpr_script
--
-- ====================================================================================
CREATE FUNCTION [test].[fnCrtCodeMnTstSig]()
RETURNS @t TABLE
(
    id    INT IDENTITY (1,1)
   ,line  VARCHAR(1000)
)
AS
BEGIN
   DECLARE
    @tst_rtn_nm   VARCHAR(50)
   ,@cora         NCHAR(1)

   SELECT
      @tst_rtn_nm = tst_rtn_nm
     ,@cora       = cora
   FROM test.RtnDetails;

   INSERT INTO @t( line)
   VALUES
       (CONCAT(iif(@cora='C', 'CREATE', 'ALTER'), ' PROCEDURE test.', @tst_rtn_nm));

   RETURN;
END
/*
SELECT * FROM test.fnCrtCodeMnTstSig()
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
--
-- Description: creates the close bloc for the main test rtn
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- Test rtn: test.test_086_sp_crt_tst_hlpr_script
--
-- ====================================================================================
CREATE FUNCTION [test].[fnCrtMnCodeClose]()
RETURNS @t TABLE
(
    id    INT IDENTITY (1,1)
   ,line  VARCHAR(1000)
)
AS
BEGIN
   DECLARE
    @tst_rtn_nm   VARCHAR(50)
   ,@tab1         NCHAR(3) = '   '
   ,@ad_stp       BIT

   SELECT
      @tst_rtn_nm = tst_rtn_nm
      ,@ad_stp    = ad_stp
   FROM test.RtnDetails;

   INSERT INTO @t( line)
   VALUES
    ('')
   ,(CONCAT(@tab1,'EXEC sp_log 2, @fn, ''99: All subtests PASSED''', IIF(@ad_stp=1, ' -- CLS-1','')))
   ,(CONCAT(@tab1, 'EXEC test.sp_tst_mn_cls;'))
   ,('END')
   ,('/*')
   ,('EXEC tSQLt.RunAll;')
   ,(CONCAT('EXEC tSQLt.Run ''test.', @tst_rtn_nm,''';'))
   ,('*/')

   RETURN;
END
/*
SELECT * FROM test.fnCrtCodeMnTstSig()
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ============================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
-- Description: creates the script for the main test routine
--    populates test.TstDef table
--
-- Design: see EA ut/Use Case Model/Test Automation/Create Helper rotine Use case/Create the Helper routine_ActivityGraph
--
-- Algorithm:
-- Create the ALTER PROCEDURE signature
-- Create the As begin declare bloc
-- Create a run test line with dummy parameters
-- Create the close bloc
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated

-- Algorithm:
--
-- Changes:
-- 231115: helper should have same defaults as the tstd rtn
-- 231121: @qrn must exist or exception 56472, '<@qrn> does not exist'
-- 231121: added a try catch handler to log errors
-- 231201: better tested exception handling
-- 231213: handle wonky []
-- 231216: add check for expected line for the given step id
-- 240402: refactor - split into subroutines
--
-- ============================================================
CREATE PROCEDURE [test].[sp_crt_tst_mn_script]
AS
BEGIN
   DECLARE 
    @fn                 VARCHAR(35)   = 'sp_crt_tst_mn_script'
   ,@qrn                VARCHAR(100) -- including schema
   ,@trn                INT
   ,@ad_stp             BIT            = 0    -- used in testing to identify a step with a unique name (not an incremental int id)
   ,@act_qrn            VARCHAR(100)
   ,@row_cnt            INT
   ,@act_tst_rtn_num    INT
   ,@error_num          INT
   ,@error_msg          VARCHAR(500)
   ,@cora               NCHAR(1)
   ,@crse_rtn_ty_code   VARCHAR(1)          -- coarse grained type one of {'F','P'}
   ,@detld_rtn_ty_code  NCHAR(2)       = '?' -- detailed type code: can be 1 of {'P', 'FN', 'IF','TF'}like TF for a table function
   ,@hlpr_params        VARCHAR(MAX)
   ,@hlpr_rtn_nm        VARCHAR(120)        -- hlpr_<@trn 000>_
   ,@line               VARCHAR(500)  ='-- ========================================================================================'
   ,@line2              VARCHAR(500)  ='-- ----------------------------------------------------------------------------------------'
   ,@max_param_len      INT = -1
   ,@msg                VARCHAR(500)
   ,@n                  INT
   ,@params             VARCHAR(MAX)
   ,@stage              INT = 1
   ,@rtn_nm             VARCHAR(100)
   ,@rtn_ty             NCHAR(1)
   ,@rtn_ty_code        VARCHAR(2)
   ,@schema_nm          VARCHAR(50)
   ,@stop_stage         INT            = 12   -- stage 12 for testing - display script
   ,@tab1               VARCHAR(3) = '   '
   ,@tst_mode           BIT            = 1    -- for testing - copy tmp tables to permananent tables for teting
   ,@tst_proc_mn_nm     VARCHAR(120)
   ,@tstd_rtn_call      VARCHAR(250)
   ,@ty_code            VARCHAR(2)
   ,@txt                VARCHAR(500)
   ;

   BEGIN TRY
      EXEC sp_log 2, @fn, '';
      EXEC sp_log 2, @fn, @line2;

      ----------------------------------------------------------------------------------------------------------------------------
      -- Log paramaters
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '000: starting, getting cached rtn details';

      SELECT
          @qrn             = qrn
         ,@schema_nm       = schema_nm
         ,@rtn_nm          = rtn_nm
         ,@trn             = trn
         ,@cora            = cora
         ,@ad_stp          = ad_stp
--         ,@tst_mode        = tst_mode
--         ,@stop_stage      = stop_stage
         ,@hlpr_rtn_nm     = hlpr_rtn_nm
         ,@rtn_ty          = rtn_ty
         ,@rtn_ty_code     = rtn_ty
         ,@tst_proc_mn_nm  = tst_rtn_nm
      FROM test.RtnDetails;

      EXEC sp_log 2, @fn, '005: rtn details:
qrn        :[',@qrn  ,']
trn        :[',@trn ,']
cora       :[',@cora,']
ad_stp     :[',@ad_stp,']
tst_mode   :[',@tst_mode,']
stop_stage :[',@stop_stage,']
hlpr_rtn_nm:[', @hlpr_rtn_nm, ']
ty_code    :[', @ty_code, ']
rtn_ty     :[', @rtn_ty, ']'
;

      SET @stage = 1;
      EXEC sp_log 1, @fn, '010: clearing HlprDeftable;';

      TRUNCATE TABLE Test.TstDef;

      if @ad_stp = 1 INSERT INTO test.TstDef (line) VALUES ('-- sp_crt_tst_mn_script');
      -------------------------------------------------------------------------------
      -- Create the text header
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '015: creating the text header';
      INSERT INTO test.TstDef (line)
      SELECT line
      FROM test.fnCrtCodeTstHdr(0); -- 0 = main tst rtn, 1 = hlpr rtn

      -------------------------------------------------------------------------------
      -- Create the mn tst sig
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: creating the mn tst sig';
      INSERT INTO test.TstDef (line)
      SELECT line
      FROM fnCrtCodeMnTstSig();

      -------------------------------------------------------------------------------
      -- Create the AS BEGIN DECLARE bloc
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '025: creating the As begin declare bloc';
      INSERT INTO TstDef (line) VALUES
         ('AS')
        ,('BEGIN')
        ,('DECLARE')
        --,(CONCAT(@tab1, '@fn VARCHAR(35) = ''T', @trn, '_',UPPER(@rtn_nm), '''')) -- @tst_proc_mn_nm
        ,(CONCAT(@tab1, '@fn VARCHAR(35) = ''',@tst_proc_mn_nm, '''')) -- 
        ,('')
        ,(CONCAT (@tab1, 'EXEC test.sp_tst_mn_st @fn;'))
        ,('')
        ,(CONCAT (@tab1, '-- 1 off setup  ??'))
      ;

      -------------------------------------------------------------------------------
      -- Create 1 helper call with dummy parameters
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: creating 1 helper with dummy parameters';
      INSERT INTO test.TstDef (line)
      SELECT line FROM test.fnCrtMnCodeCallHlpr();

      -------------------------------------------------------------------------------
      -- Create the close bloc
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '035: creating the close bloc';
      INSERT INTO test.TstDef (line)
      SELECT line FROM test.fnCrtMnCodeClose();

      -------------------------------------------------------------------------------
      -- Script completed
      -------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '900 script completed';
      EXEC sp_log 2, @fn, '910 displaying mn test script   ';
      SELECT * FROM test.TstDef;
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, '500 Stage: ', @stage;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
SELECT * FROM test.Rtndetails;
EXEC tSQLt.Run 'test].[test_012_sp_crt_tst_mn_compile';
EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =====================================================================================================================
-- Author:      Terry Watts
-- Create date: 20-NOV-2023
-- Description: Creates the main test rtn in the database
--    first it creates the SQL script in the TestDef table
--    then uses that script to compile the stored procedure in the db
--
-- Preconditions
--    test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions:                     EX 58100 'Failed to compile '
-- POST 01: script exists in databse - check delegated to sp_crt_tst_mn_compile
--
-- Algorithm:
-- Get the rtn details if necessary
-- Create  the script
-- Compile the script
--
-- Tests:
--    test_066_sp_crt_tst_mn
--    test_067_sp_crt_tst_mn
--
-- Changes:
-- 231121: @qrn must exist or exception 56472, '<@qrn> does not exist'
-- 231121: added a try catch handler to log errors
-- 240406: redesign see EA: ut/Model/Use Case Model/Test Automation
-- 240724: removed the compile ferature as have difficulty in getting this to work programmatically
--         now manually copy paste from the test.TstDef table
-- =====================================================================================================================
CREATE PROCEDURE [test].[sp_crt_tst_mn]
   @folder    VARCHAR(500)
AS
BEGIN
   DECLARE 
    @fn                 VARCHAR(35)   = 'sp_crt_tst_mn'
   ,@tst_rtn_nm         VARCHAR(60)
   ,@script_file_path   VARCHAR(500) 
   ,@bckslsh            VARCHAR(1) = NCHAR(92)

   SET NOCOUNT ON;

   BEGIN TRY
      ----------------------------------------------------------------------------------------------------------------------------
      -- Init
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'000: starting';

      SELECT
         @tst_rtn_nm = tst_rtn_nm
      FROM test.RtnDetails;

      SET @script_file_path = CONCAT(@folder, @bckslsh, @tst_rtn_nm, '.sql');

      ---------------------------------------------------------------------------------
      -- Create the main script in the TstDef table-
      ----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'010: Creating the script in the TstDef table: calling sp_crt_tst_mn_script';
      EXEC test.sp_crt_tst_mn_script;

      ----------------------------------------------------------------------------------
      -- Save the script to file
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'020: Save the script to file';
      EXEC test.sp_save_mn_script_file @script_file_path;

      ----------------------------------------------------------------------------------
      -- Processing complete 
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'800: Processing complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
TRUNCATE TABLE APPLog
EXEC tSQLt.Run 'test.test_066_sp_crt_tst_mn';
EXEC tSQLt.Run 'test.test_067_sp_crt_tst_mn';
EXEC tSQLt.RunAll;
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==================================================================
-- Author:      Terry Watts
-- Create date: 15-APR-2024
-- Description: Creates both the main and the helper test rtns
-- for the given tested rtn
--
-- Responibilities:
-- 1: creates both scripts
-- 2. runs the script to compile the stored procedure in the db
--
-- Postconditions:
-- POST 01: IF @tst_rtn_num is specfied then must be > 0
-- POST 02: IF @tst_rtn_num is specfied then must not be already used
-- POST 03: @q_tstd_rtn can either be <schema_nm>.<rtn name> or <rtn name> and must uniquely define
-- POST 04: must uniquely define exactly 1 routine if rtn does not exists -> 58000, 'Routine does not exist'
-- POST 05: if more than 1 rtn exists -> 58001, 'more than 1 routine match the tested routine paramater'
-- POST 06: @crt_or_alter must be one of {'A', 'C', NULL}  If null default: 'C' -> 58002 '@crt_or_alter paramater must be one of {'A', 'C', NULL}'
--
-- Algorithm
--    INIT crt_tst_rtns_init
--    Create the hlpr rtn (script and procdure from script)
--    Create the mn rtn  (script and procdure from script)
--
-- Tests: test_068_sp_crt_tst_rtns
--
-- Changes:
-- 231124: added remove [] brackets to make it easier to set up tests
-- 240724: removed the compile ferature as have difficulty in getting this to work programmatically
--         now manually copy paste from the test.TstHlpr table
-- 241031: removed @tst_mode param, defaulted @folder param
-- 241111: if @trn not supplied look for the first unused trn
-- 241115: default @ad_stp to 1
-- ==================================================================
CREATE PROCEDURE [test].[sp__crt_tst_rtns]
    @qrn       VARCHAR(100)  -- including schema
   ,@trn       INT            = NULL
   ,@cora      NCHAR(1)       = 'C'
   ,@ad_stp    BIT            = 0    -- 241115: default @ad_stp to 1 outputs fn call as comment in script to aid debugging
   ,@folder    VARCHAR(500)  = 'D:\tmp'
AS
BEGIN
   DECLARE 
    @fn              VARCHAR(35)   = 'sp_crt_tst_rtns'
   ,@n               INT

   SET NOCOUNT ON;

   BEGIN TRY
      EXEC sp_log 2, @fn, '00: starting:
   @qrn     :[',@qrn      ,']
   @trn     :[',@trn      ,']
   @cora    :[',@cora     ,']
   @ad_stp  :[',@ad_stp   ,']
   @ad_stp  :[',@ad_stp   ,']
   ';

      ----------------------------------------------------------------------------------------
      -- INIT crt_tst_rtns_init
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '05: test.calling sp_crt_tst_fn_hlpr';
      EXEC test.sp_crt_tst_rtns_init @qrn, @trn, @cora, @ad_stp;

      ----------------------------------------------------------------------------------------
      -- Create the hlpr rtn (script and procdure from script)
      ----------------------------------------------------------------------------------------
      EXEC test.sp_crt_tst_hlpr @folder;
      EXEC sp_log 3, @fn, '50: stopping early - while TDD';

      ----------------------------------------------------------------------------------------
      -- Create the mn rtn  (script and procdure from script)
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: calling test.sp_crt_tst_fn_mn';
      EXEC test.sp_crt_tst_mn @folder;

      ----------------------------------------------------------------------------------------
      --    Completed processing
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: Completed processing'
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
EXEC tSQLt.Run 'test.test_068_sp__crt_tst_rtns';
SELECT * FROM test.fnGetUntestedRtns();
TRUNCATE TABLE AppLog;
EXEC tSQLt.RunAll;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: settigns key for the current test number
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstNumKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Test num';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 05-FEB-2021
-- Description: Sets the @tst_num in the session context
--              Key: fnGetCrntTstNumKey()->N'Test num'
--
-- Tests:       test.test_049_SetGetCrntTstValue
-- Oppo         test.fnGetCrntTstNum()
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_num] @tst_num VARCHAR(60)
AS
BEGIN
DECLARE
    @fn     VARCHAR(35) = 'sp_tst_set_crnt_tst_num'
   ,@key    NVARCHAR(60);

   SET @key = test.fnGetCrntTstNumKey();
   EXEC sp_log 0, @fn,'000: starting, fn: ', @fn, ' key:[', @key,'] @tst_num:[',@tst_num,']';
   EXEC sp_set_session_context @key, @tst_num;
END
/*
EXEC tSQLt.Run 'test.test_030_chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===========================================================================
-- Author:      Terry
-- Create date: 20-NOV-2024
-- Description: gets the settings key for the current test number like T001
-- Tests: [test].[test 030 chkTestConfig]
-- ===========================================================================
CREATE FUNCTION [test].[fnGetCrntTstNum2Key]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Test num2';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==================================================================================
-- Author:      Terry Watts
-- Create date: 20-NOV-2024
-- Description: Sets the @tst_num2 ctx this is the numeirc part of the sub test name
--              Key: fnGetCrntTstNum2Key()->N'Test num2'
-- Tests:       test.test_049_SetGetCrntTstValue
-- Oppo         test.fnGetCrntTstNum()
-- ==================================================================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_num2] @tst_num VARCHAR(3)
AS
BEGIN
   DECLARE
    @fn     VARCHAR(35) = 'sp_tst_set_crnt_tst_num2'
   ,@key    NVARCHAR(60);

   SET @key = test.fnGetCrntTstNum2Key();
   EXEC sp_log 0, @fn,'000: starting, fn: ', @fn, ' key:[', @key,'] @tst_num:[',@tst_num,']';
   EXEC sp_set_session_context @key, @tst_num;
   EXEC sp_log 0, @fn,'999: leaving';
END
/*
EXEC tSQLt.Run 'test.test_049_SetGetCrntTstValue'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================
-- Author:      Terry
-- Create date: 03-DEC-2024
-- Description: Gets the current failed test num from settings
-- Tests: test_049_SetGetCrntTstValue
-- =============================================================
CREATE FUNCTION [test].[fnGetCrntTst1OffSetupFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Tst1OffSetupFn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests: test_049_SetGetCrntTstValue
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_1_off_setup_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE
      @fn   VARCHAR(35) = 'sp_tst_set_crnt_1_off_setup_fn'
     ,@key  NVARCHAR(40)= test.fnGetCrntTst1OffSetupFnKey()
     ;

   EXEC sp_log 0, @fn, 'starting, @val:[',@val,']';
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test_049_SetGetCrntTstValue'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current close fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstClsFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'TCLS fn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests:       test_049_SetGetCrntTstValue
-- Oppo:        test.fnGetCrntTstClseFn
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_clse_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE
    @fn  VARCHAR(35) = N'sp_tst_set_crnt_tst_clse_fn'
   ,@key NVARCHAR(40);

   SET @key = test.fnGetCrntTstClsFnKey()
   EXEC sp_log 0, @fn,'000: starting, @val: ', @val;
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.test_049_SetGetCrntTstValue
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current per test fn name from settings
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstSetupFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'TSU fn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests:       test 030 chkTestConfig
-- Key:         N'TSU fn'
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_setup_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE @key NVARCHAR(40) = test.fnGetCrntTstSetupFnKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetCrntTstSetupFnKey()
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current tested fn name from settings
-- Key:         N'Tested fn'
-- Tests:       test.test 030 chkTestConfig
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstdFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Tested fn';
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests:       test_030_chkTestConfig
-- Key:         'Tested fn'
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tstd_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE @key NVARCHAR(40) = test.fnGetCrntTstdFnKey();
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test_030_chkTestConfig';
EXEC tSQLt.RunAll;
PRINT test.fnGetCrntTstdFnKey();
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 06-FEB-2021
-- Description: Gets the display log flag key
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetDisplayLogFlgKey]()
RETURNS NVARCHAR(30)
AS
BEGIN
   RETURN N'Display Log Flag';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests:       test_030_chkTestConfig
-- Key:         Display Log Flag
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_display_log_flg] @val BIT
AS
BEGIN
   DECLARE @key NVARCHAR(6) = test.fnGetDisplayLogFlgKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetDisplayLogFlgKey()
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 06-FEB-2021
-- Description: settings key for the failes test sub number
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetTstPassCntKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Passed test count';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ================================================
-- Author:      Terry watts
-- Create date: 06-FEB-2021
-- Description: Setter, clears the test pass count
-- Tests: test.test_030_chkTestConfig
-- ================================================
CREATE PROCEDURE [test].[sp_tst_clr_test_pass_cnt]
AS
BEGIN
   DECLARE @key NVARCHAR(40) = test.fnGetTstPassCntKey()
   EXEC sp_set_session_context @key, 0;
END
/*
EXEC test.test 030 chkTestConfig;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current test fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Test fn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests: [test].[test 030 chkTestConfig]
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE @key NVARCHAR(40) = test.fnGetCrntTstFnKey();
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current close fn name from settings
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstHlprFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Hlpr fn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 05-FEB-2021
-- Description: Setter: for the test helper fn
-- Tests: [test].[test 030 chkTestConfig]
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_hlpr_fn] @val VARCHAR(100)
AS
BEGIN
   DECLARE @key NVARCHAR(60) = test.fnGetCrntTstHlprFnKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetCrntTstHlprFnNmKey()
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================================================
-- Author:      Terry Watts
-- Create date: 13-JAN-2020
-- Description: determines if a character is whitespace
--
-- whitespace is: 
-- (NCHAR(9), NCHAR(10), NCHAR(11), NCHAR(12), NCHAR(13), NCHAR(14), NCHAR(32), NCHAR(160))
--
-- RETURNS: 1 if is whitspace, 0 otherwise
-- ===============================================================================================
CREATE FUNCTION [dbo].[fnIsWhitespace]( @t NCHAR) 
RETURNS BIT
AS
BEGIN
   RETURN CASE WHEN  @t IN (NCHAR(9) , NCHAR(10), NCHAR(11), NCHAR(12)
                           ,NCHAR(13), NCHAR(14), NCHAR(32), NCHAR(160)) THEN 1 
              ELSE 0 END
END



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==========================================================================================
-- Author:      Terry Watts
-- Create date: 05-FEB-2021
-- Description: determines if the string contains whitespace
--
-- whitespace is: 
-- (NCHAR(9), NCHAR(10), NCHAR(11), NCHAR(12), NCHAR(13), NCHAR(14), NCHAR(32), NCHAR(160))
--
-- RETURNS: 1 if string contains whitspace, 0 otherwise
-- ==========================================================================================
CREATE FUNCTION [dbo].[fnContainsWhitespace]( @s VARCHAR(4000))
RETURNS BIT
AS
BEGIN
   DECLARE
       @res       BIT = 0
      ,@i         INT = 1
      ,@len       INT = dbo.fnLen(@s)

   WHILE @i <= @len
   BEGIN
      IF dbo.fnIswhitespace(SUBSTRING(@s, @i, 1))=1
      BEGIN
         SET @res = 1;
         break;
      END

      SET @i = @i + 1;
   END

   RETURN @res;
END



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 08-DEC-2024
-- Description: determines if a sql_variant is an
-- integral type: {int, smallint, tinyint, bigint, money, smallmoney}
-- test: [test].[t 025 fnIsFloat]
--
-- Changes:
-- 241128: added optional check for non negative ints
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsTxtInt]( @v VARCHAR(50), @must_be_positive BIT)
RETURNS BIT
AS
BEGIN
   DECLARE @val INT
   ,@ret BIT

   -- SETUP
   IF @must_be_positive IS NULL  SET @must_be_positive = 0;

   -- PROCESS
   SET @val = TRY_CONVERT(INT, @v);
   SET @ret = iif(@val IS NULL, 0, 1);

      IF @ret = 1 AND @must_be_positive = 1
      BEGIN
         SET @ret = iif(@val >=0, 1, 0);
      END

   RETURN @ret;
END

/*
   DECLARE
       @v_str  VARCHAR(4000)
      ,@ret    BIT = 0
      ,@val    INT

--   DECLARE @type SQL_VARIANT
--   DECLARE @ty   VARCHAR(500)
--   SELECT @type = SQL_VARIANT_PROPERTY(@v, 'BaseType');
--   SET @ty = CONVERT(VARCHAR(20), @type);
   SET @v_str = CONVERT(VARCHAR(4000), @v);

   WHILE(1=1)
   BEGIN
      IF dbo.fnLen(@v_str) = 0
         BREAK;

      IF @must_be_positive IS NULL  SET @must_be_positive = 0;
      SET @val = TRY_CONVERT(INT, @v);

      SET @ret = iif(@val IS NULL, 0, 1);

      IF @ret = 1 AND @must_be_positive = 1
      BEGIN
         --SET @val =  CONVERT(INT, @v);
         SET @ret = iif(@val >=0, 1, 0);
      END

      BREAK;
   END
   RETURN @ret;
END
*/
/*
PRINT CONVERT(INT, NULL);
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_044_fnIsInt';
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 05-FEB-2021
-- Description: main start set up
--
-- Responsibilities:
--    clear  test_pass_cnt= 0,
--
--    pop  the following:
--    crnt_tstd_fn
--    crnt_tst_fn
--    crnt_tst_hlpr_fn
--    rnt_tst_1_off_setup_fn
--    crnt_tst_setup_fn
--    crnt_tst_clse_fn
--
-- Validated preconditions:
--    PRE 01: @tst_fn must have at least 11 characters and be like: like ''test_nnn_<tested rtn mn>chkTestConfig''
--    PRE 02: the nnn @tst_fn must be a positive integer
--    PRE 02: @tst_fn must have no spaces
--
-- Postconditions 
-- CHANGES:
-- 241128: added paramater validation
-- =============================================
CREATE PROCEDURE [test].[sp_tst_mn_st_su]
       @tst_fn    VARCHAR(80)   = NULL   -- test fn like 'test 030 chkTestConfig'
      ,@log       BIT            = 1
AS
BEGIN
   DECLARE
       @tested_fn VARCHAR(60)            -- the tested function name
      ,@fn_num    VARCHAR(3)             
      ,@hlpr_fn   VARCHAR(60)            -- helper fn
      ,@tsu_fn    VARCHAR(60)            -- tsu    fn
      ,@tsu1_fn   VARCHAR(60)            -- tsu    fn
      ,@tcls_fn   VARCHAR(60)            -- close  fn
      ,@key       VARCHAR(40)
      ,@fn        VARCHAR(60) = N'sp_tst_mn_st_su'
      ,@len       INT
      ,@msg       VARCHAR(150)
      ,@is_num    BIT

   BEGIN TRY
      --PRINT CONCAT(@fn, ': 1')
      EXEC sp_log 0, @fn,'000: starting, @tst_fn:[',@tst_fn,']';
      --PRINT CONCAT(@fn, ': 2')
      ----------------------------------------------------------------------------------
      -- Validate inputs
      ----------------------------------------------------------------------------------
      EXEC sp_log 0, @fn,'010: Validate inputs';
--      PRINT CONCAT(@fn, ': 3')
      -- test fn like 'test 030 chkTestConfig'
      SET @len = dbo.fnLen(@tst_fn);
      --EXEC sp_log 0, @fn,'020: @len: ', @len;
      SET @msg = CONCAT(' ',@fn, ' @tst_fn: [',@tst_fn,'] must have at least 11 characters and be like: like ''test_nnn_<tested rtn mn>chkTestConfig'' and have no spaces,
      nnn must be a positive integer like 015');

      -- PRE 01: @tst_fn must have at least 11 characters and be like: like ''test_nnn_<tested rtn mn>chkTestConfig''
      --EXEC sp_log 0, @fn,'030 calling sp_assert_gtr_than @len: ', @len;
      EXEC sp_assert_gtr_than @len, 11, '011:', @msg;
      --EXEC sp_log 0, @fn,'040';
      SET @fn_num = SUBSTRING( @tst_fn, 6, 3 );
      --EXEC sp_log 0, @fn,'010.15';
--      PRINT CONCAT(@fn, ': 10')
      EXEC dbo.sp_assert_not_null_or_empty @fn_num, '012: @fn_num must not be null @test_fn: ', @msg2 = @tst_fn;
      --EXEC sp_log 0, @fn,'050: calling dbo.fnIsInt(',@fn_num,', 1);';
      SET @is_num = dbo.fnIsTxtInt(@fn_num, 1);

      --EXEC sp_log 0, @fn,'010.2 checking that @tst_fn has a positive integer';
--    PRE 02: the nnn @tst_fn must be a positive integer
      EXEC sp_assert_equal 1, @is_num, '060: @fn_num: [', @fn_num, '] must be a positive integer like ''015''';

      EXEC sp_log 0, @fn,'070';
      SET @tested_fn = SUBSTRING( @tst_fn, 10, 100);
      --EXEC sp_log 0, @fn, '080: @tested_fn:[', @tested_fn, ']';
      EXEC dbo.sp_assert_not_null_or_empty @tested_fn, '013: tested_fn must be specified - chars 10-100 of @tst_fn psram';
      --EXEC sp_log 0, @fn,'010.4';
  --    PRINT CONCAT(@fn, ': 20')

      -- PRE 03: @tst_fn must have no spaces
      IF CHARINDEX(' ', @tst_fn) > 0
      BEGIN
         EXEC sp_log 4, @fn,'090: @tst_fn must have no spaces';
         EXEC sp_raise_exception 56010, @fn, ' PRE 03: @tst_fn must have no spaces';
      END

      EXEC sp_log 0, @fn,'100';

      IF CHARINDEX('test_', @tst_fn )<> 1
      BEGIN
         EXEC sp_log 4, @fn,'110: test rtn nam should start with ''TEST_''';
         EXEC sp_raise_exception 53602, '100: ', @msg;
      END

      EXEC sp_log 0, @fn,'120: Validate inputs - OK';
      ----------------------------------------------------------------------------------
      -- Calc the test fn names for this test
      ----------------------------------------------------------------------------------
      -- Set the logging flag
      EXEC test.sp_tst_set_display_log_flg @log;

      SET @hlpr_fn = CONCAT(N'hlpr_', @fn_num, N' ', @tested_fn);
      SET @tsu_fn  = CONCAT(N'TSU ' , @fn_num, N' ', @tested_fn);
      SET @tsu1_fn = CONCAT(N'TSU1 ', @fn_num, N' ', @tested_fn);
      SET @tcls_fn = CONCAT(N'TCLS ', @fn_num, N' ', @tested_fn);

      ----------------------------------------------------------------------------------
      -- Validate
      ----------------------------------------------------------------------------------
      --EXEC sp_log 0, @fn, '130: @tested_fn:[', @tested_fn, ']';
      --EXEC sp_log 0, @fn, '140: @fn_num:[', @fn_num, ']';
      EXEC dbo.sp_assert_not_null_or_empty @hlpr_fn  , @msg1 = '140: @hlpr_fn  must be specified';
      EXEC dbo.sp_assert_not_null_or_empty @tsu_fn   , @msg1 = '150: @tsu_fn   must be specified';

      EXEC dbo.sp_assert_not_null_or_empty @tsu1_fn  , @msg1 = '160: @tsu1_fnm must be specified';
      EXEC dbo.sp_assert_not_null_or_empty @tcls_fn  , @msg1 = '170: @tcls_fn  must be specified';
      --EXEC sp_log 0, @fn,'909';
      SET @len = dbo.fnLen(@fn_num);

      EXEC dbo.sp_assert_equal 3, @len ,'200: @fn_num len should be 3';
      SET @len = dbo.fnContainsWhiteSpace(@fn_num);
      EXEC dbo.sp_assert_equal 0, @len ,'210: @fn_num len should not contain spaces';

      ----------------------------------------------------------------------------------
      -- Set the state:
      ----------------------------------------------------------------------------------
      EXEC test.sp_tst_clr_test_pass_cnt;
      EXEC test.sp_tst_set_crnt_tst_num @fn_num;               --  oppo: fnGetCrntTstNum()         KEY: N'Test num'
      EXEC test.sp_tst_set_crnt_tst_num2           @fn_num;    -- Just the 3 digit test number
      EXEC test.sp_tst_set_crnt_tstd_fn @tested_fn;            --  oppo: fnGetCrntTstdFn()         KEY: N'Tested fn'
      EXEC test.sp_tst_set_crnt_tst_fn @tst_fn;                -- oppo: fnGetCrntTstFn()           KEY: N'Test fn'
      EXEC test.sp_tst_set_crnt_tst_hlpr_fn @hlpr_fn;          -- oppo: fnGetCrntTstHlprFn()       KEY: N'Hlpr fn'
      EXEC test.sp_tst_set_crnt_tst_1_off_setup_fn @tsu1_fn;   -- oppo: fnGetCrntTst1OffSetupFn()  KEY: N'TSU1 fn'
      EXEC test.sp_tst_set_crnt_tst_setup_fn @tsu_fn;          -- oppo: fnGetCrntTstSetupFn()      KEY: N'TSU fn'

      EXEC test.sp_tst_set_crnt_tst_clse_fn @tcls_fn;          -- oppo: fnGetCrntTstCloseFn()      KEY: N'TCLS fn'
      EXEC sp_log 0, @fn,'400: Processing complete';
   END TRY
   BEGIN CATCH
      PRINT CONCAT(@fn, ': 499: Caught exception')
      EXEC sp_log 4, @fn,'500: Caught exception';
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

--      PRINT CONCAT(@fn, ': 999')
   EXEC sp_log 0, @fn,'999: leaving OK'
END
/*
EXEC sp_Set_log_level 0
EXEC test.sp_tst_mn_st_su 'test_049_SetGetCrntTstValue'

ECEC test.sp_tst_mn_st 'test_049_SetGetCrntTstValue'
EXEC tSQLt.Run 'test.test_050_sp_assert_not_null_or_zero';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =========================================================
-- Author:      Terry Watts
-- Create date: 20-NOV-2024
-- Description: returns test hdr or footer line
-- =========================================================
CREATE FUNCTION [test].[fnGetTstHdrFooterLine]
(
    @is_mn_tst BIT
   ,@is_Hdr    BIT            -- 1:hdr, 0 = footer
   ,@tst_num   VARCHAR(100)
   ,@msg       VARCHAR(100)
)
RETURNS VARCHAR(500)
AS
BEGIN
   DECLARE
       @len       INT
      ,@output    VARCHAR(500)
      ,@line      VARCHAR(160)
      ,@NL        VARCHAR(2)    = NCHAR(13) + NCHAR(10)
      ,@len2      INT
      ,@tst_ty    VARCHAR(160)
      ,@log_level INT
   ;

   SET @tst_ty = iif(@is_mn_tst = 1, ' Main Test',' Sub-test');
   SET @line = REPLICATE(iif(@is_mn_tst=1, '*','+'), 160);
   SET @len = dbo.fnLen(@tst_num);
   SET @len2 = 120;
   SET @log_level = dbo.fnGetLogLevel();

   IF @is_mn_tst = 0 SET @len2 = @len2 +1;
   IF @is_Hdr = 0 SET @len2 = @len2 +2;

   SET @output = 
      iif
      (
         @log_level <= 1
         ,CONCAT -- verbose if log level 0,1
         (
             @NL
            ,SUBSTRING(@line,1,30)
            ,iif(@is_mn_tst=1, ' Main Test',' Sub-test')
            ,' ', @tst_num, ' '
            ,@msg, ' '
            ,SUBSTRING(@line,1,dbo.fnMax(5, @len2 - @len)) -- + iif(@is_mn_tst=0, 1, 0)
            ,@NL
            ,@NL
         )
         ,CONCAT( @tst_num, ' ', @msg, ' ')
      );

   RETURN @output;
END
/*
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: Gets the current ErrorStateKey key
-- Tests: test_049_SetGetCrntTstValue
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstErrStKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Error state';
END
/*
EXEC tSQLt.Run 'test_049_SetGetCrntTstValue'
EXEC tSQLt.RunAll
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================================
-- Author:      Terry watts
-- Create date: 05-FEB-2021
-- Description: setter: error_state
-- Tests: [test].[test 030 chkTestConfig]
-- =================================================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_err_st] @val INT
AS
BEGIN
   DECLARE @key VARCHAR(80) = test.fnGetCrntTstErrStKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===========================================================
-- Author:      Terry Watts
-- Create date: 06-APR-2020
-- Description: Encapsulates the main test routine startup
-- Parameters:  @tfn: the test function name
--
-- Session Keys:
--    Test fn           : 'Test fn'
--    Tested fn         : 'Tested fn'
--    Helper fn         : 'Helper fn'
--    per test setup fn : 'TSU fn'
--    1 off setup fn    : 'TSU1 fn'
--    per test close fn : 'TCLS fn'
--
-- POSTCONDITIONS:
-- POST 01: if @test_fn null or empty -> ex:
-- ===========================================================
CREATE PROCEDURE [test].[sp_tst_mn_st]
       @tst_fn VARCHAR(80)   = NULL   -- test fn
      ,@log    BIT            = 0      -- default not to display the log
AS
BEGIN
   DECLARE
       @fn                    VARCHAR(60) = N'sp_tst_mn_st'
      ,@fn_tst_pass_cnt_key   VARCHAR(50)
      ,@NL                    VARCHAR(2)    = NCHAR(13) + NCHAR(10)
      ,@Line                  VARCHAR(100)  = REPLICATE('-', 100)
      ,@tested_fn             VARCHAR(60)      -- the tested function name
      ,@is_short_msg          BIT
      ,@tsu_fn                VARCHAR(60)      -- tsu    fn
      ,@tsu1_fn               VARCHAR(60)      -- tsu    fn
      ,@tcls_fn               VARCHAR(60)      -- close  fn

   BEGIN TRY
      SET NOCOUNT ON
      PRINT test.fnGetTstHdrFooterLine(1, 1, @tst_fn, 'starting');
      DELETE FROM AppLog;
      SET @is_short_msg = iif(dbo.fnGetLogLevel()>1, 1,0);
      EXEC sp_log 0, @fn, '000: starting (',@tst_fn,')';

      -- Validate Parameters
      EXEC dbo.sp_assert_not_null_or_empty @tst_fn, '@test_fn parameter must be specified';
      EXEC sp_log 0, @fn, '005';
      SET @tested_fn = SUBSTRING(@fn, 10, 99);
      EXEC sp_log 0, @fn, '006';

      -- Stop any more logging in this fn
      EXEC sp_set_session_context N'TST_MN_ST'        , 1;
      EXEC sp_log 0, @fn, '007';

      -- set up all test fn names and initial state
      EXEC sp_log 0, @fn,'010: calling sp_tst_mn_tst_st_su';
      EXEC test.sp_tst_mn_st_su
       @tst_fn = @tst_fn
      ,@log    = @log;

      EXEC sp_log 0, @fn,'015: setting context state';
      -- ASSERTION: all test fn names set up and initial state initialised properly
      -- Add static test passed count
      SET @fn_tst_pass_cnt_key  = CONCAT(@fn, N' tests passed');
      EXEC sp_set_session_context   @fn_tst_pass_cnt_key , 0;
      EXEC sp_set_session_context N'DISP_TST_RES'        , 1;
      EXEC test.sp_tst_set_crnt_tst_err_st 0;
      END TRY
   BEGIN CATCH
      PRINT CONCAT('ERROR ', @fn, ' 500: caught exception');
      EXEC sp_log 4, @fn, '500: caught exception';
      PRINT CONCAT('ERROR ', @fn, ' 510: caught exception');
      EXEC sp_log_exception @fn;
      PRINT CONCAT('ERROR ', @fn, ' 520: caught exception');
      THROW;
   END CATCH

   EXEC sp_log 0, @fn,'999: leaving OK';
END
/*
EXEC tSQLt.Run 'test.test_059_sp_tst_mn_st'
EXEC 
EXEC tSQLt.RunAll
*/



GO
GO

CREATE TYPE [dbo].[IdNmTbl] AS TABLE(
	[id] [int] IDENTITY(1,1) NOT NULL,
	[val] [varchar](4000) NULL,
	PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (IGNORE_DUP_KEY = OFF)
)

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 03-APR-2020
-- Description: Inserts a log row in the app log
--
--              Splits into column based on tabs in the the message or 

   -- set @tmp = LEFT(CONCAT(REPLICATE( '  ', @sf), REPLACE(LEFT( @tmp, 500), @NL, '--')), 500);
   -- set @tmp = LEFT(CONCAT( REPLACE(LEFT( @tmp, 500), @NL, '--')), 500);
-- =============================================
CREATE PROCEDURE [dbo].[sp_appLog_display]
    @rtns   VARCHAR(MAX) = NULL -- like 'dbo.fnA,test.sp_b'
   ,@msg    VARCHAR(4000)= NULL     -- no %%
   ,@level  INT          = NULL
   ,@id     INT          = NULL -- starting id
   ,@dir    BIT          = 1 -- ASC
AS
BEGIN
DECLARE
    @fn                 VARCHAR(35)   = N'sp_appLog_display '
   ,@sql                VARCHAR(4000)
   ,@need_where         BIT = 0
   ,@nl                 VARCHAR(2)   = CHAR(13) + CHAR(10)
   ,@fns                IdNmTbl
   ,@s                  VARCHAR(4000)
   ;

   SET NOCOUNT ON;

   INSERT into @fns(val) SELECT value FROM string_split(@rtns,',');
   SELECT @s = string_agg(CONCAT('''', val, ''''),',') FROM @fns;
--   PRINT(@s);
   SET @need_where = 
      IIF(    @rtns  IS NOT NULL
           OR @level IS NOT NULL
           OR @id    IS NOT NULL
           OR @msg   IS NOT NULL
           ,1, 0);

   SET @sql = CONCAT(
'SELECT
  id
,[level]
,rtn AS [rtn',   REPLICATE('_',20), ']
,SUBSTRING(msg, 1  , 128) AS ''msg1', REPLICATE('_',100), '''
,SUBSTRING(msg, 129, 128) AS ''msg2', REPLICATE('_',100), '''
,SUBSTRING(msg, 257, 128) AS ''msg3', REPLICATE('_',100), '''
,SUBSTRING(msg, 385, 128) AS ''log4', REPLICATE('_',100), '''
FROM AppLog
'
,iif(@need_where= 0, '', CONCAT('WHERE '                                                            , @nl))
,iif(@rtns  IS NULL, '', CONCAT(' rtn IN (', @s, ')'                                                , @nl))
,iif(@msg   IS NULL, '', CONCAT(IIF(@rtns IS NULL                   ,'', ' AND'),' msg LIKE (''%', @msg, '%'')'         , @nl))
,iif(@level IS NULL, '', CONCAT(IIF(@rtns IS NULL                   ,'', ' AND'),' level = ', @level, @nl))
,iif(@id    IS NULL, '', CONCAT(IIF(@rtns IS NULL AND @level IS NULL,'', ' AND'),' id >= '  , @id   , @nl))
,'ORDER BY ID ', iif(@dir=1, 'ASC','DESC'), ';'
);

 --  PRINT CONCAT(@fn, '100: executing sql:', @sql);
   EXEC (@sql);

/*   IF dbo.fnGetLogLevel() = 0
      PRINT CONCAT( @fn,'999: leaving:');*/
END
/*
EXEC tSQLt.RunAll;

EXEC sp_appLog_display;
EXEC sp_appLog_display @rtns='S2_UPDATE_TRIGGER',@msg='@fixup_row_id: 4'
EXEC sp_appLog_display @id=140;
000: starting @fixup_row_id: 4, @imp_file_nm: [ImportCorrections_221018-Crops.txt], @fixup_stg_id: 4, @search_clause: [ agricult
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 06-FEB-2021
-- Description: Gets the display log flag
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetDisplayLogFlg]()
RETURNS BIT
AS
BEGIN
   RETURN CONVERT(BIT, SESSION_CONTEXT(test.fnGetDisplayLogFlgKey()));
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current tested fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstdFn]()
RETURNS VARCHAR(60)
AS
BEGIN
   RETURN CONVERT(VARCHAR(60), SESSION_CONTEXT(test.fnGetCrntTstdFnKey()));
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: accessor: error_state
-- Tests: test_049_SetGetCrntTstValue
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstErrSt]()
RETURNS INT
AS
BEGIN
   RETURN CONVERT( INT, SESSION_CONTEXT(test.fnGetCrntTstErrStKey()));
END
/*
PRINT [test].[fnGetCrntTstErrSt]()
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current test fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstFn]()
RETURNS VARCHAR(60)
AS
BEGIN
   RETURN CONVERT(VARCHAR(60), SESSION_CONTEXT(test.fnGetCrntTstFnKey()));
END

/*
PRINT [test].[fnGetCurrentTestFnName]()

EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 15-JAN-2020
-- Description: returns standard NL char(s)
-- =============================================
CREATE FUNCTION [dbo].[fnGetNL]()
RETURNS VARCHAR(2)
AS
BEGIN
   RETURN NCHAR(13)+NCHAR(10)
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ========================================================
-- Author:      Terry Watts
-- Create date: 06-APR-2020
-- Description: Encapsulates the main test routine startup
-- ========================================================
CREATE PROCEDURE [test].[sp_tst_mn_cls] @err_msg VARCHAR(4000) = NULL
AS
BEGIN
   DECLARE
       @fn           VARCHAR(30)   = N'sp_tst_mn_cls'
      ,@tested_fn    VARCHAR(50)   = test.fnGetCrntTstdFn()
      ,@tst_fn       VARCHAR(50)   = test.fnGetCrntTstFn()
      ,@msg          VARCHAR(2000)
      ,@nl           VARCHAR(2)    = dbo.fnGetNL()
      ,@tests_passed INT
      ,@error_st     BIT            = test.fnGetCrntTstErrSt()
      ,@is_short_msg BIT

   SET @is_short_msg = iif(dbo.fnGetLogLevel()>1, 1,0);
   SET @msg = iif(@error_st = 0, 'Test: All sub tests passed', CONCAT('Error: 1 or more sub tests failed', @NL));
   EXEC sp_log 2, @fn, @tst_fn, ' finished, ', @msg, @short_msg = @is_short_msg;

   -- The disp log flag is set on startup
   -- Display Log both up and down ASC and DESC
   IF test.fnGetDisplayLogFlg() = 1
   BEGIN
      EXEC dbo.sp_appLog_display 1  -- descending order
      EXEC dbo.sp_appLog_display 0; -- ascending  order
   END

   -- Clear all flags and counters
   PRINT test.fnGetTstHdrFooterLine(1, 0, @tst_fn, CONCAT('', iif(@error_st = 0, 'PASSED', 'FAILED')));
END
/*
EXEC test.sp_tst_mn_st 'test_011_sp_import_UseStaging';
EXEC test.sp_tst_mn_cls;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 03-DEC-2024
-- Description: gets the current sub test id key
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntSubTstKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Current sub test';
END
/*
PRINT test.fnGetCrntSubTstKey()
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================================
-- Author:      Terry watts
-- Create date: 03-DEC-2024
-- Description: sets the current sub test id
-- Tests:       test_049_SetGetCrntTstValue
-- =================================================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_sub_tst] @sub_tst VARCHAR(100)
AS
BEGIN
   DECLARE
      @fn   VARCHAR(35) = 'sp_tst_set_crnt_sub_tst'
     ,@key  VARCHAR(40) = test.fnGetCrntSubTstKey();
   ;

   EXEC sp_log 0, @fn, 'starting, @sub_tst:[',@sub_tst,']';
   EXEC sp_set_session_context @key, @sub_tst;
END
/*
EXEC tSQLt.Run 'test.test_049_SetGetCrntTstValue'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: settings key for the failes test sub number
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntFailedTstNumKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Failed test num';
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 05-FEB-2021
-- Description: Setter
-- Tests: test.test_049_fnGetCrntTstValue
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_failed_tst_num] @val VARCHAR(60)
AS
BEGIN
   DECLARE @key NVARCHAR(60);
   SET @key = test.fnGetCrntFailedTstNumKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: settings key for the current failed test number
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntFailedTstSubNumKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Failed test sub num';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================
-- Author:      Terry watts
-- Create date: 05-FEB-2021
-- Description: Setter
-- Tests: test_049_SetGetCrntTstValue
-- ====================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_failed_tst_sub_num] @val VARCHAR(60)
AS
BEGIN
   DECLARE @key NVARCHAR(40);
   SET @key = test.fnGetCrntFailedTstSubNumKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 20-NOV-2024
-- Description: Gets the current test hlpr fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstHlprFn]()
RETURNS VARCHAR(60)
AS
BEGIN
   RETURN CONVERT(VARCHAR(60), SESSION_CONTEXT(test.fnGetCrntTstHlprFnKey()));
END
/*
PRINT [test].[fnGetCrntTstHlprFn]()
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===================================================
-- Author:      Terry Watts
-- Create date: 05-APR-2020
-- Description:
--  Encapsulates the test helper startup:
--  Prints a line to separate test output
--  Prints the EXEC sp_log 2, @fn, '01: starting msg
--  Sets the current test num context
--
--  Clears previous test state context:
--    crnt_tst_err_st         = 0
--    crnt_failed_tst_num     = NULL
--    crnt_failed_tst_sub_num = NULL
-- ===================================================
CREATE PROCEDURE [test].[sp_tst_hlpr_st]
    @sub_tst   VARCHAR(50) -- Like '010: Chk Rule 1' OR 'T010: Chk Rule 1'
   ,@params    VARCHAR(MAX) = NULL
AS
BEGIN
   DECLARE
    @fn        VARCHAR(35)   = N'sp_tst_hlpr_st'
   ,@fnHlrSt   VARCHAR(35)
   ,@NL        VARCHAR(2)    = NCHAR(13) + NCHAR(10)
   ,@line      VARCHAR(100)  = REPLICATE(N'=', 100)
   ,@prms_msg  VARCHAR(MAX)
   ,@tstRtn    VARCHAR(60)
   ,@subTstNum VARCHAR(10) --  = test.fnGetCrntTstNum2()
   ,@msg       VARCHAR(500)
   ,@ndx       INT
   ;

   SET @tstRtn = test.fnGetCrntTstFn();
   SET @ndx = iif(IsNumeric(SUBSTRING(@sub_tst, 1,1))=1, 1,2);
   SET @subTstNum = SUBSTRING(@sub_tst, @ndx, 3);
   EXEC test.sp_tst_set_crnt_tst_num2 @subTstNum;    -- Just the 3 digit test number
   SET @fnHlrSt = test.fnGetCrntTstHlprFn();
   SET @msg = CONCAT(@tstRtn,'.',@subTstNum);
   DELETE FROM AppLog;

   --------------------------------------------------
   -- Validate preconditions:
   --------------------------------------------------
   EXEC sp_assert_not_null_or_empty @sub_tst;

   --------------------------------------------------
   -- Process
   --------------------------------------------------
   SET @prms_msg = IIF(@params IS NOT NULL, CONCAT('params: ', @params), '');

   PRINT test.fnGetTstHdrFooterLine(1, 1, @msg, 'starting');

   EXEC sp_log 1, @fn,@fnHlrSt, '.', @tstRtn,'.',@subTstNum,': 000: starting', @nl, @params;

   EXEC test.sp_tst_set_crnt_sub_tst            @sub_tst;
   EXEC test.sp_tst_set_crnt_tst_err_st         0;
   EXEC test.sp_tst_set_crnt_failed_tst_num     NULL;
   EXEC test.sp_tst_set_crnt_failed_tst_sub_num NULL;

   --------------------------------------------------
   -- Process complete
   --------------------------------------------------
   EXEC sp_log 1, @fn,'999: leaving';
END
/*
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [tSQLt].[TestResult](
	[Id] [int] IDENTITY(1,1) NOT NULL,
	[Class] [nvarchar](max) NOT NULL,
	[TestCase] [nvarchar](max) NOT NULL,
	[Name]  AS ((quotename([Class])+'.')+quotename([TestCase])),
	[TranName] [nvarchar](max) NULL,
	[Result] [nvarchar](max) NULL,
	[Msg] [nvarchar](max) NULL,
	[TestStartTime] [datetime2](7) NOT NULL,
	[TestEndTime] [datetime2](7) NULL,
 CONSTRAINT [PK:tSQLt.TestResult] PRIMARY KEY CLUSTERED 
(
	[Id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

ALTER TABLE [tSQLt].[TestResult] ADD  CONSTRAINT [DF:TestResult(TestStartTime)]  DEFAULT (sysdatetime()) FOR [TestStartTime]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


CREATE PROCEDURE [tSQLt].[Fail]
    @Message0 NVARCHAR(MAX) = '',
    @Message1 NVARCHAR(MAX) = '',
    @Message2 NVARCHAR(MAX) = '',
    @Message3 NVARCHAR(MAX) = '',
    @Message4 NVARCHAR(MAX) = '',
    @Message5 NVARCHAR(MAX) = '',
    @Message6 NVARCHAR(MAX) = '',
    @Message7 NVARCHAR(MAX) = '',
    @Message8 NVARCHAR(MAX) = '',
    @Message9 NVARCHAR(MAX) = ''
AS
BEGIN
   DECLARE @WarningMessage NVARCHAR(MAX);
   SET @WarningMessage = '';

   IF XACT_STATE() = -1
   BEGIN
     SET @WarningMessage = CHAR(13)+CHAR(10)+'Warning: Uncommitable transaction detected!';

     DECLARE @TranName NVARCHAR(MAX);
     SELECT @TranName = TranName
       FROM tSQLt.TestResult
      WHERE Id = (SELECT MAX(Id) FROM tSQLt.TestResult);

     DECLARE @TranCount INT;
     SET @TranCount = @@TRANCOUNT;
     ROLLBACK;
     WHILE(@TranCount>0)
     BEGIN
       BEGIN TRAN;
       SET @TranCount = @TranCount -1;
     END;
     SAVE TRAN @TranName;
   END;

   INSERT INTO #TestMessage(Msg)
   SELECT COALESCE(@Message0, '!NULL!')
        + COALESCE(@Message1, '!NULL!')
        + COALESCE(@Message2, '!NULL!')
        + COALESCE(@Message3, '!NULL!')
        + COALESCE(@Message4, '!NULL!')
        + COALESCE(@Message5, '!NULL!')
        + COALESCE(@Message6, '!NULL!')
        + COALESCE(@Message7, '!NULL!')
        + COALESCE(@Message8, '!NULL!')
        + COALESCE(@Message9, '!NULL!')
        + @WarningMessage;
        
   RAISERROR('tSQLt.Failure',16,10);
END;



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry Watts
-- Create date: 03-DEC-2024
-- Description: gets the current sub test identifier
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntSubTst]()
RETURNS VARCHAR(100)
AS
BEGIN
   RETURN CONVERT(VARCHAR(100), SESSION_CONTEXT(test.fnGetCrntSubTstKey()));
END
/*
PRINT test.fnGetCrntSubTst();
EXEC tSQLt.RunAll;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: Gets the current test helper fn name from settings
-- Key:         N'Test num'
-- Tests:       test.test 030 chkTestConfig
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstNum]()
RETURNS VARCHAR(60)
AS
BEGIN
   RETURN CONVERT(VARCHAR(60), SESSION_CONTEXT(test.fnGetCrntTstNumKey()));
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test_030_chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetCrntTstNumKey();
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE PROCEDURE [tSQLt].[AssertIsSubString]
    @a    NVARCHAR(4000)
   ,@b    NVARCHAR(4000)
   ,@msg1 NVARCHAR(2000) = NULL
   ,@msg2 NVARCHAR(2000) = NULL
   ,@msg3 NVARCHAR(2000) = NULL
   ,@msg4 NVARCHAR(2000) = NULL
AS
BEGIN
   DECLARE
    @fn        NVARCHAR(35)  = N'AssertIsSubString'
   ,@error_msg NVARCHAR(MAX)
   ,@Msg       NVARCHAR(MAX)
   ,@nl        NCHAR(2)      = NCHAR(13)+CHAR(10)
   ,@subtest   NVARCHAR(200) = test.fnGetCrntSubTst()
   PRINT N'AssertIsSubString starting';
   PRINT CONCAT(@fn, ' loglevel: ', dbo.fnGetLogLevel());
   EXEC sp_log 1, @fn, '000: starting', @nl
, '@a:[', @a, ']', @nl
, '@b:[', @b, ']';

   IF ((@a = @b) OR (@a IS NULL AND @b IS NULL) OR (CHARINDEX(@a, @b) > 0))
   BEGIN
      EXEC sp_log 1, @fn, '010: OK passed'
      RETURN 0;
   END

    -----------------------------------------------------
    -- Assertion: ERROR: a is not a substring of b
    -----------------------------------------------------
   DECLARE
    @line      NVARCHAR(100) =REPLICATE(N'*', 100)
   ,@testFn    NVARCHAR(100)
   ,@testNum   NVARCHAR(100)

   SET @testFn  = test.fnGetCrntTstFn();
   SET @testNum = test.fnGetCrntTstNum();

   SELECT @Msg = CONCAT
    (
       'Failed, Exp/Act '
       ,@NL,'<', @a,'>'
       ,@NL,'<', @b,'>'
       ,@NL
    );

   SET @msg = 
      CONCAT
      (
        test.fnGetCrntTstFn(), '.', test.fnGetCrntSubTst()
       , @msg1
       ,iif(@msg1 IS NULL, '', CONCAT(' ', @msg2))
       ,iif(@msg2 IS NULL, '', CONCAT(' ', @msg3))
       ,iif(@msg3 IS NULL, '', CONCAT(' ', @msg4))
       );

   SELECT @Msg = CONCAT
                 (
                   @nl, '@a:<', ISNULL(@a, 'NULL'), '>'
                  ,@nl, ' is not in'
                  ,@nl, '@b:<', ISNULL(@b, 'NULL'), '>'
                  ,@nl
                 );

--*********************************************************************************************
   PRINT CONCAT( @NL, @line);
   EXEC sp_log 4, @fn,'**** ', @testFn, '.', @testNum, '.', @subtest, '. failed ****', @Msg;
   PRINT CONCAT( @line, @NL);
--*********************************************************************************************

    EXEC tSQLt.Fail '**** ', @testFn, '.', @testNum, '.', @subtest, '. failed ****', @Msg;
END;

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================================================
-- Author:      Terry Watts
-- Create date: 20-NOV-2024
-- Description: Gets the current tst_num2 from the session context
--              This is the 3 digit int number only part of the sub test identifier
-- Key:         N'Test num'
-- Tests:       test.test 030 chkTestConfig
-- =================================================================================
CREATE FUNCTION [test].[fnGetCrntTstNum2]()
RETURNS VARCHAR(3)
AS
BEGIN
   RETURN CONVERT(VARCHAR(3), SESSION_CONTEXT(test.fnGetCrntTstNum2Key()));
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test_030_chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetCrntTstNumKey();
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ================================================
-- Author:      Terry Watts
-- Create date: 13-FEB-2021
-- Description: handles test failure
--
-- TESTS:
-- ================================================
CREATE PROCEDURE [test].[sp_tst_hlpr_hndl_failure]
 @msg1 VARCHAR(2000) = NULL
,@msg2 VARCHAR(2000) = NULL
,@msg3 VARCHAR(2000) = NULL
,@msg4 VARCHAR(2000) = NULL
AS
BEGIN
   DECLARE
      @fn       VARCHAR(35) = 'sp_tst_hlpr_hndl_failure'
     ,@tst_num2 VARCHAR(6) = test.fnGetCrntTstNum2()
     ,@msg      VARCHAR(500)
   ;

   SET NOCOUNT ON;
   -- Display applog up and down
   EXEC sp_log 0, @fn, '000: starting';
   EXEC sp_appLog_display;-- 0;
   --EXEC sp_appLog_display 1;

   SET @msg = 
      CONCAT
      (
        test.fnGetCrntTstFn(), '.', test.fnGetCrntSubTst()
       , @msg1
       ,iif(@msg1 IS NULL, '', CONCAT(' ', @msg2))
       ,iif(@msg2 IS NULL, '', CONCAT(' ', @msg3))
       ,iif(@msg3 IS NULL, '', CONCAT(' ', @msg4))
       );

   PRINT test.fnGetTstHdrFooterLine(1, 0, @msg, 'failed');
   EXEC sp_log 1, @fn, '900: leaving';
END
/*
EXEC tSQLt.Run 'test.test_013_sp_pop_AttendanceDates';

EXEC [test].[sp_tst_hlpr_st] 'MyFn', 'T010: MyFn'
EXEC test.sp_tst_hlpr_hndl_failure
PRINT test.fnGetCrntTstFn()
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry
-- Create date: 06-FEB-2021
-- Description: Gets the failed test number  from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetTstPassCnt]()
RETURNS INT
AS
BEGIN
   DECLARE @cnt INT;
   SET @cnt = CONVERT(INT, SESSION_CONTEXT(test.[fnGetTstPassCntKey]()));

   IF @cnt IS NULL  -- handle null as we are incrmenting this
      SET @cnt = 0;

   RETURN @cnt
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO



-- =============================================
-- Author:      Terry Watts
-- Create date: 06-FEB-2021
-- Description: Setter, clears the test pass count
-- Tests: [test].[test 030 chkTestConfig]
-- Returns: the cremented test count
-- =============================================
CREATE PROCEDURE [test].[sp_tst_incr_pass_cnt]
AS
BEGIN
   DECLARE @key NVARCHAR(60)
         , @cnt INT;

   SET @key = test.fnGetTstPassCntKey();
   SET @cnt = test.fnGetTstPassCnt() + 1;

   EXEC sp_set_session_context @key, @cnt;
   RETURN @cnt;
END



GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =========================================================================
-- Author:      Terry Watts
-- Create date: 13-FEB-2021
-- Description: handles test success 
--                increments the test passed counter, logs (force) msg
--
-- CALLED BY:   sp_tst_gen_chk
-- TESTS:       hlpr_015_fnGetErrorMsg
-- =========================================================================
CREATE PROCEDURE [test].[sp_tst_hlpr_hndl_success]
AS
BEGIN
   DECLARE
       @fn            VARCHAR(35)   = N'sp_tst_hlpr_hndl_success'
      ,@test_pass_cnt INT
      ,@msg           VARCHAR(500)
   ;

 -- Passed so increment the test count
   EXEC @test_pass_cnt = test.sp_tst_incr_pass_cnt;
   SET @msg = CONCAT(test.fnGetCrntTstFn(), '.', test.fnGetCrntTstNum2());

   PRINT test.fnGetTstHdrFooterLine(0, 0, @msg, 'passed');
END
/*
*/



GO
