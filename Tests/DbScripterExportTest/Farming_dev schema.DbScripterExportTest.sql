/*
Parameters:

--------------------------------------------------------------------------------
 Type            : Params
--------------------------------------------------------------------------------
 CreateMode      : Create
 Database        : Farming_dev
 DisplayLog      : True
 DisplayScript   : True
 IndividualFiles              : False
 Instance                     : 
 IsExprtngData                : False
 LogFile                      : D:\Logs\Farming.log
 LogLevel                     : Info
 Name                         : AppSettings.01
 RequiredAssemblies           : System.Collections.Generic.List`1[System.String]
 RequiredSchemas              : System.Collections.Generic.List`1[System.String]
 RequiredFunctions            : System.Collections.Generic.List`1[System.String]
 RequiredProcedures           : System.Collections.Generic.List`1[System.String]
 RequiredTables               : System.Collections.Generic.List`1[System.String]
 RequiredViews                : System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedTypes     : System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedDataTypes : System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedTableTypes: System.Collections.Generic.List`1[System.String]
 Want All:                  : Assembly
 Want All:                  : Database
 Want All:                  : Function
 Want All:                  : Procedure
 Want All:                  : Schema
 Want All:                  : Table
 Want All:                  : View
 Want All:                  : UserDefinedType
 Want All:                  : UserDefinedDataType
 Want All:                  : UserDefinedTableType
 Script Dir                   : D:\Dev\DbScripter\Tests\DbScripterExportTest
 Script File                  : D:\Dev\DbScripter\Tests\DbScripterExportTest\Farming_dev schema.DbScripterExportTest.sql
 ScriptUseDb                  : True
 Server                       : DevI9
 AddTimestamp                 : False
 Timestamp                    : 250720-0902

 RequiredSchemas : 2
	dbo
	test

*/

USE [Farming_dev]
GO

CREATE ASSEMBLY [RegEx]
FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C010300B1C625930000000000000000E00022200B0130000022000000080000000000007E40000000200000006000000000001000200000000200000400000000000000060000000000000000A0000000020000000000000300608500001000001000000000100000100000000000001000000000000000000000002A4000004F000000006000001C04000000000000000000000000000000000000008000000C000000883F0000380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E7465787400000084200000002000000022000000020000000000000000000000000000200000602E727372630000001C040000006000000006000000240000000000000000000000000000400000402E72656C6F6300000C0000000080000000020000002A000000000000000000000000000040000042000000000000000000000000000000005E400000000000004800000002000500242900006416000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001330020065000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1300000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281400000A281500000A2A000000133004007F000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1300000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281900000A281500000A2A00133002006A000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1A00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A6F1C00000A281D00000A2A00001330040084000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1A00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281E00000A6F1C00000A281D00000A2A133002006A000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A282000000A6F2100000A282200000A2A00001330040084000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001282300000A6F2100000A282200000A2A133003008F000000000000000F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A0F02FE16140000016F1100000A282400000A282200000A2A0013300500A9000000000000000F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A0F02FE16140000016F1100000AD01F000001281600000A05281700000A281800000AA51F000001282500000A282200000A2A0000001B3004001B010000010000110F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A0A066F1C00000A163E8C000000066F1C00000A8D1E0000010B160C066F2600000A13042B1C11046F2700000A7419000001130507082517580C11056F2100000AA211046F2800000A2DDBDE151104751A000001130611062C0711066F2900000ADC000F02FE16140000016F1100000A0713071107282A00000A0DDE161308720100007011086F2B00000A282C00000A0DDE0009282200000A2A7E1F00000A2A00011C000002009F0029C80015000000000000DE001AF800161B0000011B30040035010000020000110F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A05281700000A281800000AA51F000001281E00000A0A066F1C00000A163E8C000000066F1C00000A8D1E0000010B160D066F2600000A13042B1C11046F2700000A7419000001130507092517580D11056F2100000AA211046F2800000A2DDBDE151104751A000001130611062C0711066F2900000ADC000F02FE16140000016F1100000A0713071107282A00000A0CDE161308720100007011086F2B00000A282C00000A0CDE0008282200000A2A7E1F00000A2A000000011C00000200B90029E20015000000000000F8001A1201161B000001133002008A0000000000000002282D00000A2D03162B011703282D00000A2D03162B01186004282D00000A2D03162B011A6005282D00000A2D03162B011E600E04282D00000A2D03162B021F10600E05282D00000A2D03162B021F20600E06282D00000A2D03162B021F40600E07282D00000A2D03162B052000010000600E08282D00000A2D03162B05200002000060281D00000A2A0000133002005C000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D02142A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A2A1330040076000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D02142A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281E00000A2A0000133002003C000000030000110274190000010A03066F2E00000A281D00000A811600000104066F2F00000A281D00000A811600000105066F2100000A282200000A733000000A512A42534A4201000100000000000C00000076342E302E33303331390000000005006C00000034050000237E0000A0050000A805000023537472696E677300000000480B00001C00000023555300640B0000100000002347554944000000740B0000F00A000023426C6F620000000000000002000001471502000900000000FA0133001600000100000023000000020000000E0000002F000000300000001B0000000300000001000000030000000000EA020100000000000600DA01B70306004702B7030600F90085030F00D70300000600210116030600BD01160306008901160306002E0216030600FA01160306001302160306003801160306000D0198030600EB00980306006C01160306005301770206008304FF020A00A8014A030A0031004A030A000B03EE030A009102EE030E00A10503040A000100EE030E00280303040600650322040E00B802030406007E00FF0206003803FF020600720022040A005D04EE0306009D02FF020E00430403040600C300FF0206008A00FF0206000603FF020E00D0000304000000000A00000000000100010081011000A10500004100010001005020000000009600B002EF000100C4200000000096001505F80003005021000000009600D70403010600C8210000000096004C050C0108005822000000009600A40217010B00D022000000009600050520010D00602300000000960040002B011000FC23000000009600F30436011300B4240000000096006D042B011700F8250000000096003B0536011A005827000000009600350443011E00F027000000009600DA025A0127005828000000009600270563012900DC2800000000960083056E012C00000001006D05000002004203000001006D05000002004203000003005004000001006D05000002004203000001006D05000002004203000003004304000001006D05000002004203000001006D05000002004203000003004304000001006D0500000200420300000300BF04000001006D0500000200420300000300BF04000004004304000001006D05000002004203000003007A04000001006D0500000200420300000300730500000400430400000100D80000000200B90000000300C80000000400280000000500AE00000006004E00000007008A0400000800620500000900AE04000001006D05000002004203000001006D0500000200420300000300430400000100D602020002009B0502000300CF0202000400BE0209007F03010011007F03060019007F030A0029007F03100031007F03100039007F03100041007F03100049007F03100051007F03100059007F03100061007F03150069007F03100071007F03100079007F03100089007F030600A100F4021A0081009B021E00F100C40222009900FA022600A900B6022A0099009604300001019C003600B100A2043F00110181044500A900B6024D00B100FA025500A900E6035900B900E9042200B10096046000A900E6036600A100FA026F00A900B8027300190165021E00A10096047A00A900B8028000A90046008900A90046009000B9007103AC00C100CB04B100C1007A051A00D100E3000600F1007304B500D90066001E00F1006604BC0099006F02D5001901910522001901C4022200E9007F03E00020007B00C4022E000B007C012E00130085012E001B00A4012E002300AD012E002B00BB012E003300F3012E003B00F9012E004300AD012E004B0014022E005300F3012E005B00F3012E0063003F022E006B0069022E007300760240007B007D0360007B003A0480007B00F704A0007B00B805C0007B006F06E0007B002A0700017B00E30720017B00A00840017B00580960017B00140A80017B00CD0AA0017B00CD0A9900C200DB000480000001000000000000000000000000008B050000040000000000000000000000E6001F0000000000040000000000000000000000E600130000000000040000000000000000000000E600FF0200000000000000000053716C496E743332003C4D6F64756C653E0053797374656D2E44617461006D73636F726C696200436F6D70696C656400446174614163636573734B696E640052656765785F5265706C6163650049676E6F72655061747465726E57686974657370616365006765745F4D6573736167650049456E756D657261626C650049446973706F7361626C650052756E74696D655479706548616E646C65004765745479706546726F6D48616E646C650053696E676C654C696E65004D756C74694C696E650054797065004578706C69636974436170747572650049676E6F72654361736500446973706F736500477569644174747269627574650044656275676761626C6541747472696275746500436F6D56697369626C6541747472696275746500417373656D626C795469746C6541747472696275746500417373656D626C7954726164656D61726B417474726962757465005461726765744672616D65776F726B41747472696275746500417373656D626C7946696C6556657273696F6E41747472696275746500417373656D626C79436F6E66696775726174696F6E4174747269627574650053716C46756E6374696F6E41747472696275746500417373656D626C794465736372697074696F6E41747472696275746500436F6D70696C6174696F6E52656C61786174696F6E7341747472696275746500417373656D626C7950726F6475637441747472696275746500417373656D626C79436F7079726967687441747472696275746500417373656D626C79436F6D70616E794174747269627574650052756E74696D65436F6D7061746962696C697479417474726962757465006765745F56616C7565006F705F547275650053797374656D2E52756E74696D652E56657273696F6E696E670053716C537472696E6700546F537472696E670052656765785F4D617463680052656765785F49734D61746368006D61746368006765745F4C656E677468006C656E677468006F626A0052656765785F4D617463685F416C6C0052656745782E646C6C006765745F49734E756C6C0053797374656D00456E756D0053716C426F6F6C65616E0053797374656D2E5265666C656374696F6E004D61746368436F6C6C656374696F6E00457863657074696F6E007061747465726E004D6963726F736F66742E53716C5365727665722E5365727665720049456E756D657261746F7200476574456E756D657261746F72002E63746F720053797374656D2E446961676E6F73746963730053797374656D2E52756E74696D652E496E7465726F7053657276696365730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F646573004D6174636865730053797374656D2E446174612E53716C54797065730053797374656D2E546578742E526567756C617245787072657373696F6E730053797374656D2E436F6C6C656374696F6E730052656765785F4F7074696F6E730052656765784F7074696F6E730072656765784F7074696F6E730053716C436861727300436F6E6361740052656765785F466F726D617400666F726D617400546F4F626A656374005269676874546F4C656674006F705F496D706C69636974006F705F4578706C696369740043756C74757265496E76617269616E74007265706C6163656D656E74006765745F43757272656E740052656765785F4D617463685F436F756E74006765745F436F756E740052656765785F5265706C6163655F4F70740052656765785F4D617463685F4F70740052656765785F49734D617463685F4F70740052656765785F4D617463685F416C6C5F4F70740052656765785F466F726D61745F4F70740052656765785F4D617463685F436F756E745F4F70740045434D4153637269707400696E707574006F7574707574004D6F76654E6578740046696C6C526F77005265674578006765745F496E64657800696E6465780052656765780000001745007800630065007000740069006F006E003A00200000000000CA0849E65B60614FBB66A50C49F81C3400042001010803200001052001011111042001010E0420010102032000020320000E032000080306114D050002020E0E050001114D020800011280811180850500010811590700021C12808108070003020E0E117D03061159060002125D0E0E050001115908080003125D0E0E117D0306115106000212650E0E05000111510E08000312650E0E117D0600030E0E0E0E0800040E0E0E0E117D120709125D1D0E080E1261126512691D1C126D04200012610320001C0600020E0E1D1C0500020E0E0E120709125D1D0E0E081261126512691D1C126D05000102114D040701126505200101115108B77A5C561934E089080002114D115111510A0003114D1151115111590800021159115111510A000311591151115111590800021151115111510A000311511151115111590A000311511151115111510C0004115111511151115111591600091159114D114D114D114D114D114D114D114D114D0800021271115111510A000312711151115111590D0004011C1011591011591012750801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F7773010801000200000000000D01000853514C5265676578000037010032526567756C61722045787072657373696F6E732073616D706C6520617373656D626C7920666F722053514C2053657276657200000501000000001A0100154D6963726F736F667420436F72706F726174696F6E00002A010025436F7079726967687420C2A92032303232204D6963726F736F667420436F72706F7261746500002901002439316233393038372D636434382D343633622D613838632D63346566323038303464623400000C010007312E302E302E3000004D01001C2E4E45544672616D65776F726B2C56657273696F6E3D76342E372E320100540E144672616D65776F726B446973706C61794E616D65142E4E4554204672616D65776F726B20342E372E3280B701000300540E044E616D650D52656765785F49734D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F49734D617463685F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F4D617463685F436F756E745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BF01000300540E044E616D651552656765785F4D617463685F436F756E745F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B501000300540E044E616D650B52656765785F4D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B901000300540E044E616D650F52656765785F4D617463685F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B701000300540E044E616D650D52656765785F5265706C6163655455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F5265706C6163655F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B601000300540E044E616D650C52656765785F466F726D61745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BA01000300540E044E616D651052656765785F466F726D61745F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B701000300540E044E616D650D52656765785F4F7074696F6E735455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E6973746963002001000100540E1146696C6C526F774D6574686F644E616D650746696C6C526F770000000000004A84A98800000000020000006A000000C03F0000C02100000000000000000000000000001000000000000000000000000000000052534453AC0D2DF91B817E4284EDEAC96F1DA1BE01000000443A5C4465765C53514C5F434C525C53514C5F434C525F362E305F646F6E745F776F726B5F696E5F73716C5F7365727665725C53716C52656745785C6F626A5C52656C656173655C52656745782E706462005240000000000000000000006C4000000020000000000000000000000000000000000000000000005E400000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C00000000000000FF2500200010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058600000C00300000000000000000000C00334000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE00000100000001000000000000000100000000003F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B00420030000010053007400720069006E006700460069006C00650049006E0066006F000000FC02000001003000300030003000300034006200300000007E003300010043006F006D006D0065006E0074007300000052006500670075006C00610072002000450078007000720065007300730069006F006E0073002000730061006D0070006C006500200061007300730065006D0062006C007900200066006F0072002000530051004C002000530065007200760065007200000000004C001600010043006F006D00700061006E0079004E0061006D006500000000004D006900630072006F0073006F0066007400200043006F00720070006F0072006100740069006F006E0000003A0009000100460069006C0065004400650073006300720069007000740069006F006E0000000000530051004C005200650067006500780000000000300008000100460069006C006500560065007200730069006F006E000000000031002E0030002E0030002E003000000034000A00010049006E007400650072006E0061006C004E0061006D0065000000520065006700450078002E0064006C006C0000006E00250001004C006500670061006C0043006F007000790072006900670068007400000043006F0070007900720069006700680074002000A9002000320030003200320020004D006900630072006F0073006F0066007400200043006F00720070006F007200610074006500000000002A00010001004C006500670061006C00540072006100640065006D00610072006B00730000000000000000003C000A0001004F0072006900670069006E0061006C00460069006C0065006E0061006D0065000000520065006700450078002E0064006C006C000000320009000100500072006F0064007500630074004E0061006D00650000000000530051004C005200650067006500780000000000340008000100500072006F006400750063007400560065007200730069006F006E00000031002E0030002E0030002E003000000038000800010041007300730065006D0062006C0079002000560065007200730069006F006E00000031002E0030002E0030002E00300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000C000000803000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
WITH PERMISSION_SET = SAFE

GO
GO

CREATE ASSEMBLY [SQLRegEx]
FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C010300E24A0DF80000000000000000E00022200B013000002200000008000000000000AE40000000200000006000000000001000200000000200000400000000000000060000000000000000A000000002000000000000030060850000100000100000000010000010000000000000100000000000000000000000594000004F000000006000005C04000000000000000000000000000000000000008000000C000000A83F0000380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E74657874000000B4200000002000000022000000020000000000000000000000000000200000602E727372630000005C040000006000000006000000240000000000000000000000000000400000402E72656C6F6300000C0000000080000000020000002A000000000000000000000000000040000042000000000000000000000000000000008D400000000000004800000002000500242900008416000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001330020065000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1300000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281400000A281500000A2A000000133004007F000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1300000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281900000A281500000A2A00133002006A000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1A00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A6F1C00000A281D00000A2A00001330040084000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1A00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281E00000A6F1C00000A281D00000A2A133002006A000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A282000000A6F2100000A282200000A2A00001330040084000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001282300000A6F2100000A282200000A2A133003008F000000000000000F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A0F02FE16140000016F1100000A282400000A282200000A2A0013300500A9000000000000000F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A0F02FE16140000016F1100000AD01F000001281600000A05281700000A281800000AA51F000001282500000A282200000A2A0000001B3004001B010000010000110F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A0A066F1C00000A163E8C000000066F1C00000A8D1E0000010B160C066F2600000A13042B1C11046F2700000A7419000001130507082517580C11056F2100000AA211046F2800000A2DDBDE151104751A000001130611062C0711066F2900000ADC000F02FE16140000016F1100000A0713071107282A00000A0DDE161308720100007011086F2B00000A282C00000A0DDE0009282200000A2A7E1F00000A2A00011C000002009F0029C80015000000000000DE001AF800161B0000011B30040035010000020000110F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A05281700000A281800000AA51F000001281E00000A0A066F1C00000A163E8C000000066F1C00000A8D1E0000010B160D066F2600000A13042B1C11046F2700000A7419000001130507092517580D11056F2100000AA211046F2800000A2DDBDE151104751A000001130611062C0711066F2900000ADC000F02FE16140000016F1100000A0713071107282A00000A0CDE161308720100007011086F2B00000A282C00000A0CDE0008282200000A2A7E1F00000A2A000000011C00000200B90029E20015000000000000F8001A1201161B000001133002008A0000000000000002282D00000A2D03162B011703282D00000A2D03162B01186004282D00000A2D03162B011A6005282D00000A2D03162B011E600E04282D00000A2D03162B021F10600E05282D00000A2D03162B021F20600E06282D00000A2D03162B021F40600E07282D00000A2D03162B052000010000600E08282D00000A2D03162B05200002000060281D00000A2A0000133002005C000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D02142A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A2A1330040076000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D02142A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281E00000A2A0000133002003C000000030000110274190000010A03066F2E00000A281D00000A811600000104066F2F00000A281D00000A811600000105066F2100000A282200000A733000000A512A42534A4201000100000000000C00000076342E302E33303331390000000005006C00000034050000237E0000A0050000C805000023537472696E677300000000680B00001C00000023555300840B0000100000002347554944000000940B0000F00A000023426C6F620000000000000002000001471502000900000000FA0133001600000100000023000000020000000E0000002F000000300000001B0000000300000001000000030000000000EA020100000000000600DA01C60306004702C6030600F90094030F00E60300000600210125030600BD01250306008901250306002E0225030600FA01250306001302250306003801250306000D01A7030600EB00A70306006C0125030600530177020600A7040E030A00A80159030A00310059030A001A03FD030A009102FD030E00BF0512040A000100FD030E00370312040600740331040E00B802120406007E000E03060047030E030600720031040A008104FD0306009D020E030E00670412040600C3000E0306008A000E03060015030E030E00D0001204000000000A00000000000100010081011000BF0500004100010001005020000000009600B002EF000100C4200000000096003905F80003005021000000009600FB0403010600C82100000000960070050C0108005822000000009600A40217010B00D022000000009600290520010D00602300000000960040002B011000FC23000000009600170536011300B42400000000960091042B011700F8250000000096005F0536011A005827000000009600590443011E00F027000000009600DA025A01270058280000000096004B0563012900DC28000000009600A7056E012C0000000100910500000200510300000100910500000200510300000300740400000100910500000200510300000100910500000200510300000300670400000100910500000200510300000100910500000200510300000300670400000100910500000200510300000300E30400000100910500000200510300000300E304000004006704000001009105000002005103000003009E0400000100910500000200510300000300970500000400670400000100D80000000200B90000000300C80000000400280000000500AE00000006004E0000000700AE0400000800860500000900D20400000100910500000200510300000100910500000200510300000300670400000100D60202000200B90502000300CF0202000400BE0209008E03010011008E03060019008E030A0029008E03100031008E03100039008E03100041008E03100049008E03100051008E03100059008E03100061008E03150069008E03100071008E03100079008E03100089008E030600A10003031A0081009B021E00F100C4022200990009032600A900B6022A009900BA04300001019C003600B100C6043F001101A5044500A900B6024D00B10009035500A900F5035900B9000D052200B100BA046000A900F5036600A10009036F00A900B8027300190165021E00A100BA047A00A900B8028000A90046008900A90046009000B9008003AC00C100EF04B100C1009E051A00D100E3000600F1009704B500D90066001E00F1008A04BC0099006F02D5001901AF0522001901C4022200E9008E03E00020007B00C4022E000B007C012E00130085012E001B00A4012E002300AD012E002B00BB012E003300F3012E003B00F9012E004300AD012E004B0014022E005300F3012E005B00F3012E0063003F022E006B0069022E007300760240007B007D0360007B003A0480007B00F704A0007B00B805C0007B006F06E0007B002A0700017B00E30720017B00A00840017B00580960017B00140A80017B00CD0AA0017B00CD0A9900C200DB0004800000010000000000000000000000000044040000040000000000000000000000E6001F0000000000040000000000000000000000E600130000000000040000000000000000000000E6000E0300000000000000000053716C496E743332003C4D6F64756C653E0053797374656D2E44617461006D73636F726C696200436F6D70696C656400446174614163636573734B696E640052656765785F5265706C6163650049676E6F72655061747465726E57686974657370616365006765745F4D6573736167650049456E756D657261626C650049446973706F7361626C650052756E74696D655479706548616E646C65004765745479706546726F6D48616E646C650053696E676C654C696E65004D756C74694C696E650054797065004578706C69636974436170747572650049676E6F72654361736500446973706F736500477569644174747269627574650044656275676761626C6541747472696275746500436F6D56697369626C6541747472696275746500417373656D626C795469746C6541747472696275746500417373656D626C7954726164656D61726B417474726962757465005461726765744672616D65776F726B41747472696275746500417373656D626C7946696C6556657273696F6E41747472696275746500417373656D626C79436F6E66696775726174696F6E4174747269627574650053716C46756E6374696F6E41747472696275746500417373656D626C794465736372697074696F6E41747472696275746500436F6D70696C6174696F6E52656C61786174696F6E7341747472696275746500417373656D626C7950726F6475637441747472696275746500417373656D626C79436F7079726967687441747472696275746500417373656D626C79436F6D70616E794174747269627574650052756E74696D65436F6D7061746962696C697479417474726962757465006765745F56616C7565006F705F547275650053797374656D2E52756E74696D652E56657273696F6E696E670053716C537472696E6700546F537472696E670052656765785F4D617463680052656765785F49734D61746368006D61746368006765745F4C656E677468006C656E677468006F626A0052656765785F4D617463685F416C6C0053514C45787465726E616C46756E6374696F6E732E646C6C006765745F49734E756C6C0053797374656D00456E756D0053716C426F6F6C65616E0053797374656D2E5265666C656374696F6E004D61746368436F6C6C656374696F6E00457863657074696F6E007061747465726E004D6963726F736F66742E53716C5365727665722E5365727665720049456E756D657261746F7200476574456E756D657261746F72002E63746F720053797374656D2E446961676E6F73746963730053797374656D2E52756E74696D652E496E7465726F7053657276696365730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F646573004D6174636865730053797374656D2E446174612E53716C54797065730053797374656D2E546578742E526567756C617245787072657373696F6E730053797374656D2E436F6C6C656374696F6E730053514C45787465726E616C46756E6374696F6E730052656765785F4F7074696F6E730052656765784F7074696F6E730072656765784F7074696F6E730053716C436861727300436F6E6361740052656765785F466F726D617400666F726D617400546F4F626A656374005269676874546F4C656674006F705F496D706C69636974006F705F4578706C696369740043756C74757265496E76617269616E74007265706C6163656D656E74006765745F43757272656E740052656765785F4D617463685F436F756E74006765745F436F756E740052656765785F5265706C6163655F4F70740052656765785F4D617463685F4F70740052656765785F49734D617463685F4F70740052656765785F4D617463685F416C6C5F4F70740052656765785F466F726D61745F4F70740052656765785F4D617463685F436F756E745F4F70740045434D4153637269707400696E707574006F7574707574004D6F76654E6578740046696C6C526F77006765745F496E64657800696E64657800526567657800000000001745007800630065007000740069006F006E003A002000000000006F51D52F0353AC43AFA2D60BC6B80D6E00042001010803200001052001011111042001010E0420010102032000020320000E032000080306114D050002020E0E050001114D020800011280811180850500010811590700021C12808108070003020E0E117D03061159060002125D0E0E050001115908080003125D0E0E117D0306115106000212650E0E05000111510E08000312650E0E117D0600030E0E0E0E0800040E0E0E0E117D120709125D1D0E080E1261126512691D1C126D04200012610320001C0600020E0E1D1C0500020E0E0E120709125D1D0E0E081261126512691D1C126D05000102114D040701126505200101115108B77A5C561934E089080002114D115111510A0003114D1151115111590800021159115111510A000311591151115111590800021151115111510A000311511151115111590A000311511151115111510C0004115111511151115111591600091159114D114D114D114D114D114D114D114D114D0800021271115111510A000312711151115111590D0004011C1011591011591012750801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F7773010801000200000000000D01000853514C5265676578000037010032526567756C61722045787072657373696F6E732073616D706C6520617373656D626C7920666F722053514C2053657276657200000501000000001A0100154D6963726F736F667420436F72706F726174696F6E00002A010025436F7079726967687420C2A92032303232204D6963726F736F667420436F72706F7261746500002901002439316233393038372D636434382D343633622D613838632D63346566323038303464623400000C010007312E302E302E3000004D01001C2E4E45544672616D65776F726B2C56657273696F6E3D76342E372E320100540E144672616D65776F726B446973706C61794E616D65142E4E4554204672616D65776F726B20342E372E3280B701000300540E044E616D650D52656765785F49734D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F49734D617463685F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F4D617463685F436F756E745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BF01000300540E044E616D651552656765785F4D617463685F436F756E745F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B501000300540E044E616D650B52656765785F4D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B901000300540E044E616D650F52656765785F4D617463685F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B701000300540E044E616D650D52656765785F5265706C6163655455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F5265706C6163655F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B601000300540E044E616D650C52656765785F466F726D61745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BA01000300540E044E616D651052656765785F466F726D61745F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B701000300540E044E616D650D52656765785F4F7074696F6E735455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E6973746963002001000100540E1146696C6C526F774D6574686F644E616D650746696C6C526F770000000000004A84A988000000000200000079000000E03F0000E02100000000000000000000000000001000000000000000000000000000000052534453AC0D2DF91B817E4284EDEAC96F1DA1BE01000000443A5C4465765C53514C5F434C525C53514C5F434C525F362E305F646F6E745F776F726B5F696E5F73716C5F7365727665725C53716C52656745785C6F626A5C52656C656173655C53514C45787465726E616C46756E6374696F6E732E706462008140000000000000000000009B4000000020000000000000000000000000000000000000000000008D400000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C0000000000000000FF2500200010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058600000000400000000000000000000000434000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE00000100000001000000000000000100000000003F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B00460030000010053007400720069006E006700460069006C00650049006E0066006F0000003C03000001003000300030003000300034006200300000007E003300010043006F006D006D0065006E0074007300000052006500670075006C00610072002000450078007000720065007300730069006F006E0073002000730061006D0070006C006500200061007300730065006D0062006C007900200066006F0072002000530051004C002000530065007200760065007200000000004C001600010043006F006D00700061006E0079004E0061006D006500000000004D006900630072006F0073006F0066007400200043006F00720070006F0072006100740069006F006E0000003A0009000100460069006C0065004400650073006300720069007000740069006F006E0000000000530051004C005200650067006500780000000000300008000100460069006C006500560065007200730069006F006E000000000031002E0030002E0030002E003000000052001900010049006E007400650072006E0061006C004E0061006D0065000000530051004C00450078007400650072006E0061006C00460075006E006300740069006F006E0073002E0064006C006C00000000006E00250001004C006500670061006C0043006F007000790072006900670068007400000043006F0070007900720069006700680074002000A9002000320030003200320020004D006900630072006F0073006F0066007400200043006F00720070006F007200610074006500000000002A00010001004C006500670061006C00540072006100640065006D00610072006B00730000000000000000005A00190001004F0072006900670069006E0061006C00460069006C0065006E0061006D0065000000530051004C00450078007400650072006E0061006C00460075006E006300740069006F006E0073002E0064006C006C0000000000320009000100500072006F0064007500630074004E0061006D00650000000000530051004C005200650067006500780000000000340008000100500072006F006400750063007400560065007200730069006F006E00000031002E0030002E0030002E003000000038000800010041007300730065006D0062006C0079002000560065007200730069006F006E00000031002E0030002E0030002E003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000C000000B03000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
WITH PERMISSION_SET = SAFE

GO
GO

CREATE ASSEMBLY [tSQLtCLR]
FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C01030095AB0D620000000000000000E00022200B013000004A000000080000000000006A69000000200000008000000000001000200000000200000400000000000000040000000000000000C0000000020000FEC60000030040850000100000100000000010000010000000000000100000000000000000000000186900004F000000008000001C0400000000000000000000000000000000000000A000000C000000E06700001C0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E746578740000007049000000200000004A000000020000000000000000000000000000200000602E727372630000001C0400000080000000060000004C0000000000000000000000000000400000402E72656C6F6300000C00000000A00000000200000052000000000000000000000000000040000042000000000000000000000000000000004C6900000000000048000000020005005C3400000433000009000000000000000000000000000000606700008000000000000000000000000000000000000000000000000000000000000000000000001E02281200000A2A133004005400000001000011731300000A0A160B022803000006731400000A0C7201000070731500000A13042B261104096F1600000A2C1C0717580B0607096F1700000A186F1800000A281900000A6F1A00000A086F1B00000A250D2DD0062A5E0F00281C00000A2D080F00281D00000A2A72210000702A13300200270000000200001102A50200001B0A031200281E00000A281F00000A8118000001041200282000000A81140000012A001B3003006500000003000011140A18732100000A0B2806000006732200000A0A066F2300000A732400000A25066F2500000A250F01FE16140000016F2600000A6F2700000A6F2800000A26DE0A072C06076F2900000ADCDE170C722300007008730A0000067A062C06066F2A00000ADC2A00000001280000020009003841000A00000000000002004B4D000D1C00000102000200585A000A000000001330040046000000040000117344000006256F490000060A6F4A0000060B732B00000A2572D8000070066F2C00000A2572F0000070178C4A0000016F2C00000A257218010070076F2C00000A6F2D00000A2A1E02282E00000A2A220203282F00000A2A26020304283000000A2A26020304283100000A2A3A02281200000A02037D010000042A7A0203280F000006027B01000004027B010000046F460000066F4F0000062A220203280F0000062A4A027B01000004036F4B0000066F3200000A2A6A283300000A6F3400000A6F3500000A6F2600000A281900000A2A56283300000A6F3400000A6F3600000A283700000A2A00001330040032000000050000117238010070283800000A0A1200FE16270000016F2600000A725C01007072210000706F3900000A283A00000A281900000A2A00001B3005001A020000060000110F00281C00000A2C0B7260010070732F00000A7A0F01281C00000A2C0C7221000070281900000A10010F02281C00000A2C0C7221000070281900000A100273440000060F000F0128190000060A06281900000A6F4B00000604281A0000060B160C07166F3B00000A8E698D4F0000010D076F3C00000A13072B371207283D00000A13081613092B1D09110909110994110811099A6F3E00000A283F00000A9E110917581309110911088E6932DB0817580C1207284000000A2DC0DE0E1207FE160400001B6F2900000ADC16130A2B1809110A09110A94209B000000284100000A9E110A1758130A110A098E6932E116130409130B16130C2B16110B110C94130D110417110D58581304110C1758130C110C110B8E6932E211041758130411040817585A13041713051104734200000A1306076F3C00000A130738AE0000001207283D00000A130E11052D0811066F4300000A2616130F2B2B110672960100706F4400000A110E110F9A281800000609110F9428170000066F4400000A26110F1758130F110F110E8E6932CD110672960100706F4400000A2611052C5016130511066F4300000A261613102B2B1106729A0100706F4400000A26110611066F4500000A725C010070091110946F4600000A261110175813101110110E8E6932CD1106729A0100706F4400000A261207284000000A3A46FFFFFFDE0E1207FE160400001B6F2900000ADC11066F2600000A281900000A734700000A2A0000011C00000200780044BC000E0000000002003901C1FA010E000000001330050035000000070000110228160000060A729E010070731500000A0F00FE16140000016F2600000A720202007017066F4800000A281900000A734700000A2A327E04000004026F4900000A2A000013300200FA000000080000110F00FE16140000016F2600000A6F4A00000A0A150B160C160D16130438C900000008450600000005000000330000003F00000053000000760000008C00000038A00000000611049328150000063A92000000061104931F2D3307170C3883000000061104931F2F3304190C2B7711040B2B72061104931F2D336A180C2B66061104931F0D2E08061104931F0A3356160C2B52061104931F2A33081A0C0917580D2B42091631041A0C2B3A7220020070732F00000A7A061104931F2A33021B0C061104931F2F331D190C2B19061104931F2F330F0917590D092D04160C2B061A0C2B021A0C1104175813041104068E692F0707163F29FFFFFF072A9202734B00000A16723A02007003026F3E00000A59284600000A6F2600000A283A00000A2AD2026F3E00000A209B000000312502161F4B6F4C00000A723E02007002026F3E00000A1F4B591F4B6F4C00000A284D00000A2A022A133003004500000009000011724A02007002FE16140000016F2600000A283A00000A0A03FE16140000016F2600000A6F3E00000A16311806726802007003FE16140000016F2600000A284D00000A0A062A00000013300400860200000A000011026F4E00000A0A734F00000A0B066F5000000A6F5100000A0C0F01FE16140000016F2600000A72210000706F5200000A2C47088D420000010D1613042B2A066F5000000A11046F5300000A13050911041105727E0200706F5400000A6F2600000AA211041758130411040832D107096F5500000A38000200000F01281B000006735600000A130613071613082B2E110711089A130911096F3E00000A2C18110611097294020070729A0200706F3900000A6F5700000A110817581308110811078E6932CA0711066F5800000A6F5500000A38A3010000088D42000001130A16130B387E01000002110B6F5900000A2C0F110A110B729E020070A2385F010000066F5000000A110B6F5300000A72AC0200706F5400000AA52F000001130C110C1F0F3024110C1A59450400000074000000B8000000D6000000FC000000110C1F0F2E523805010000110C1F133BE8000000110C1F153BDF000000110C1F1F59450400000005000000D9000000590000006D00000038D4000000110A110B02110B6F5A00000A285B00000A281D000006A238CA000000110A110B02110B6F5A00000A285B00000A281F000006A238AE000000110A110B02110B6F5A00000A285B00000A281E000006A23892000000110A110B02110B6F5A00000A2820000006A22B7E110A110B02110B6F5C00000A2821000006A22B6A110A110B02110B6F5D00000A130D120DFE16300000016F2600000AA22B4C110A110B02110B6F5E00000A130E120E285F00000A130F120F72C6020070286000000AA22B26110A110B02110B6F6100000A2822000006A22B12110A110B02110B6F6200000A6F2600000AA2110B1758130B110B026F6300000A3F75FEFFFF07110A6F5500000A026F6400000A3A52FEFFFF072A9A72F002007002FE16140000016F2600000A72F6020070284D00000A72FC020070286500000A2A8202720803007072210000706F3900000A729A02007072210000706F3900000A2A5E720C0300700F00286600000A8C33000001286700000A2A5E722A0300700F00286600000A8C33000001286700000A2A5E72620300700F00286600000A8C33000001286700000A2A72728C0300700F00286800000A736900000A8C33000001286700000A2A4672CC030070028C34000001286700000A2A00000013300300440000000B000011734B00000A7214040070284400000A0A0F00286A00000A0B160C2B1B0708910D061203721A040070286B00000A6F4400000A260817580C08078E6932DF066F2600000A2A2E7220040070732F00000A7A1A736C00000A7A00133004004100000000000000736D00000A251F20176F6E00000A251F0A176F6E00000A251F0D176F6E00000A251F09176F6E00000A251F0C176F6E00000A251F0B176F6E00000A80040000042A3A02281200000A02037D050000042A1B300300340000000C000011020328300000060A020428300000060B027B0500000406076F4D000006DE140C027B05000004086F6F00000A6F4E000006DE002A01100000000000001F1F0014070000021B300200370000000D000011140A027B05000004036F4B0000060A066F6400000A26030628320000060B030728330000060728340000060CDE07062831000006DC082A0001100000020002002C2E0007000000002A022C06026F3200000A2A001B3003002F0000000E000011036F4E00000A0ADE240B72940400700F00FE16140000016F2600000A72B0040070284D00000A07732C0000067A062A000110000000000000090900241D0000019A032D2272940400700F00FE16140000016F2600000A72F8040070284D00000A732B0000067A2A001B3005000D0100000F00001172210000700A026F5000000A6F7000000A0B38D3000000076F7100000A742E0000010C0872340500706F5400000A6F2600000A7246050070287200000A39A8000000067208030070283A00000A0A026F7300000A6F7000000A0D2B64096F7100000A74390000011304110428350000062C4E1C8D42000001251606A225177250050070A2251811046F7400000AA225197254050070A2251A0811046F7400000A6F5400000A252D0426142B056F2600000AA2251B7258050070A2287500000A0A096F7600000A2D94DE1409753A000001130511052C0711056F2900000ADC06729A020070283A00000A0A076F7600000A3A22FFFFFFDE1407753A000001130511052C0711056F2900000ADC062A000000011C000002005A0070CA00140000000002001200E5F7001400000000AA026F7400000A725C0500701B6F7700000A2D15026F7400000A72620500701B6F7700000A16FE012A162A3A02281200000A02037D060000042A000013300400A30000001000001102032838000006027B06000004046F4B0000060A160B066F6300000A1631270717580B07281F00000A03287800000A287900000A2C080628390000062B08066F7A00000A2DD9066F3200000A07281F00000A03287B00000A287900000A2C431B8D420000012516726C050070A225171201287C00000AA22518729E050070A225190F01FE16180000016F2600000AA2251A72D0050070A2287500000A732B0000067A2A001330030054000000110000110316281F00000A287B00000A0A06287900000A2D14060F01287D00000A287E00000A287F00000A2B0106287900000A2C2272F40500700F01FE16180000016F2600000A7252060070284D00000A732B0000067A2A13300200290000001200001102283C0000060A288000000A06738100000A6F8200000A0206283A000006288000000A6F8300000A2A722B11288000000A0203283B0000066F8400000A026F6400000A2DE72A000013300300230000001300001103738100000A026F6300000A8D0F0000010A02066F8500000A2625066F8600000A262A001B3003005100000014000011026F4E00000A283D000006256F8700000A8D3C0000010A160B6F8800000A0C2B151202288900000A0D060709283E000006A20717580B1202288A00000A2DE2DE0E1202FE160800001B6F2900000ADC062A0000000110000002001F002241000E000000001B3002006600000015000011738B00000A0A026F5000000A6F7000000A0B2B35076F7100000A742E0000010C0872340500706F5400000A6F2600000A6F8C00000A726E060070287200000A2C0806086F8D00000A26076F7600000A2DC3DE1107753A0000010D092C06096F2900000ADC062A000001100000020012004153001100000000133005006D010000160000110272AC0200706F5400000AA52F0000010A02727E0200706F5400000A74420000010B0272780600706F5400000A74400000010C064523000000050000000D000000050000000D000000050000004B000000050000000500000005000000050000000D0000000500000026000000050000000500000005000000050000000500000005000000050000000500000026000000260000000500000086000000050000008600000086000000860000007D0000008600000005000000050000004B0000004B00000038810000000706738E00000A2A070602728A0600706F5400000AA54F0000016A738F00000A2A02728A0600706F5400000AA54F0000010D0920FF7F00003102150D0706096A738F00000A2A07060272A00600706F5400000A289000000A289100000A0272C20600706F5400000A289000000A289100000A739200000A2A070608739300000A2A72DC0600701200FE162F0000016F2600000A72F2060070284D00000A739400000A7A4A7344000006732E00000602036F2F0000062A4A7344000006733600000602036F370000062A327307000006026F050000062A467344000006730C000006026F0D0000062A467344000006730C000006026F0E0000062A3602281200000A0228470000062A72027B090000042D0D02284800000602177D0900000402289500000A2A1E027B080000042A9E02739600000A7D07000004027B07000004723A0700706F9700000A027B070000046F2300000A2A32027B070000046F9800000A2A13300300260000000900001102726C070070281900000A284B000006256F6400000A2625166F9900000A0A6F3200000A062A32027B070000046F9A00000A2A00133003004D00000000000000027E9B00000A7D08000004027B0700000402FE064C000006739C00000A6F9D00000A732400000A25027B070000046F2500000A250F01FE16140000016F2600000A6F2700000A1A6F9E00000A2A000000133004004400000000000000027C08000004281C00000A2C10027221000070281900000A7D0800000402027B08000004046F9F00000A72B6070070283A00000A281900000A28A000000A7D080000042A133004004E00000000000000732400000A25027B070000046F2500000A2572BC0700706F2700000A256FA100000A72EE070070036FA200000A26256FA100000A7200080070046FA200000A26251A6FA300000A6F2800000A262AF2732400000A25027B070000046F2500000A25720E0800706F2700000A256FA100000A7224080070036FA200000A26251A6FA300000A6F2800000A262A00133004004100000000000000732400000A25027B070000046F2500000A2572360800706F2700000A256FA100000A7266080070038C140000016FA200000A26251A6FA300000A6F2800000A262A00000042534A4201000100000000000C00000076322E302E35303732370000000005006C000000800F0000237E0000EC0F0000A811000023537472696E677300000000942100007008000023555300042A0000100000002347554944000000142A0000F008000023426C6F620000000000000002000001579FA2090902000000FA01330016000001000000650000000C000000100000004F0000005100000003000000A3000000080000001300000001000000160000000200000005000000050000000800000001000000040000000100000000003B0801000000000006005805630D0600ED05630D060078041C0D0F00830D00000600A3053A090600A0043A0906003B053A09060007053A090600D4053A09060078053A090600EC043A0906008C04440D0600BE0577080600B7043A090600C90E77080A002605A50C0A00D301A50C0600CA02870E0A009105A50C0A00C906920D0600370011010600CF0B6D000E00D710480E0A001F00920D0600280011010A00A6092D0F12009C03730E0600970A7A1106009F0A77080600290B1D0906007D101D090A00C20EA50C0A00D004A50C0600C70377080A00C002920D0A005306A50C0A003C11920D0A006504A50C0600410177080A009A0E920D0600180011010600320C5310A700E70C00000A009C0B2D0F0A009E028F000A00B8108F000A00AD038F000A001A08920D0A00E502920D0A005F03920D06006E0377080600DE0E77080600E70B6D0006006F0C6D000600830877080600D80C870E0A00BA088F000600D60277080A008808920D0A00BC00A50C0A00E201A50C0E0012001101FB00E70C00000600CC0377080A00E60D2D0F0600A20777080600DC0B6D001200EA09730E0A009909A90A0A009B012D0F0A005501A90A0A00250C2D0F0A000B0CA90A06008B0877080A008F0BA90A060030113A09060052033A090600F50877080600220077080600E50777080A0078098F000A00E6038F000600E802770806001506770806000D0A77080A004C098F000600E70A77080A00A510A50C0A009403A50C0E000100110106001D0B08090600AA0F77080600FB0B77080600670A770806004D0077080E00630F25080A00470C2D0F0A00C80C8F000A0061092D0F0A00620C2D0F0A00BB038F00000000004400000000000100010001001000670E77003D0001000100000010000C0D77003D000100050001201000340A770075000100080000001000FF0C77003D0001000C00090110004A047700890002001000012010004D0A7700750005002A00000010008C0C77003D0005002E00000010007C0C77003D000600360081011000A70D77003D0007003F0000001000030277003D000700440003010000B80D0000DD000A00500001001602900451805000940451805C0097043100F8019A040100160290040100160290040100C209A204010072027D0301003501A60406068000970456801A0FA9045680CB07A9045680BB07A9045680DA07A90456805E0BA90456806D0BA9045020000000008618F20C060001005820000000009600E60FAD040100B8200000000091008607B4040200D020000000009100D90FBA04030004210000000086000B0648010600A0210000000091000E04C50407005020000000008618F20C06000700F221000000008618F20C06000700FA21000000008618F20C100007000322000000008618F20CA00008000D22000000008418F20CA7000A001722000000008618F20CC9040C002622000000008300A80248010D0045220000000083003B1048010E004E220000000083006F0148010F006122000000009600360BCF0410007C220000000096000D11D404100094220000000096003303CF041000D4220000000096001207DA04100018250000000096007506E604130059250000000091004D0BEE0414006825000000009100D909F30415006E26000000009100C508F90416009326000000009100F507FF041800C826000000009100530F040519001C27000000009100DD100E051B00AE29000000009100BA0F1D051D00D5290000000091005D04FF041E00F6290000000091004A0725051F000E2A000000009100360725052000262A0000000091002007250521003E2A000000009100FD062C0522005B2A0000000091005A0733052300702A00000000910074073A052400C02A000000009608510841052500C02A00000000E6095A0855002500C02A000000009600440446052500C02A00000000C6007D073E002600CC2A00000000E6012C014D052600CC2A00000000E601570454052700D42A000000009118F80C5B052800F221000000008618F20C06002800FA21000000008618F20C100028000322000000008618F20CA00029000D22000000008418F20CA7002B00212B000000008618F20CC9042D00302B0000000086009B005F052E00802B000000008100A60167053000D42B000000009100B50B6D053100E02B0000000091008602740532002C2C0000000091008A117F053400542C0000000091009B06880536008C2D000000009100BC0A8F053700B72D000000008618F20CC9043800C82D0000000086008E1096053900782E000000008100770B9E053B00D82E0000000091002F0D6D053C000D2F000000009100C800A4053D002C2F000000009100DD00AF053F005C2F000000009100ED0EBC054100CC2F000000009100340EC60542005030000000009100CF08D4054300C9310000000096009B00DD054400DC310000000096007C0CE5054600EF31000000009600B409ED054800FC310000000096002D10ED0549000E320000000096003B10ED054A002032000000008618F20C06004B002E3200000000E6013C0406004B004B320000000086085402F3054B005332000000008100D30E06004B007B32000000008100D00E06004B00883200000000860824033E004B00BA32000000008608F9023E004B00C8320000000086007E01F8054B002433000000008400640200064C0074330000000086000D0E08064E00CE33000000008600790A100050000C340000000086001B1048015100000001006F10000001006F1000000100CF1002000200F80A02000300FD0800000100C401000001007E02000001007E0200000200250A000001003B0B00000200B01000000100160200000100C40100000100C40100000100C40100000100EF0200000200010A00000300CE0F00000100430F000001002A0100000100430F00000100151000000200050800000100FB0000000100EF0200000200010A00000100F40B00000200F80F00000100CE0F000001001903000001003A06000001003A06000001003A06000001003A06000001003106000001004611000001001510000001001A0D00000100D110000001007E02000001007E0200000200250A000001003B0B00000200B010000001001602000001005F01000002008D0100000100C40100000100F40B00000100C40100000200F40B00000100C40100000200880000000100880000000100EA0800000100160200000100110B00000200C40100000100110B00000100AA0B00000100AA0B00000200030100000100AA0B00000200030100000100AA0B000001008800000001001A0E000001005F01000002008D0100000100050B00000200C40100000100C40100000100C40100000100C40100000100BC0100000100400C00000200FE0D00000100AD0600000200BC0600000100350200000100B31006008D00060091000B00E9000900F20C01001100F20C06001900F20C0A002900F20C10003100F20C10003900F20C10004100F20C10004900F20C10005100F20C10005900F20C10006100F20C15006900F20C15007100F20C10008100F20C06009900F20C06000901F20C1A003101F20C06007900F20C06000C00F20C0600B100F20C1000B900F20C1000B900B307390011027E083E001102A9074200A100080F47000C0031014D00190277033E00A1005A085500A1001A063E00140005116B00C100080F700014001A067600D900F20C8400D100F20C10002902B10806003102F20C060031028A098B0079007D073E0039025F101000390250119100D1013C0406002902360406004102F20C060049026E089A004902D3063E00E900F20C0600E900F20C1000E900F20CA000E900F20CA70059023604060061022411AF0061024A03B5006902F108BB0069029F08C1002901080FC60039013E01D4001102F001DA001102BB0EE0001C00650814011C00E40C1A0124006D0F6B001102EA0791008102D3102C0124004A1055008102B6082C015101F20C01005101800332015101CC0138015101EA0791005101A30F3F014101F20C4801B900F00152012C00181161011102F91071015101F20C06001102A90776011102BB0E7C0159028F02B2011C00F20C06006901B20EB8019102790F91001102130E390089026508BE0171016508C5011C003101CA013400F20C060034003101CA013400F110D70159024808DD0159026B03E2019101080FE9016101DB0EF20161011708F9016101E202000289011A06070299027D070B026101391110025902420617025902830F910059022C015500B900140F1C0291011A0623021102C20E29029901030E2F029901F20C330229011A06C100A1027D070B02A902F20C06002C00F20C06002C0031014D00E90029023E009102E40C6E02C1016D0F740211026C1178026901280E7E02C9010A033E001102BB0E8402C1014A10550011020C088A02C10060119902D9014B06A3025902220F5500C1009308990279027D073E00C1005A085500D901080FB002D901400BB702C1028B03CA02E901F20CD002C902920FD802C90246010600C902C010D8026101CF0DE402E901DC0DE4023C00790F91003C00E40C060344006D0F6B0044004A1055003C00F20C06001102C00C3E003C00B20F2D03E101F20C4403E101F20C4C03D902D1035503E10213065B03E101F20C6303E101F20C6D03F102F20C1000F90264067803D100F20C06002902E806100001033C04060059029F074200290201043E00A10060087D030903F20C8103D100440287033102C10B8E03090229023E00A100CD0997033102A30EA00319032406A6033902B703AE030E000800600408000C006D0408002C007204080030007704080034007C0408003800810408003C008604080040008B0424007B00DB082E000B0020062E00130029062E001B0048062E00230051062E002B007B062E00330089062E003B00B8062E004300BE062E004B00CE062E005300B8062E005B00B8062E006300D9062E006B00DF0640007300FD06C3008300AF0840028B001E0860028B001E0880028B001E080000010000000600210059007B009500CE00E6004E0167018301870138024202490253025B029202AA02C302DF02EA0219033903060001000B000300000060080E0600005E081306000066021706000028031C060000FD021C0602002300030002002400050002004600070002004900090002004A000B00310063000C0124015A01D001FD0210030480000001000000931FC90D01000000BE0377000000020000000000000000000000B503080100000000020000000000000000000000B5038F0000000000020000000000000000000000B503770800000000020000000000000000000000B503730E000000000C0006000000004C696E6B65644C6973744E6F64656031004C696E6B65644C69737460310053716C496E743332004B657956616C75655061697260320044696374696F6E6172796032003C4D6F64756C653E004743004E554C4C5F535452494E47004D41585F434F4C554D4E5F57494454480053797374656D2E494F007453514C74434C520076616C75655F5F00736368656D610053797374656D2E4461746100417373657274526573756C74536574734861766553616D654D657461446174610053716C4D657461446174610073656E64456163685265636F72644F6644617461006372656174655265636F7264506F70756C61746564576974684461746100726F7744617461006D657461006D73636F726C69620053797374656D2E436F6C6C656374696F6E732E47656E6572696300526561640041646400646973706F736564004E6577477569640053656E64526573756C7473456E64004462436F6D6D616E64006578706563746564436F6D6D616E640045786563757465436F6D6D616E640065786563757465436F6D6D616E640061637475616C436F6D6D616E640053716C436F6D6D616E6400637265617465536368656D61537472696E6746726F6D436F6D6D616E6400636F6D6D616E6400417070656E6400446174614163636573734B696E640053716C446174615265636F7264005265706C61636500576869746573706163650054657374446174616261736546616361646500746573744461746162617365466163616465006765745F4D657373616765006661696C7572654D657373616765006164645F496E666F4D657373616765006765745F496E666F4D657373616765004F6E496E666F4D65737361676500696E666F4D657373616765006D65737361676500617474656D7074546F476574536368656D615461626C6500446174615461626C6500436170747572654F7574707574546F4C6F675461626C6500494E756C6C61626C650049456E756D657261626C650049446973706F7361626C650047657453716C446F75626C65005461626C654E616D65006765745F44617461626173654E616D65006765745F436F6C756D6E4E616D6500636F6C756D6E4E616D65006765745F5365727665724E616D6500437265617465556E697175654F626A6563744E616D65004765744E616D6500417373656D626C794E616D650053716C4461746554696D65004765744461746554696D6500526561644C696E6500417070656E644C696E65006765745F506970650053716C50697065005472616E73616374696F6E53636F70650053716C446254797065007365745F436F6D6D616E64547970650056616C756554797065006765745F496E76617269616E7443756C7475726500496E7465726E616C44617461436F6C6C656374696F6E42617365006765745F446174616261736500437265617465436F6E6E656374696F6E537472696E67546F436F6E74657874446174616261736500436C6F736500446973706F7365005061727365007453514C745072697661746500577269746500756E71756F74650053716C4D6574686F644174747269627574650044656275676761626C6541747472696275746500436F6D56697369626C6541747472696275746500417373656D626C795469746C6541747472696275746500417373656D626C794B65794E616D654174747269627574650053716C55736572446566696E65645479706541747472696275746500417373656D626C7954726164656D61726B41747472696275746500417373656D626C79436F6E66696775726174696F6E4174747269627574650053716C46756E6374696F6E41747472696275746500417373656D626C794465736372697074696F6E41747472696275746500436F6D70696C6174696F6E52656C61786174696F6E7341747472696275746500417373656D626C7950726F647563744174747269627574650053716C466163657441747472696275746500417373656D626C79436F7079726967687441747472696275746500434C53436F6D706C69616E7441747472696275746500417373656D626C79436F6D70616E794174747269627574650052756E74696D65436F6D7061746962696C697479417474726962757465004578656375746500546F42797465006765745F56616C7565004164645769746856616C75650064746F56616C756500647456616C75650047657456616C7565006F705F54727565004942696E61727953657269616C697A6500537570707265737346696E616C697A6500476574416C74657253746174656D656E74576974686F7574536368656D6142696E64696E67006275696C64536368656D61537472696E67006578706563746564537472696E670061637475616C537472696E670053716C537472696E67006765745F436F6E6E656374696F6E537472696E67007365745F436F6E6E656374696F6E537472696E670053716C4461746554696D6532546F537472696E67005461626C65546F537472696E6700536D616C6C4461746554696D65546F537472696E670053716C4461746554696D65546F537472696E670053716C44617465546F537472696E670053716C4461746554696D654F6666736574546F537472696E670053716C42696E617279546F537472696E670047657450726F636564757265546578744173537472696E6700476574537472696E6700537562737472696E670049734D617463680041667465725365636F6E6444617368004166746572466972737444617368004166746572536C617368004D617468006765745F4C656E677468005472696D546F4D61784C656E677468006C656E67746800537461727473576974680047657453716C446563696D616C0053797374656D2E436F6D706F6E656E744D6F64656C007453514C74434C522E646C6C00497344424E756C6C006765745F4E756C6C006765745F49734E756C6C006765745F4974656D007365745F4974656D0053797374656D005472696D00456E756D0053716C426F6F6C65616E006F705F4C6573735468616E004765745075626C69634B6579546F6B656E004F70656E004D696E0044617461436F6C756D6E00506164436F6C756D6E0063726561746553716C4D65746144617461466F72436F6C756D6E00636F6C756D6E006765745F56657273696F6E00416E6E6F746174696F6E0053797374656D2E476C6F62616C697A6174696F6E0053797374656D2E52756E74696D652E53657269616C697A6174696F6E0053797374656D2E5265666C656374696F6E0044617461436F6C756D6E436F6C6C656374696F6E0053716C506172616D65746572436F6C6C656374696F6E0044617461526F77436F6C6C656374696F6E007365745F436F6E6E656374696F6E004462436F6E6E656374696F6E0053716C436F6E6E656374696F6E004E6577436F6E6E656374696F6E00636F6E6E656374696F6E006F705F4164646974696F6E004765745374617274506F736974696F6E005472616E73616374696F6E53636F70654F7074696F6E004F726465724F7074696F6E004E6F74496D706C656D656E746564457863657074696F6E00696E6E6572457863657074696F6E00436F6D6D616E644578656375746F72457863657074696F6E00496E76616C6964526573756C74536574457863657074696F6E00417267756D656E74457863657074696F6E006661696C5465737443617365416E645468726F77457863657074696F6E005365637572697479457863657074696F6E0053797374656D2E446174612E436F6D6D6F6E00636F6C756D6E50726F7065727479497356616C6964466F724D65746144617461436F6D70617269736F6E00537472696E67436F6D70617269736F6E00416E6E6F746174696F6E4E6F00726573756C745365744E6F00726573756C747365744E6F0043756C74757265496E666F0053657269616C697A6174696F6E496E666F00696E666F006F705F426974776973654F720049735768697465737061636543686172004166746572536C61736853746172004166746572537461720076616C6964617465526573756C745365744E756D626572004462446174615265616465720053716C44617461526561646572006461746152656164657200636C6F7365526561646572004578656375746552656164657200537472696E6752656164657200546578745265616465720042696E617279526561646572007265616465720049466F726D617450726F7669646572004462436F6E6E656374696F6E537472696E674275696C6465720053716C436F6E6E656374696F6E537472696E674275696C6465720073656E6465720053716C496E666F4D6573736167654576656E7448616E646C65720053716C506172616D657465720042696E61727957726974657200526573756C7453657446696C746572004D65746144617461457175616C6974794173736572746572004D6963726F736F66742E53716C5365727665722E53657276657200546F4C6F77657200436F6D6D616E644265686176696F720049456E756D657261746F7200476574456E756D657261746F72002E63746F72002E6363746F72004F7574707574436170746F7200436F6D6D616E644578656375746F720053797374656D2E446961676E6F73746963730073656E64526573756C747365745265636F7264730053797374656D2E52756E74696D652E496E7465726F7053657276696365730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F6465730053797374656D2E446174612E53716C54797065730053746F72656450726F63656475726573004765745374617274506F736974696F6E5374617465730047657453716C56616C7565730053657456616C7565730053716C496E666F4D6573736167654576656E74417267730061726773006765745F5469636B7300617373657274457175616C7300636F6C756D6E44657461696C73006765745F436F6C756D6E7300676574446973706C61796564436F6C756D6E730053797374656D2E546578742E526567756C617245787072657373696F6E7300416E6E6F746174696F6E730053797374656D2E5472616E73616374696F6E730053797374656D2E436F6C6C656374696F6E730053716C4368617273006765745F506172616D6574657273006765745F526F777300436F6E63617400466F726D6174004F626A65637400646973636F6E6E656374004765744461746554696D654F6666736574006372656174654D65746144617461466F72526573756C74736574006F705F496D706C696369740053706C69740044656661756C74004E657874526573756C740053797374656D2E446174612E53716C436C69656E740063726561746553746174656D656E740067657453716C53746174656D656E7400436F6D706F6E656E74006765745F43757272656E74006765745F436F756E74006765745F4669656C64436F756E740053656E64526573756C7473537461727400496E7365727400436F6E76657274004164644C6173740053706C6974436F6C756D6E4E616D654C69737400436F6C756D6E4C6973740050726F63657373526F77466F72476574416E6E6F746174696F6E4C697374005072696E744F6E6C79436F6C756D6E4E616D65416C6961734C69737400696E707574006C6F6743617074757265644F757470757400436170747572654F75747075740053757070726573734F7574707574004D6F76654E6578740053797374656D2E54657874007365745F436F6D6D616E64546578740070726F636564757265546578740053747265616D696E67436F6E746578740073656E6453656C6563746564526573756C74536574546F53716C436F6E7465787400636F6E746578740044617461526F770053656E64526573756C7473526F7700726F77004D6178005265676578006765745461626C65537472696E67417272617900546F417272617900546F436861724172726179006765745F4B6579005369676E696E674B657900436F6E7461696E734B657900476574457865637574696E67417373656D626C790047657453716C42696E6172790073716C42696E61727900457865637574654E6F6E5175657279006F705F457175616C697479006F705F496E657175616C6974790053797374656D2E5365637572697479007468726F77457863657074696F6E4966536368656D614973456D70747900001F5E005C0073002A002D002D005C005B0040007400530051004C0074003A0001010080B34500720072006F007200200063006F006E006E0065006300740069006E006700200074006F002000640061007400610062006100730065002E00200059006F00750020006D006100790020006E00650065006400200074006F00200063007200650061007400650020007400530051004C007400200061007300730065006D0062006C007900200077006900740068002000450058005400450052004E0041004C005F004100430043004500530053002E0000174400610074006100200053006F007500720063006500002749006E0074006500670072006100740065006400200053006500630075007200690074007900001F49006E0069007400690061006C00200043006100740061006C006F00670000237400530051004C0074005F00740065006D0070006F0062006A006500630074005F0000032D0001354F0062006A0065006300740020006E0061006D0065002000630061006E006E006F00740020006200650020004E0055004C004C0000037C0000032B0000634300520045004100540045005C0073002B00560049004500570028005C0073002A002E002A003F005C0073002A00290057004900540048005C0073002B0053004300480045004D004100420049004E00440049004E0047005C0073002B0041005300001D41004C00540045005200200056004900450057002400310041005300001975006E006500780070006500630074006500640020002F0000032000000B3C002E002E002E003E00001D530045004C0045004300540020002A002000460052004F004D002000001520004F0052004400450052002000420059002000001543006F006C0075006D006E004E0061006D00650000055D005D0000035D00000D21004E0055004C004C0021000019500072006F00760069006400650072005400790070006500002930002E0030003000300030003000300030003000300030003000300030003000300045002B00300000055D002C0000052C005B00000B5C005D002C005C005B0000035B00001D7B0030003A0079007900790079002D004D004D002D00640064007D0001377B0030003A0079007900790079002D004D004D002D00640064002000480048003A006D006D003A00730073002E006600660066007D0001297B0030003A0079007900790079002D004D004D002D00640064002000480048003A006D006D007D00013F7B0030003A0079007900790079002D004D004D002D00640064002000480048003A006D006D003A00730073002E0066006600660066006600660066007D0001477B0030003A0079007900790079002D004D004D002D00640064002000480048003A006D006D003A00730073002E00660066006600660066006600660020007A007A007A007D0001053000780000055800320000737400530051004C007400500072006900760061007400650020006900730020006E006F007400200069006E00740065006E00640065006400200074006F002000620065002000750073006500640020006F0075007400730069006400650020006F00660020007400530051004C0074002100001B540068006500200063006F006D006D0061006E00640020005B0000475D00200064006900640020006E006F0074002000720065007400750072006E00200061002000760061006C0069006400200072006500730075006C0074002000730065007400003B5D00200064006900640020006E006F0074002000720065007400750072006E0020006100200072006500730075006C0074002000730065007400001149007300480069006400640065006E000009540072007500650000037B0000033A0000037D0000054900730000094200610073006500003145007800650063007500740069006F006E002000720065007400750072006E006500640020006F006E006C00790020000031200052006500730075006C00740053006500740073002E00200052006500730075006C00740053006500740020005B0000235D00200064006F006500730020006E006F0074002000650078006900730074002E00005D52006500730075006C007400530065007400200069006E00640065007800200062006500670069006E007300200061007400200031002E00200052006500730075006C007400530065007400200069006E0064006500780020005B00001B5D00200069007300200069006E00760061006C00690064002E0000097400720075006500001144006100740061005400790070006500001543006F006C0075006D006E00530069007A00650000214E0075006D00650072006900630050007200650063006900730069006F006E0000194E0075006D0065007200690063005300630061006C006500001541007200670075006D0065006E00740020005B0000475D0020006900730020006E006F0074002000760061006C0069006400200066006F007200200052006500730075006C007400530065007400460069006C007400650072002E00003143006F006E007400650078007400200043006F006E006E0065006300740069006F006E003D0074007200750065003B000049530045004C004500430054002000530045005200560045005200500052004F0050004500520054005900280027005300650072007600650072004E0061006D006500270029003B0001050D000A0000317400530051004C0074002E0041007300730065007200740045007100750061006C00730053007400720069006E006700001145007800700065006300740065006400000D410063007400750061006C0000157400530051004C0074002E004600610069006C0000114D006500730073006100670065003000002F7400530051004C0074002E004C006F006700430061007000740075007200650064004F0075007400700075007400000974006500780074000054E676F0AE1C744AB26E0953546BB50500042001010803200001052001011111042001010E0420010102062001011180810F0705151255020811510812590E125D0715125502081151042001020E0320000E0420010E0805000111510E072002011300130103200002090701151165020811510715116502081151042000130005000111610804200013010807031269126D127106200101118111052001011269032000080407020E0E052002010E1C062002010E1275072002011279117D0500001281310520001281350520001281390420001D050700011180951D0505070111809D05000011809D0520020E0E0E0500020E0E0E2507110E151280A5011D0E081D0808021280A9151180AD011D0E1D0E08081D0808081D0E080807151280A5011D0E052001130008092000151180AD01130007151180AD011D0E0500020808080520001280A90620011280A90E0820031280A9080E08052001011151030701080720040E0E0E0808061512550203020520010213000907051D0308113008080420001D030520020E08080600030E0E0E0E0307010E2A07101280B5151280A5011D0E081D0E081280B9151280A5010E1D0E080E1D0E081180BD1180C11180C50D0520001280B50520001281450620011280B9080420011C0E05200101130006151280A5010E0520001D130004200102080620011180CD080800011180C91180CD0620011180D1080620011180C1080620011180C5080320000D0420010E0E062001118095080420011C080600021D0E0E0E0520001180CD0500020E0E1C0320000A042001010A0907041280A91D0508050607030E0E121C0907031280B11280B50E0707021280B512751207060E1280E11280B91280E11280E51280E90520001280E10320001C050002020E0E0520001281590500010E1D0E072002020E11815D0607021280B1080900021180ED11611161060001021180ED0507011180ED0600011180ED020B00021180ED1180ED1180ED0607011D1280F1050000128165072001011D1280F1062001011280F50407011D1C052001081D1C1207041D1280F108151180FD011280B91280B908151280F9011280B9092000151180FD01130008151180FD011280B9130704151280F9011280B91280E11280B91280E90B20011512816901130013000A07041180BD0E12810108072002010E1180BD082003010E1180BD0A05000012816D070002051C128175092004010E1180BD05050A2003010E1180BD128101040001011C03061151052002011C18062001011281850820011280B111818908000211511151115105200012818D0720021281910E1C0620010111819508B77A5C561934E08980A00024000004800000940000000602000000240000525341310004000001000100B9AF416AD8DFEDEC08A5652FA257F1242BF4ED60EF5A7B84A429604D62C919C5663A9C7710A7C5DF9953B69EC89FCE85D71E051140B273F4C9BF890A2BC19C48F22D7B1F1D739F90EEBC5729555F7F8B63ED088BBB083B336F7E38B92D44CFE1C842F09632B85114772FF2122BC638C78D497C4E88C2D656C166050D6E1EF3940C21004E0055004C004C002100049B0000000400000000040100000004020000000403000000040400000004050000000306122C02060E02060807061512550203020306126902060203061130060001124911510500010E11510A0003011C1011611011510300000E05200101122C04000011510500001180950B00031280A11151115111510700011280A1115104000102030500010811510500020E0E080400010E0E0900020E1011511011510E0002151280A5011D0E1280B111510700011D0E1011510600010E1180C90600010E1180CD0600010E1180D10600010E118095040000111806000111181151062001011280D5062001011280D90300000107200201115111510520010E1151060001011280B10A00021280B511511280B10800020111511280B50600010E1280B5060001021280E507200201116111510520010111610A0002011280B11D1280F10C00021280F51280B11D1280F10900011D1280F11280B10D0001151280F9011280B91280B50800011280F11280B90700020111511151070002011161115105000101115104200011510720011280B11151072002011C128105052002010E0E04080011180328000204280011510328000E0801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F77730108010002000000000029010024436F7079726967687420C2A9202073716C6974792E6E65742032303130202D203230313500000D0100087453514C74434C5200002E010029434C527320666F7220746865207453514C7420756E69742074657374696E67206672616D65776F726B00000501000000000F01000A73716C6974792E6E657400000A0100057453514C7400000501000100001D0100187453514C745F4F6666696369616C5369676E696E674B65790000811F010005005455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D322E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630154020949735072656369736501540E0F5461626C65446566696E6974696F6E2A416E6E6F746174696F6E4E6F20494E542C20416E6E6F746174696F6E204E56415243484152284D415829540E1146696C6C526F774D6574686F644E616D651E50726F63657373526F77466F72476574416E6E6F746174696F6E4C697374808F010001005455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D322E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A44617461416363657373010000002B010002000000020054080B4D61784279746553697A650100000054020D497346697865644C656E6774680112010001005408074D617853697A65FFFFFFFF0000EB06C2A28199175C1922F5244EB4E5C34276704E2B0009A88E85A27E4741464DB89E7361541154C9F705E6DD8FAA066C344E1BFA5475F9A78F2A40EFE883C693BC06F9E884930BA96DC66A978A6B46E807369489DB3AC6281D56A59DA5B714A02FAFC53F42C54D07638EB7A28B148F5BFA306AFC47356B5C63AD86B42E68C0510000000095AB0D6200000000020000001C010000FC670000FC490000525344537D89B6DEAF5FB54A96906274BAF65C4F01000000443A5C615C315C7453514C745C7453514C74434C525C7453514C74434C525C6F626A5C437275697365436F6E74726F6C5C7453514C74434C522E706462000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004069000000000000000000005A6900000020000000000000000000000000000000000000000000004C690000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C0000000000FF250020001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058800000C00300000000000000000000C00334000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE0000010000000100C90D931F00000100C90D931F3F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B00420030000010053007400720069006E006700460069006C00650049006E0066006F000000FC02000001003000300030003000300034006200300000006C002A00010043006F006D006D0065006E0074007300000043004C0052007300200066006F007200200074006800650020007400530051004C007400200075006E00690074002000740065007300740069006E00670020006600720061006D00650077006F0072006B00000036000B00010043006F006D00700061006E0079004E0061006D00650000000000730071006C006900740079002E006E0065007400000000003A0009000100460069006C0065004400650073006300720069007000740069006F006E00000000007400530051004C00740043004C005200000000003C000E000100460069006C006500560065007200730069006F006E000000000031002E0030002E0038003000380033002E00330035003200390000003A000D00010049006E007400650072006E0061006C004E0061006D00650000007400530051004C00740043004C0052002E0064006C006C00000000006C00240001004C006500670061006C0043006F007000790072006900670068007400000043006F0070007900720069006700680074002000A90020002000730071006C006900740079002E006E00650074002000320030003100300020002D002000320030003100350000002A00010001004C006500670061006C00540072006100640065006D00610072006B007300000000000000000042000D0001004F0072006900670069006E0061006C00460069006C0065006E0061006D00650000007400530051004C00740043004C0052002E0064006C006C00000000002C0006000100500072006F0064007500630074004E0061006D006500000000007400530051004C007400000040000E000100500072006F006400750063007400560065007200730069006F006E00000031002E0030002E0038003000380033002E003300350032003900000044000E00010041007300730065006D0062006C0079002000560065007200730069006F006E00000031002E0030002E0038003000380033002E00330035003200390000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000C0000006C3900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
WITH PERMISSION_SET = EXTERNAL_ACCESS

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[PathogenType](
	[pathogenType_id] [int] IDENTITY(1,1) NOT NULL,
	[pathogenType_nm] [varchar](50) NOT NULL,
 CONSTRAINT [PK_PathogenType] PRIMARY KEY CLUSTERED 
(
	[pathogenType_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE UNIQUE NONCLUSTERED INDEX [UQ_PathogenType_nm] ON [dbo].[PathogenType]
(
	[pathogenType_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Pathogen](
	[pathogen_id] [int] IDENTITY(1,1) NOT NULL,
	[pathogen_nm] [varchar](100) NULL,
	[pathogenType_nm] [varchar](100) NULL,
	[pathogenType_id] [int] NULL,
	[subtype] [varchar](50) NULL,
	[latin_nm] [varchar](150) NULL,
	[alt_latin_nms] [varchar](200) NULL,
	[alt_common_nms] [varchar](200) NULL,
	[ph_common_nms] [varchar](50) NULL,
	[crops] [varchar](360) NULL,
	[taxonomy] [varchar](250) NULL,
	[biological_cure] [varchar](600) NULL,
	[notes] [varchar](500) NULL,
	[urls] [varchar](500) NULL,
	[image] [varchar](500) NULL,
	[binomial_nm] [varchar](50) NULL,
	[synonyms] [varchar](1500) NULL,
 CONSTRAINT [PK_Pathogen] PRIMARY KEY CLUSTERED 
(
	[pathogen_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [IX_Pathogen_nm] UNIQUE NONCLUSTERED 
(
	[pathogen_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].[Pathogen]  WITH NOCHECK ADD  CONSTRAINT [FK_Pathogen_PathogenType] FOREIGN KEY([pathogenType_id])
REFERENCES [dbo].[PathogenType] ([pathogenType_id])

ALTER TABLE [dbo].[Pathogen] NOCHECK CONSTRAINT [FK_Pathogen_PathogenType]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Crop](
	[crop_id] [int] IDENTITY(1,1) NOT NULL,
	[crop_nm] [varchar](100) NOT NULL,
	[latin_nm] [varchar](50) NULL,
	[alt_latin_nms] [varchar](50) NULL,
	[alt_common_nms] [varchar](50) NULL,
	[taxonomy] [varchar](250) NULL,
	[notes] [varchar](150) NULL,
 CONSTRAINT [PK_Crop] PRIMARY KEY CLUSTERED 
(
	[crop_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[CropPathogen](
	[crop_id] [int] NOT NULL,
	[pathogen_id] [int] NOT NULL,
	[crop_nm] [varchar](50) NULL,
	[pathogen_nm] [varchar](100) NULL,
 CONSTRAINT [PK_CropPathogen] PRIMARY KEY CLUSTERED 
(
	[crop_id] ASC,
	[pathogen_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_CropPathogen_crop] ON [dbo].[CropPathogen]
(
	[crop_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_CropPathogen_pathogen] ON [dbo].[CropPathogen]
(
	[pathogen_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

ALTER TABLE [dbo].[CropPathogen]  WITH CHECK ADD  CONSTRAINT [FK_CropPathogen_Crop] FOREIGN KEY([crop_id])
REFERENCES [dbo].[Crop] ([crop_id])

ALTER TABLE [dbo].[CropPathogen] CHECK CONSTRAINT [FK_CropPathogen_Crop]

ALTER TABLE [dbo].[CropPathogen]  WITH CHECK ADD  CONSTRAINT [FK_CropPathogen_Pathogen] FOREIGN KEY([pathogen_id])
REFERENCES [dbo].[Pathogen] ([pathogen_id])

ALTER TABLE [dbo].[CropPathogen] CHECK CONSTRAINT [FK_CropPathogen_Pathogen]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry Watts
-- Create date: 08-JAN-2020
-- Description: fnLen deals with the trailing spaces bug in Len
-- ===============================================================
CREATE   FUNCTION [dbo].[fnLen]( @v VARCHAR(8000))
RETURNS INT
AS
BEGIN
   RETURN CASE
            WHEN @v IS NULL THEN 0
            ELSE Len(@v+'x')-1
            END;
END
/*
EXEC test.sp__crt_tst_rtns 'dbo].[fnLen]', 43;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==========================================================================
-- Author:      Terry Watts
-- Create date: 08-JAN-2020
-- Description: Removes specific characters from the right end of a string
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ==========================================================================
CREATE   FUNCTION [dbo].[fnRTrim]
(
   @s VARCHAR(MAX)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE  
       @tcs    VARCHAR(20)

   IF (@s IS NULL ) OR (LEN(@s) = 0)
      RETURN @s;

   SET @tcs = CONCAT( NCHAR(9), NCHAR(10), NCHAR(13), NCHAR(32), NCHAR(160))

   WHILE CHARINDEX(Right(@s, 1) , @tcs) > 0 AND dbo.fnLen(@s) > 0 -- SUBSTRING(@s,  dbo.fnLen(@s)-1, 1) or Right(@s, 1)
      SET @s = SUBSTRING(@s, 1, dbo.fnLen(@s)-1); -- SUBSTRING(@s, 1, dbo.fnLen(@s)-1) or Left(@s, dbo.fnLen(@s)-1)

   RETURN @s;
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ================================================================
-- Author:      Terry Watts
-- Create date: 23-JUN-2023
-- Description: Removes specific characters from 
--              the beginning of a string
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ==================================================================
CREATE   FUNCTION [dbo].[fnLTrim]
(
    @s VARCHAR(MAX)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE  
       @tcs    VARCHAR(20)

   IF (@s IS NULL ) OR (dbo.fnLen(@s) = 0)
      RETURN @s;

   SET @tcs = CONCAT( NCHAR(9), NCHAR(10), NCHAR(13), NCHAR(32), NCHAR(160))

   WHILE CHARINDEX(SUBSTRING(@s, 1, 1), @tcs) > 0 AND dbo.fnLen(@s) > 0
      SET @s = SUBSTRING(@s, 2, dbo.fnLen(@s)-1);

   RETURN @s;
END
/*
PRINT CONCAT('[', fnTrim(' '), ']')
PRINT CONCAT('[', fnLTrim(' '), ']')
PRINT CONCAT('[', fnLTrim2(' ', ' '), ']')
PRINT CONCAT('[', fnLTrim(CONCAT(0x20, 0x09, 0x0a, 0x0d, 0x20,'a', 0x20, 0x09, 0x0a, 0x0d, 0x20,' #cd# ')), ']');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ================================================================
-- Author:      Terry Watts
-- Create date: 10-OCT-2019
-- Description: Trims leading and trailing whitesace including the 
--                normally untrimmable CHAR(160)
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ================================================================
CREATE   FUNCTION [dbo].[fnTrim]( @s VARCHAR(4000)
)
RETURNS VARCHAR(4000)
AS
BEGIN
  RETURN dbo.fnRTrim( dbo.fnLTrim(@s));
END
/*
PRINT CONCAT('[', dbo.fnTrim(CONCAT(0x20, 0x09, 0x0a, 0x0d, 0xA0, '  a  #cd# ', 0x20, 0x09, 0x0a, 0x0d, 0x0d,0xA0)), ']');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 29-NOV-2024
-- Description: Pathogen Search Utility
-- =============================================
CREATE   FUNCTION [dbo].[fnFindPathogen](@pathogen VARCHAR(60))
RETURNS
@t TABLE
(
   pathogen_nm       VARCHAR(1000) NULL,
   crop_nm           VARCHAR(100) NULL,
   latin_name        VARCHAR(250)  NULL,
   alt_common_names  VARCHAR(200) NULL,
   alt_latin_names   VARCHAR(200) NULL,
   ph_common_names   VARCHAR(100)  NULL
)
AS
BEGIN
   DECLARE
       @srch   VARCHAR(60) = CONCAT('%', dbo.fnTrim(@pathogen), '%')
      ,@len    INT
      ,@cnt    INT = 0
   ;

   SET @pathogen = dbo.fnTrim(@pathogen);
   SET @srch     = CONCAT('%', dbo.fnTrim(@pathogen), '%')

   SET @len = dbo.fnLen(@pathogen);

   -- Search, and if nothing found so far try lopping off some characters till found
   WHILE @len > 1
   BEGIN
      SET @cnt = @cnt + 1;

      INSERT INTO @t(pathogen_nm,crop_nm, latin_name,alt_common_names,alt_latin_names,ph_common_names)
      SELECT       p.pathogen_nm,crop_nm, latin_name,alt_common_names,alt_latin_names,ph_common_names
      FROM Pathogen p LEFT JOIN CropPathogen cp ON p.pathogen_nm= cp.pathogen_nm
      WHERE p. pathogen_nm LIKE @srch OR alt_common_names like @srch OR latin_name LIKE @srch OR alt_latin_names LIKE @srch;

      if @cnt > 50
         break;

      -- if not found lop off 1 character in srch
      IF @@ROWCOUNT = 0
      BEGIN
         --INSERT INTO @t(pathogen_nm) VALUES(CONCAT('@cnt: ', @cnt, ' @len: ', @len,' @s:[',@srch, ']'));

         SET @srch = CONCAT('%',SUBSTRING( @pathogen, 1, @len), '%');
         SET @len = @len - 1;
      END
      ELSE
      BEGIN
         --INSERT INTO @t(pathogen_nm) VALUES('@@ROWCOUNT <> 0');
         BREAK;
      END
   END

   RETURN;
END
/*
SELECT * FROM dbo.fnFindPathogen('Sigatoka');
SELECT pathogen_nm FROM dbo.fnFindPathogen('Alternaria');
select * pATHOGEN P lEFT JOIN CROP
CREATE OR ALTERnaria*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================================================
-- Author:      Terry Watts
-- Create date: 04-JAN-2021
-- Description: determines if 2 floats are approximately equal
-- Returns    : 1 if a significantly gtr than b
--              0 if a = b with the signifcance of epsilon 
--             -1 if a significantly less than b within +/- Epsilon, 0 otherwise
-- DROP FUNCTION [dbo].[fnCompareFloats2]
-- =============================================================================================
CREATE FUNCTION [dbo].[fnCompareFloats2](@a FLOAT(24), @b FLOAT(24), @epsilon FLOAT(24) = 0.00001)
RETURNS INT
AS
BEGIN
   DECLARE   @v      FLOAT(24)
            ,@res    INT

   SET @v   = abs(@a - @b);

   IF(@v < @epsilon)
      RETURN 0;  -- a = b within the tolerance of epsilon

   -- ASSERTION  a is signifcantly different to b

   -- 10-7 is the tolerance for floats
   SET @v   = round(@a - @b, 7);
   SET @res = IIF( @v>0.0, 1, -1);
   RETURN @res;
END
/*
EXEC test.sp_crt_tst_rtns 'dbo].[fnCompareFloats2', 80
-- Test
-- cmp > tolerance
PRINT CONCAT('[dbo].[fnCompareFloats2](1.2, 1.3, 0.00001)          : ', [dbo].[fnCompareFloats2](1.2, 1.3, 0.00001),       ' T01: EXP -1')
PRINT CONCAT('[dbo].[fnCompareFloats2](1.2, 1.2, 0.00001)          : ', [dbo].[fnCompareFloats2](1.2, 1.2, 0.00001),       '  T02: EXP  0')
PRINT CONCAT('[dbo].[fnCompareFloats2](1.3, 1.2, 0.00001)          : ', [dbo].[fnCompareFloats2](1.3, 1.2, 0.00001),       '  T03: EXP  1')
PRINT CONCAT('[dbo].[fnCompareFloats2](0.1,      0.1 , 0.00001)    : ', [dbo].[fnCompareFloats2](0.1,       0.1, 0.00001), '  T04: EXP  0')
PRINT CONCAT('[dbo].[fnCompareFloats2](0.10001,  0.1 , 0.00001)    : ', [dbo].[fnCompareFloats2](0.10001,   0.1, 0.00001), '  T05: EXP  0')
PRINT CONCAT('[dbo].[fnCompareFloats2](0.1,  0.000009, 0.00001)    : ', [dbo].[fnCompareFloats2](0.1,  0.100009, 0.00001), '  T06 in tolerance: EXP  0')
PRINT CONCAT('[dbo].[fnCompareFloats2](0.1,  0.10001 , 0.00001)    : ', [dbo].[fnCompareFloats2](0.1,  0.10001 , 0.00001), '  T07 exact: EXP  0')
PRINT CONCAT('[dbo].[fnCompareFloats2](0.1,  0.000011, 0.00001)    : ', [dbo].[fnCompareFloats2](0.1,  0.100011, 0.00001), ' T08 out of tolerance: EXP -1')
PRINT CONCAT('[dbo].[fnCompareFloats2](0.100011, 0.1, 0.00001)     : ', [dbo].[fnCompareFloats2](0.100011, 0.1, 0.00001) , '  T09 out of tolerance: EXP  1')
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================================
-- Author:      Terry Watts
-- Create date: 04-JAN-2021
-- Description: determines if 2 floats are approximately equal
-- Returns    : 1 if a significantly gtr than b
--              0 if a = b with the signifcance of epsilon 
--             -1 if a significantly less than b within +/- Epsilon, 0 otherwise
-- =================================================================
CREATE FUNCTION [dbo].[fnCompareFloats](@a FLOAT(24), @b FLOAT(24))
RETURNS INT
AS
BEGIN
   RETURN
      dbo.fnCompareFloats2(@a, @b, 0.00001);
END
/*
*/


GO
SET ANSI_NULLS OFF

SET QUOTED_IDENTIFIER OFF

GO

CREATE FUNCTION [dbo].[Regex_Match_Count](@input [nvarchar](max), @pattern [nvarchar](max))
RETURNS [int] WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [RegEx].[Regex].[Regex_Match_Count]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =========================================================================
-- Author:      Terry Watts
-- Create date: 23-Jul-2024
-- Description: creates the script file name based on 
--    rtn_nm, server name and DB name
--
--- Changes:
-- =========================================================================
CREATE FUNCTION [test].[fnCrtScriptFileName](@rtn_nm VARCHAR(60))
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE @ret VARCHAR(MAX)
   SELECT @ret = CONCAT(@@SERVERNAME, '.', DB_NAME(), '.', @rtn_nm,'.sql');

RETURN @ret;
END
/*
PRINT test.fnCrtScriptFileName('MyRtn','D:\tmp');
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================    
-- Author:      Terry Watts
-- Create date: 23-JUN-2023
-- Description: Pads Right with specified padding character
-- =============================================    
CREATE   FUNCTION [dbo].[fnPadRight2]
(
    @s      VARCHAR(MAX)
   ,@width  INT
   ,@pad    VARCHAR(1)
)
RETURNS VARCHAR (1000)
AS
BEGIN
   DECLARE 
      @ret  VARCHAR(1000)
     ,@len  INT

   IF @s IS null
      SET @s = '';

   SET @len = ut.dbo.fnLen(@s)
   RETURN LEFT( CONCAT( @s, REPLICATE( @pad, @width-@len)), @width)
END
/*
SELECT CONCAT('[', dbo.fnPadRight2('a very long string indeed - its about time we had a beer', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadRight2('', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadRight2(NULL, 25, '.'), ']  ');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================    
-- Author:  Terry Watts
-- Create date: 04-OCT-2019
-- Description: Pads Right
-- =============================================    
CREATE   FUNCTION [dbo].[fnPadRight]( @s VARCHAR(500), @width INT)
RETURNS VARCHAR (1000)
AS
BEGIN
   RETURN dbo.fnPadRight2( @s, @width, ' ' )
END
/*
SELECT CONCAT(', ]', dbo.fnPadRight([name], 25), ']  ', [type])
FROM [tg].[test].[fnCrtPrmMap]( '          @table_nm                  VARCHAR(50)  
         ,@folder                    VARCHAR(260)  
         ,@workbook_nm               VARCHAR(260)   OUTPUT  
         ,@sheet_nm                  VARCHAR(50)    OUTPUT  
         ,@view_nm                   VARCHAR(50)    OUTPUT  
         ,@error_msg                 VARCHAR(200)   OUTPUT  ')
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[AppLog](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[timestamp] [varchar](30) NOT NULL,
	[schema_nm] [varbinary](20) NULL,
	[rtn] [varchar](60) NULL,
	[hit] [int] NULL,
	[log] [varchar](max) NULL,
	[msg] [varchar](max) NULL,
	[level] [int] NULL,
	[row_count] [int] NULL,
 CONSTRAINT [PK_AppLog] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

ALTER TABLE [dbo].[AppLog] ADD  CONSTRAINT [DF_AppLog_timestamp]  DEFAULT (getdate()) FOR [timestamp]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================
-- Author:      Terry Watts
-- Create date: 25-MAY-2020
-- Description: Get session context as int - default = -1
-- RETURNS      if    key/value present returns value as INT
--              if no key/value present returns NULL
--
-- See Also: fnGetSessionContextAsString, sp_set_session_context
--
-- CHANGES:
-- 14-JUL-2023: default = -1 (not found) was 0 before
-- 06-FEB-2024: simply returns value if key found else NULL
-- ===============================================================
CREATE   FUNCTION [dbo].[fnGetSessionContextAsInt](@key NVARCHAR(100))
RETURNS INT
BEGIN
   RETURN CONVERT(INT, SESSION_CONTEXT(@key));
END
/*
PRINT CONCAT('[',dbo.fnGetSessionContextAsInt(N'cor_id'),']')
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =========================================================================
-- Author:      Terry Watts
-- Create date: 22-MAR-2020
-- Description: Logs to output and to the AppLog table

-- Level: 0 DEBUG
--        1 INFO
--        2 NOTE
--        3 WARNING (CONTINUE)
--        4 ERROR   (STOP)
--
-- Changes:
-- 231014: Added support of table logging: add a row to table for each log 
--            Level and msg
-- 231016: Added fn and optional row count columns
-- 231017: @fn no longer needs the trailing ' :'
-- 231018: @fn, @row_count are stored as separate fields
-- 231115: added Level
-- 231116: always append to the AppLog table - bit print is conditional on level
-- 240309: Trimmed the  @fn paameter as it is left padded
-- 240314: Logic Change: now if less than min log level do not log or print msg
-- 231221: added hold, values:
--          0: print cache first then this msg on same line immediatly
--          1: cache msg for later - dont print it now 
--          2: dump cache first then print this msg on a new line immediatly
-- 240422: separate lines into a separate display line if msg contains \r\n
-- =================================================================================
CREATE PROCEDURE [dbo].[sp_log]
 @level  INT = 1
,@fn     VARCHAR(35)=NULL
,@msg00  VARCHAR(MAX)=NULL,@msg01  VARCHAR(MAX)=NULL,@msg02  VARCHAR(MAX)=NULL,@msg03  VARCHAR(MAX)=NULL,@msg04  VARCHAR(MAX)=NULL,@msg05  VARCHAR(MAX)=NULL,@msg06  VARCHAR(MAX)=NULL,@msg07  VARCHAR(MAX)=NULL,@msg08  VARCHAR(MAX)=NULL,@msg09  VARCHAR(MAX)=NULL
,@msg10  VARCHAR(MAX)=NULL,@msg11  VARCHAR(MAX)=NULL,@msg12  VARCHAR(MAX)=NULL,@msg13  VARCHAR(MAX)=NULL,@msg14  VARCHAR(MAX)=NULL,@msg15  VARCHAR(MAX)=NULL,@msg16  VARCHAR(MAX)=NULL,@msg17  VARCHAR(MAX)=NULL,@msg18  VARCHAR(MAX)=NULL,@msg19  VARCHAR(MAX)=NULL
,@msg20  VARCHAR(MAX)=NULL,@msg21  VARCHAR(MAX)=NULL,@msg22  VARCHAR(MAX)=NULL,@msg23  VARCHAR(MAX)=NULL,@msg24  VARCHAR(MAX)=NULL,@msg25  VARCHAR(MAX)=NULL,@msg26  VARCHAR(MAX)=NULL,@msg27  VARCHAR(MAX)=NULL,@msg28  VARCHAR(MAX)=NULL,@msg29  VARCHAR(MAX)=NULL
,@msg30  VARCHAR(MAX)=NULL,@msg31  VARCHAR(MAX)=NULL,@msg32  VARCHAR(MAX)=NULL,@msg33  VARCHAR(MAX)=NULL,@msg34  VARCHAR(MAX)=NULL,@msg35  VARCHAR(MAX)=NULL,@msg36  VARCHAR(MAX)=NULL,@msg37  VARCHAR(MAX)=NULL,@msg38  VARCHAR(MAX)=NULL,@msg39  VARCHAR(MAX)=NULL
,@msg40  VARCHAR(MAX)=NULL,@msg41  VARCHAR(MAX)=NULL,@msg42  VARCHAR(MAX)=NULL,@msg43  VARCHAR(MAX)=NULL,@msg44  VARCHAR(MAX)=NULL,@msg45  VARCHAR(MAX)=NULL,@msg46  VARCHAR(MAX)=NULL,@msg47  VARCHAR(MAX)=NULL,@msg48  VARCHAR(MAX)=NULL,@msg49  VARCHAR(MAX)=NULL
,@msg50  VARCHAR(MAX)=NULL,@msg51  VARCHAR(MAX)=NULL,@msg52  VARCHAR(MAX)=NULL,@msg53  VARCHAR(MAX)=NULL,@msg54  VARCHAR(MAX)=NULL,@msg55  VARCHAR(MAX)=NULL,@msg56  VARCHAR(MAX)=NULL,@msg57  VARCHAR(MAX)=NULL,@msg58  VARCHAR(MAX)=NULL,@msg59  VARCHAR(MAX)=NULL
,@msg60  VARCHAR(MAX)=NULL,@msg61  VARCHAR(MAX)=NULL,@msg62  VARCHAR(MAX)=NULL,@msg63  VARCHAR(MAX)=NULL,@msg64  VARCHAR(MAX)=NULL,@msg65  VARCHAR(MAX)=NULL,@msg66  VARCHAR(MAX)=NULL,@msg67  VARCHAR(MAX)=NULL,@msg68  VARCHAR(MAX)=NULL,@msg69  VARCHAR(MAX)=NULL
,@msg70  VARCHAR(MAX)=NULL,@msg71  VARCHAR(MAX)=NULL,@msg72  VARCHAR(MAX)=NULL,@msg73  VARCHAR(MAX)=NULL,@msg74  VARCHAR(MAX)=NULL,@msg75  VARCHAR(MAX)=NULL,@msg76  VARCHAR(MAX)=NULL,@msg77  VARCHAR(MAX)=NULL,@msg78  VARCHAR(MAX)=NULL,@msg79  VARCHAR(MAX)=NULL
,@msg80  VARCHAR(MAX)=NULL,@msg81  VARCHAR(MAX)=NULL,@msg82  VARCHAR(MAX)=NULL,@msg83  VARCHAR(MAX)=NULL,@msg84  VARCHAR(MAX)=NULL,@msg85  VARCHAR(MAX)=NULL,@msg86  VARCHAR(MAX)=NULL,@msg87  VARCHAR(MAX)=NULL,@msg88  VARCHAR(MAX)=NULL,@msg89  VARCHAR(MAX)=NULL
,@msg90  VARCHAR(MAX)=NULL,@msg91  VARCHAR(MAX)=NULL,@msg92  VARCHAR(MAX)=NULL,@msg93  VARCHAR(MAX)=NULL,@msg94  VARCHAR(MAX)=NULL,@msg95  VARCHAR(MAX)=NULL,@msg96  VARCHAR(MAX)=NULL,@msg97  VARCHAR(MAX)=NULL,@msg98  VARCHAR(MAX)=NULL,@msg99  VARCHAR(MAX)=NULL
,@msg100 VARCHAR(MAX)=NULL,@msg101 VARCHAR(MAX)=NULL,@msg102 VARCHAR(MAX)=NULL,@msg103 VARCHAR(MAX)=NULL,@msg104 VARCHAR(MAX)=NULL,@msg105 VARCHAR(MAX)=NULL,@msg106 VARCHAR(MAX)=NULL,@msg107 VARCHAR(MAX)=NULL,@msg108 VARCHAR(MAX)=NULL,@msg109 VARCHAR(MAX)=NULL
,@msg110 VARCHAR(MAX)=NULL,@msg111 VARCHAR(MAX)=NULL,@msg112 VARCHAR(MAX)=NULL,@msg113 VARCHAR(MAX)=NULL,@msg114 VARCHAR(MAX)=NULL,@msg115 VARCHAR(MAX)=NULL,@msg116 VARCHAR(MAX)=NULL,@msg117 VARCHAR(MAX)=NULL,@msg118 VARCHAR(MAX)=NULL,@msg119 VARCHAR(MAX)=NULL
,@msg120 VARCHAR(MAX)=NULL,@msg121 VARCHAR(MAX)=NULL,@msg122 VARCHAR(MAX)=NULL,@msg123 VARCHAR(MAX)=NULL,@msg124 VARCHAR(MAX)=NULL,@msg125 VARCHAR(MAX)=NULL,@msg126 VARCHAR(MAX)=NULL,@msg127 VARCHAR(MAX)=NULL,@msg128 VARCHAR(MAX)=NULL,@msg129 VARCHAR(MAX)=NULL
,@msg130 VARCHAR(MAX)=NULL,@msg131 VARCHAR(MAX)=NULL,@msg132 VARCHAR(MAX)=NULL,@msg133 VARCHAR(MAX)=NULL,@msg134 VARCHAR(MAX)=NULL,@msg135 VARCHAR(MAX)=NULL,@msg136 VARCHAR(MAX)=NULL,@msg137 VARCHAR(MAX)=NULL,@msg138 VARCHAR(MAX)=NULL,@msg139 VARCHAR(MAX)=NULL
,@msg140 VARCHAR(MAX)=NULL,@msg141 VARCHAR(MAX)=NULL,@msg142 VARCHAR(MAX)=NULL,@msg143 VARCHAR(MAX)=NULL,@msg144 VARCHAR(MAX)=NULL,@msg145 VARCHAR(MAX)=NULL,@msg146 VARCHAR(MAX)=NULL,@msg147 VARCHAR(MAX)=NULL,@msg148 VARCHAR(MAX)=NULL,@msg149 VARCHAR(MAX)=NULL
,@msg150 VARCHAR(MAX)=NULL,@msg151 VARCHAR(MAX)=NULL,@msg152 VARCHAR(MAX)=NULL,@msg153 VARCHAR(MAX)=NULL,@msg154 VARCHAR(MAX)=NULL,@msg155 VARCHAR(MAX)=NULL,@msg156 VARCHAR(MAX)=NULL,@msg157 VARCHAR(MAX)=NULL,@msg158 VARCHAR(MAX)=NULL,@msg159 VARCHAR(MAX)=NULL
,@msg160 VARCHAR(MAX)=NULL,@msg161 VARCHAR(MAX)=NULL,@msg162 VARCHAR(MAX)=NULL,@msg163 VARCHAR(MAX)=NULL,@msg164 VARCHAR(MAX)=NULL,@msg165 VARCHAR(MAX)=NULL,@msg166 VARCHAR(MAX)=NULL,@msg167 VARCHAR(MAX)=NULL,@msg168 VARCHAR(MAX)=NULL,@msg169 VARCHAR(MAX)=NULL
,@msg170 VARCHAR(MAX)=NULL,@msg171 VARCHAR(MAX)=NULL,@msg172 VARCHAR(MAX)=NULL,@msg173 VARCHAR(MAX)=NULL,@msg174 VARCHAR(MAX)=NULL,@msg175 VARCHAR(MAX)=NULL,@msg176 VARCHAR(MAX)=NULL,@msg177 VARCHAR(MAX)=NULL,@msg178 VARCHAR(MAX)=NULL,@msg179 VARCHAR(MAX)=NULL
,@msg180 VARCHAR(MAX)=NULL,@msg181 VARCHAR(MAX)=NULL,@msg182 VARCHAR(MAX)=NULL,@msg183 VARCHAR(MAX)=NULL,@msg184 VARCHAR(MAX)=NULL,@msg185 VARCHAR(MAX)=NULL,@msg186 VARCHAR(MAX)=NULL,@msg187 VARCHAR(MAX)=NULL,@msg188 VARCHAR(MAX)=NULL,@msg189 VARCHAR(MAX)=NULL
,@msg190 VARCHAR(MAX)=NULL,@msg191 VARCHAR(MAX)=NULL,@msg192 VARCHAR(MAX)=NULL,@msg193 VARCHAR(MAX)=NULL,@msg194 VARCHAR(MAX)=NULL,@msg195 VARCHAR(MAX)=NULL,@msg196 VARCHAR(MAX)=NULL,@msg197 VARCHAR(MAX)=NULL,@msg198 VARCHAR(MAX)=NULL,@msg199 VARCHAR(MAX)=NULL
,@msg200 VARCHAR(MAX)=NULL,@msg201 VARCHAR(MAX)=NULL,@msg202 VARCHAR(MAX)=NULL,@msg203 VARCHAR(MAX)=NULL,@msg204 VARCHAR(MAX)=NULL,@msg205 VARCHAR(MAX)=NULL,@msg206 VARCHAR(MAX)=NULL,@msg207 VARCHAR(MAX)=NULL,@msg208 VARCHAR(MAX)=NULL,@msg209 VARCHAR(MAX)=NULL
,@msg210 VARCHAR(MAX)=NULL,@msg211 VARCHAR(MAX)=NULL,@msg212 VARCHAR(MAX)=NULL,@msg213 VARCHAR(MAX)=NULL,@msg214 VARCHAR(MAX)=NULL,@msg215 VARCHAR(MAX)=NULL,@msg216 VARCHAR(MAX)=NULL,@msg217 VARCHAR(MAX)=NULL,@msg218 VARCHAR(MAX)=NULL,@msg219 VARCHAR(MAX)=NULL
,@msg220 VARCHAR(MAX)=NULL,@msg221 VARCHAR(MAX)=NULL,@msg222 VARCHAR(MAX)=NULL,@msg223 VARCHAR(MAX)=NULL,@msg224 VARCHAR(MAX)=NULL,@msg225 VARCHAR(MAX)=NULL,@msg226 VARCHAR(MAX)=NULL,@msg227 VARCHAR(MAX)=NULL,@msg228 VARCHAR(MAX)=NULL,@msg229 VARCHAR(MAX)=NULL
,@msg230 VARCHAR(MAX)=NULL,@msg231 VARCHAR(MAX)=NULL,@msg232 VARCHAR(MAX)=NULL,@msg233 VARCHAR(MAX)=NULL,@msg234 VARCHAR(MAX)=NULL,@msg235 VARCHAR(MAX)=NULL,@msg236 VARCHAR(MAX)=NULL,@msg237 VARCHAR(MAX)=NULL,@msg238 VARCHAR(MAX)=NULL,@msg239 VARCHAR(MAX)=NULL
,@msg240 VARCHAR(MAX)=NULL,@msg241 VARCHAR(MAX)=NULL,@msg242 VARCHAR(MAX)=NULL,@msg243 VARCHAR(MAX)=NULL,@msg244 VARCHAR(MAX)=NULL,@msg245 VARCHAR(MAX)=NULL,@msg246 VARCHAR(MAX)=NULL,@msg247 VARCHAR(MAX)=NULL,@msg248 VARCHAR(MAX)=NULL,@msg249 VARCHAR(MAX)=NULL
,@row_count INT = NULL
AS
BEGIN
   DECLARE
       @fnThis          VARCHAR(35) = 'sp_log'
      ,@min_log_level   INT
      ,@lvl_msg         VARCHAR(MAX)
      ,@log_msg         VARCHAR(4000)
      ,@row_count_str   VARCHAR(30) = NULL

   SET NOCOUNT ON
   SET @min_log_level = COALESCE(dbo.fnGetSessionContextAsInt(N'LOG_LEVEL'), 1); -- Default: INFO

   SET @lvl_msg = 
   CASE
      WHEN @level = 0 THEN 'DEBUG'
      WHEN @level = 1 THEN 'INFO '
      WHEN @level = 2 THEN 'NOTE '
      WHEN @level = 3 THEN 'WARN '
      WHEN @level = 4 THEN 'ERROR'
      ELSE '???? '
   END;

   SET @fn= dbo.fnPadRight(@fn, 30);

   IF @row_count IS NOT NULL SET @row_count_str = CONCAT(' rowcount: ', @row_count)

   SET @log_msg = CONCAT
   (
       @msg00 ,@msg01 ,@msg02 ,@msg03, @msg04, @msg05, @msg06 ,@msg07 ,@msg08 ,@msg09 
      ,@msg10 ,@msg11 ,@msg12 ,@msg13, @msg14, @msg15, @msg16 ,@msg17 ,@msg18 ,@msg19
      ,@msg20 ,@msg21 ,@msg22 ,@msg23, @msg24, @msg25, @msg26 ,@msg27 ,@msg28 ,@msg29
      ,@msg30 ,@msg31 ,@msg32 ,@msg33, @msg34, @msg35, @msg36 ,@msg37 ,@msg38 ,@msg39
      ,@msg40 ,@msg41 ,@msg42 ,@msg43, @msg44, @msg45, @msg46 ,@msg47 ,@msg48 ,@msg49
      ,@msg50 ,@msg51 ,@msg52 ,@msg53, @msg54, @msg55, @msg56 ,@msg57 ,@msg58 ,@msg59
      ,@msg60 ,@msg61 ,@msg62 ,@msg63, @msg64, @msg65, @msg66 ,@msg67 ,@msg68 ,@msg69
      ,@msg70 ,@msg71 ,@msg72 ,@msg73, @msg74, @msg75, @msg76 ,@msg77 ,@msg78 ,@msg79
      ,@msg80 ,@msg81 ,@msg82 ,@msg83, @msg84, @msg85, @msg86 ,@msg87 ,@msg88 ,@msg89
      ,@msg90 ,@msg91 ,@msg92 ,@msg93, @msg94, @msg95, @msg96 ,@msg97 ,@msg98 ,@msg99
      ,@msg100,@msg101,@msg102,@msg103,@msg104,@msg105,@msg106,@msg107,@msg108,@msg109 
      ,@msg110,@msg111,@msg112,@msg113,@msg114,@msg115,@msg116,@msg117,@msg118,@msg119 
      ,@msg120,@msg121,@msg122,@msg123,@msg124,@msg125,@msg126,@msg127,@msg128,@msg129 
      ,@msg130,@msg131,@msg132,@msg133,@msg134,@msg135,@msg136,@msg137,@msg138,@msg139 
      ,@msg140,@msg141,@msg142,@msg143,@msg144,@msg145,@msg146,@msg147,@msg148,@msg149 
      ,@msg150,@msg151,@msg152,@msg153,@msg154,@msg155,@msg156,@msg157,@msg158,@msg159 
      ,@msg160,@msg161,@msg162,@msg163,@msg164,@msg165,@msg166,@msg167,@msg168,@msg169 
      ,@msg170,@msg171,@msg172,@msg173,@msg174,@msg175,@msg176,@msg177,@msg178,@msg179 
      ,@msg180,@msg181,@msg182,@msg183,@msg184,@msg185,@msg186,@msg187,@msg188,@msg189 
      ,@msg190,@msg191,@msg192,@msg193,@msg194,@msg195,@msg196,@msg197,@msg198,@msg199 
      ,@msg200,@msg201,@msg202,@msg203,@msg204,@msg205,@msg206,@msg207,@msg208,@msg209 
      ,@msg210,@msg211,@msg212,@msg213,@msg214,@msg215,@msg216,@msg217,@msg218,@msg219 
      ,@msg220,@msg221,@msg222,@msg223,@msg224,@msg225,@msg226,@msg227,@msg228,@msg229 
      ,@msg230,@msg231,@msg232,@msg233,@msg234,@msg235,@msg236,@msg237,@msg238,@msg239 
      ,@msg240,@msg241,@msg242,@msg243,@msg244,@msg245,@msg246,@msg247,@msg248,@msg249 
      ,@row_count_str
   );

   -- Always log to log table
   INSERT INTO AppLog (rtn, msg, [level], row_count) VALUES (dbo.fnTrim(@fn), @log_msg, @level, @row_count);

   -- Only display if required
   IF @level >=@min_log_level
   BEGIN
      PRINT CONCAT(@lvl_msg, ' ',@fn, ': ', @log_msg);
   END
END
/*
EXEC tSQLt.RunAll;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ================================================================
-- Author:      Terry Watts
-- Create date: 25-MAR-2020
-- Description: Raises an exception coallescing the error messages
-- with a space between the messages
--
-- Ensures @state is positive
-- if @ex_num < 50000 message and raise to 50K+ @ex_num
-- ================================================================
CREATE PROCEDURE [dbo].[sp_raise_exception]
       @ex_num    INT           = 53000
      ,@msg0      VARCHAR(max)  = NULL
      ,@msg1      VARCHAR(max)  = NULL
      ,@msg2      VARCHAR(max)  = NULL
      ,@msg3      VARCHAR(max)  = NULL
      ,@msg4      VARCHAR(max)  = NULL
      ,@msg5      VARCHAR(max)  = NULL
      ,@msg6      VARCHAR(max)  = NULL
      ,@msg7      VARCHAR(max)  = NULL
      ,@msg8      VARCHAR(max)  = NULL
      ,@msg9      VARCHAR(max)  = NULL
      ,@msg10     VARCHAR(max)  = NULL
      ,@msg11     VARCHAR(max)  = NULL
      ,@msg12     VARCHAR(max)  = NULL
      ,@msg13     VARCHAR(max)  = NULL
      ,@msg14     VARCHAR(max)  = NULL
      ,@msg15     VARCHAR(max)  = NULL
      ,@msg16     VARCHAR(max)  = NULL
      ,@msg17     VARCHAR(max)  = NULL
      ,@msg18     VARCHAR(max)  = NULL
      ,@msg19     VARCHAR(max)  = NULL
      ,@msg20     VARCHAR(max)  = NULL
      ,@fn        VARCHAR(35)   = NULL
AS
BEGIN
   DECLARE
       @fnThis    VARCHAR(35) = 'sp_raise_exception'
      ,@msg       VARCHAR(max)
   ;

   DECLARE @msgs TABLE (txt VARCHAR(MAX));

   INSERT INTO @msgs (txt)
   SELECT TRIM(value)
   FROM (VALUES
       (@msg0), (@msg1), (@msg2), (@msg3), (@msg4),
       (@msg5), (@msg6), (@msg7), (@msg8), (@msg9),
       (@msg10), (@msg11), (@msg12), (@msg13), (@msg14),
       (@msg15), (@msg16), (@msg17), (@msg18), (@msg19), (@msg20)
   ) AS V(value)
   WHERE value IS NOT NULL AND LTRIM(RTRIM(value)) <> '';

   SELECT @msg = STRING_AGG(txt, ' ') FROM @msgs;

   IF @ex_num IS NULL SET @ex_num = 53000; -- default
      EXEC sp_log 4, @fnThis, '000: throwing exception ', @ex_num, ' ', @msg, ' st: 1';

   ------------------------------------------------------------------------------------------------
   -- Validate
   ------------------------------------------------------------------------------------------------
   -- check ex num >= 50000 if not add 50000 to it
   IF @ex_num < 50000
   BEGIN
      SET @ex_num = abs(@ex_num) + 50000;
      EXEC sp_log 3, @fnThis, '010: supplied exception number is too low changing to ', @ex_num;
   END

   ------------------------------------------------------------------------------------------------
   -- Throw the exception
   ------------------------------------------------------------------------------------------------
   ;THROW @ex_num, @msg, 1;
END
/*
EXEC sp_raise_exception 53000, 'test exception msg 1',' msg 2', @state=2, @fn='test_fn'
*/





GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: Raises exception if @a is null or empty
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_not_null_or_empty]
    @val       VARCHAR(3999)
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT             = NULL
   ,@fn        VARCHAR(35)    = '*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE 
       @fnThis    VARCHAR(35) = N'sp_assert_not_null_or_empty'
      ,@valTxt    VARCHAR(20)= @val
   ;

   EXEC sp_log @log_level, @fnThis, '000: starting,' ,@msg1,': @val:[',@val,']';

   IF dbo.fnLen(@val) > 0
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
       IF dbo.fnLen(@valTxt) < 20 SET @valTxt= CONCAT(@valTxt, '   ');
      EXEC sp_log @log_level, @fnThis, '010: OK, ASSERTION: val: [',@valTxt, '] IS NOT NULL';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fn, '020: @val IS NULL OR EMPTY, raising exception';
   IF @ex_num IS NULL SET @ex_num = 50005;
   DECLARE @msg0 VARCHAR(20)= 'val is NULL or empty'

   EXEC sp_raise_exception
       @ex_num = @ex_num
      ,@msg1   = @msg0
      ,@msg2   = @msg1
      ,@msg3   = @msg2
      ,@msg4   = @msg3
      ,@msg5   = @msg4
      ,@msg6   = @msg5
      ,@msg7   = @msg6
      ,@msg8   = @msg7
      ,@msg9   = @msg8
      ,@msg10  = @msg9
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@msg20  = @msg19
      ,@fn     = @fn
      ;
END
/*
EXEC tSQLt.Run 'test.test_049_sp_assert_not_null_or_empty';
EXEC tSQLt.RunAll;
EXEC sp_assert_not_null_or_empty NULL
EXEC sp_assert_not_null_or_empty ''
EXEC sp_assert_not_null_or_empty 'Fred'
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


CREATE   FUNCTION [dbo].[fnMin] (@p1 INT, @p2 INT)
RETURNS INT
AS
BEGIN
   RETURN CASE WHEN @p1 > @p2 THEN @p2 ELSE @p1 END;
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ========================================================================================================
-- Author:      Terry Watts
-- Create date: 28-MAR-2020
-- Description: standard error handling:
--              get the exception message, log messages
--              clear the log cache first
-- NB: this does not throw
--
-- CHANGES
-- 231221: added clear the log cache first
-- 240315: added ex num, ex msg as optional out parmeters
-- 241204: it is possible that ERROR_MESSAGE() or ERROR_NUMBER() are throwing exceptions 
--        -this can happen inside tranactions when low level errors like select * from non existant table
-- 241221: error proc and error line do not always work - for example when executing SQL statements that
--         return a low error number like the following: 207:Invalid column name    
-- ========================================================================================================
CREATE   PROCEDURE [dbo].[sp_log_exception]
       @fn        VARCHAR(35)
      ,@msg01     VARCHAR(4000) = NULL
      ,@msg02     VARCHAR(1000) = NULL
      ,@msg03     VARCHAR(1000) = NULL
      ,@msg04     VARCHAR(1000) = NULL
      ,@msg05     VARCHAR(1000) = NULL
      ,@msg06     VARCHAR(1000) = NULL
      ,@msg07     VARCHAR(1000) = NULL
      ,@msg08     VARCHAR(1000) = NULL
      ,@msg09     VARCHAR(1000) = NULL
      ,@msg10     VARCHAR(1000) = NULL
      ,@msg11     VARCHAR(1000) = NULL
      ,@msg12     VARCHAR(1000) = NULL
      ,@msg13     VARCHAR(1000) = NULL
      ,@msg14     VARCHAR(1000) = NULL
      ,@msg15     VARCHAR(1000) = NULL
      ,@msg16     VARCHAR(1000) = NULL
      ,@msg17     VARCHAR(1000) = NULL
      ,@msg18     VARCHAR(1000) = NULL
      ,@msg19     VARCHAR(1000) = NULL
      ,@ex_num    INT            = NULL OUT
      ,@ex_msg    VARCHAR(500)  = NULL OUT
      ,@ex_proc   VARCHAR(80)   = NULL OUT
      ,@ex_line   VARCHAR(20)   = NULL OUT
AS
BEGIN
   DECLARE 
       @fnThis    VARCHAR(35) = 'sp_log_exception'
      ,@NL        VARCHAR(2)  =  NCHAR(13) + NCHAR(10)
      ,@msg       VARCHAR(500)
      ,@fnHdr     VARCHAR(100)
      ,@isTrans   BIT = 0
      ,@line      VARCHAR(4000)

   SET @ex_num = -1; -- unknown
   SET @msg    = 'UNKNOWN MESSAGE';

   --EXEC sp_log 4, @fnThis, '510: starting';

   SELECT
       @ex_num = ERROR_NUMBER()
      ,@ex_proc= ERROR_PROCEDURE()
      ,@ex_line= CAST(ERROR_LINE() AS VARCHAR(20))
      ,@ex_msg = ERROR_MESSAGE();

   SET @fnHdr = CONCAT(@ex_proc, '(',@ex_line,'): ')

   BEGIN TRY
      SET @msg =
      CONCAT
      (
         '500: caught exception ', @ex_num, ': ', @ex_msg, ' ', 
          @msg01
         ,iif(@msg02 IS NOT NULL, CONCAT(' ', @msg02 ), '')
         ,iif(@msg03 IS NOT NULL, CONCAT(' ', @msg03 ), '')
         ,iif(@msg04 IS NOT NULL, CONCAT(' ', @msg04 ), '')
         ,iif(@msg05 IS NOT NULL, CONCAT(' ', @msg05 ), '')
         ,iif(@msg06 IS NOT NULL, CONCAT(' ', @msg06 ), '')
         ,iif(@msg07 IS NOT NULL, CONCAT(' ', @msg07 ), '')
         ,iif(@msg08 IS NOT NULL, CONCAT(' ', @msg08 ), '')
         ,iif(@msg09 IS NOT NULL, CONCAT(' ', @msg09 ), '')
         ,iif(@msg10 IS NOT NULL, CONCAT(' ', @msg10 ), '')
         ,iif(@msg11 IS NOT NULL, CONCAT(' ', @msg11 ), '')
         ,iif(@msg12 IS NOT NULL, CONCAT(' ', @msg12 ), '')
         ,iif(@msg13 IS NOT NULL, CONCAT(' ', @msg13 ), '')
         ,iif(@msg14 IS NOT NULL, CONCAT(' ', @msg14 ), '')
         ,iif(@msg15 IS NOT NULL, CONCAT(' ', @msg15 ), '')
         ,iif(@msg16 IS NOT NULL, CONCAT(' ', @msg16 ), '')
         ,iif(@msg17 IS NOT NULL, CONCAT(' ', @msg17 ), '')
         ,iif(@msg18 IS NOT NULL, CONCAT(' ', @msg18 ), '')
         ,iif(@msg19 IS NOT NULL, CONCAT(' ', @msg19 ), '')
      );

      SET @line = REPLICATE('*', dbo.fnMin(300, dbo.fnLen(@msg)+46));

      PRINT CONCAT(@nl, @line);
      EXEC sp_log 4, @fnHdr, @msg;
      PRINT CONCAT(@line, @nl);
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fnThis, '590: failed. exception was: ', @ex_num, ': ', @ex_msg;
      SET @ex_num = ERROR_NUMBER();
      SET @ex_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fnThis,  '580: sp_log failed, exception: ',@ex_num, ': @ex_msg';
      SET @ex_msg ='*** system error: failed to get error msg ***';
   END CATCH
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from the right end of a string
-- =============================================
CREATE   FUNCTION [dbo].[fnRTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   IF @str IS NOT NULL AND @trim_chr IS NOT NULL
      WHILE Right(@str, 1)= @trim_chr AND dbo.fnLen(@str) > 0
         SET @str = Left(@str, dbo.fnLen(@str)-1);

   RETURN @str
END
/*
PRINT CONCAT('[',  dbo.fnRTrim2('  ', ' '), ']');
PRINT CONCAT('[',  dbo.fnRTrim2(' ', ' '), ']');
PRINT CONCAT('[',  dbo.fnRTrim2('', ' '), ']');
PRINT CONCAT('[', Right('', 1), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' s 5   ', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' ', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2('', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(NULL, ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' ', NULL), ']
PRINT CONCAT('[', dbo.fnRTrim2('', NULL), ']');
IF dbo.fnRTrim2(NULL, NULL) IS NULL PRINT 'IS NULL';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from 
--              the beginning end of a string
-- =============================================
CREATE   FUNCTION [dbo].[fnLTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE @len INT;

   IF @str IS NOT NULL AND @trim_chr IS NOT NULL
      WHILE Left(@str, 1) = @trim_chr
      BEGIN
         SET @len = dbo.fnLen(@str)-1;

         IF @len < 0
            BREAK;

         SET @str = Substring(@str, 2, dbo.fnLen(@str)-1);
      END

   RETURN @str
END

/*
PRINT CONCAT('1: [',  dbo.fnLTrim2('  ', ' '), ']');
PRINT CONCAT('2: [',  dbo.fnLTrim2(' ', ' '), ']');
PRINT CONCAT('3: [',  dbo.fnLTrim2('', ' '), ']');
PRINT CONCAT('4: [', Right('', 1), ']');
PRINT CONCAT('5: [', dbo.fnLTrim2(' s 5   ', ' '), ']');
PRINT CONCAT('6: [', dbo.fnLTrim2(' ', ' '), ']');
PRINT CONCAT('7: [', dbo.fnLTrim2('', ' '), ']');
PRINT CONCAT('8: [', dbo.fnLTrim2(NULL, ' '), ']');
PRINT CONCAT('9: [', dbo.fnLTrim2(' ', NULL), ']');
PRINT CONCAT('10:[', dbo.fnLTrim2('', NULL), ']');
IF dbo.fnLTrim2(NULL, NULL) IS NULL PRINT 'IS NULL';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from 
--              the beginning end of a string
-- =============================================
CREATE   FUNCTION [dbo].[fnTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   RETURN dbo.fnRTrim2(dbo.fnLTrim2(@str, @trim_chr), @trim_chr);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 15-MAR-2024
-- Description: returns the fixed up range
-- =============================================
CREATE FUNCTION [dbo].[fnFixupXlRange](@range VARCHAR(100))
RETURNS VARCHAR(100)
AS
BEGIN
   SET @range = dbo.fnTrim2(dbo.fnTrim2(@range, '['), ']');

   IF @range IS NULL OR @range='' SET @range = 'Sheet1$';

   IF CHARINDEX('$', @range) = 0
      SET @range = CONCAT( @range, '$');

   SET @range = CONCAT('[', @range, ']');
   RETURN @range;
END
/*
PRINT dbo.fnFixupXlRange(NULL);
PRINT dbo.fnFixupXlRange('');
PRINT dbo.fnFixupXlRange('Sheet1$');
PRINT dbo.fnFixupXlRange('[Sheet1$]');
PRINT dbo.fnFixupXlRange('Call Register');
PRINT dbo.fnFixupXlRange('Call Register$]');
PRINT dbo.fnFixupXlRange('[Call Register$]');
PRINT dbo.fnFixupXlRange('[Call Register$A:B]');
PRINT dbo.fnFixupXlRange('Call Register$A:B]');
PRINT dbo.fnFixupXlRange('[Call Register$A:B');
PRINT dbo.fnFixupXlRange('Call Register$A:B');
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =====================================================================
-- Author:      Terry Watts
-- Create date: 31-OCT-2024
-- Description: determines if @ty is a text datatype
-- e.g. 'VARCHAR' is a text type
-- 
-- PRECONDITIONS: @ty is just the datatype without ()
-- e.g. 'VARCHAR' is OK but 'VARCHAR(20)' the output is undefined
-- =====================================================================
CREATE   FUNCTION [dbo].[fnIsTextType](@ty   VARCHAR(500))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('char','nchar','varchar','nvarchar'), 1, 0);
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_097_fnIsTextType';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================
-- Author:      Terry Watts
-- Create date: 06-NOV-2023
-- Description: lists the columns for the tables
-- =============================================================
CREATE   VIEW [dbo].[list_table_columns_vw]
AS
SELECT TOP 10000 
    TABLE_SCHEMA
   ,TABLE_NAME
   ,COLUMN_NAME
   ,ORDINAL_POSITION
   ,DATA_TYPE
   ,dbo.fnIsTextType(DATA_TYPE) as is_txt
   ,CHARACTER_MAXIMUM_LENGTH
   ,isc.COLLATION_NAME
   ,is_computed
   ,so.[object_id] AS table_oid
   ,so.[type_desc]
   ,so.[type]
FROM [INFORMATION_SCHEMA].[COLUMNS] isc
JOIN sys.objects     so ON so.[name]        = isc.TABLE_NAME
JOIN sys.all_columns sac ON sac.[object_id] =  so.[object_id] AND sac.[name]=isc.column_name
ORDER BY TABLE_NAME, ORDINAL_POSITION;
/*
SELECT CONCAT(column_name) FROM list_table_columns_vw where table_name = 'PathogenStaging' and is_txt = 1;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===============================================================
-- Author:      Terry watts
-- Create date: 30-MAR-2020
-- Description: returns true if the file exists, false otherwise
-- ===============================================================
CREATE FUNCTION [dbo].[fnFileExists](@path varchar(512))
RETURNS BIT
AS
BEGIN
     DECLARE @result INT
     EXEC master.dbo.xp_fileexist @path, @result OUTPUT
     RETURN cast(@result as bit)
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==========================================================================================================
-- Author:      Terry Watts
-- Create date: 28-FEB-2024
-- Description: 
--
-- PRECONDITIONS:
-- PRE 01: @spreadsheet must be specified OR EXCEPTION 58000, 'spreadsheet must be specified'
-- PRE 02: @spreadsheet exists,           OR EXCEPTION 58001, 'spreadsheet does not exist'
-- PRE 03: @range not null or empty       OR EXCEPTION 58002, 'range must be specified'
-- 
-- POSTCONDITIONS:
-- POST01:
--
-- CALLED BY:
-- sp_import_XL_new, sp_import_XL_existing
--
-- TESTS:
--
-- CHANGES:
-- 05-MAR-2024: put brackets around the field names to handle spaces reserved words etc.
-- 05-MAR-2024: added parameter validation
-- ==========================================================================================================
CREATE   PROCEDURE [dbo].[sp_get_flds_frm_hdr_xl]
    @import_file  VARCHAR(500)                 -- include path, and optional range
   ,@range        VARCHAR(100) -- = N'Sheet1$'   -- for XL: like 'Table$' OR 'Table$A:B'
   ,@fields       VARCHAR(4000) OUT            -- comma separated list
AS
BEGIN
   DECLARE 
    @fn           VARCHAR(35)   = N'GET_FLDS_FRM_HDR_XL'
   ,@cmd          NVARCHAR(4000)
   ,@n            INT

   EXEC sp_log 1, @fn, '000: starting, 
@import_file:  [', @import_file,']
@range:        [', @range,']
@fields:       [', @fields,']
';

   BEGIN TRY
      -------------------------------------------------------
      -- Param validation, fixup
      -------------------------------------------------------
      SET @n = charindex('!', @import_file, 0);
      IF( @n > 0)
      BEGIN
         SET @range = SUBSTRING(@import_file, @n+1, 100);
         SET @import_file = SUBSTRING(@import_file,1, @n-1);
      END

      -- soert out []$ etc.
      SET @range = dbo.fnFixupXlRange(@range);

      --------------------------------------------------------------------------------------------------------
      -- PRE 01: @spreadsheet must be specified OR EXCEPTION 58000, 'spreadsheet must be specified'
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '010: checking PRE 01,. @range: [',@range,']';
      EXEC sp_assert_not_null_or_empty @import_file, 'spreadsheetfile  must be specified', @ex_num=58000--, @fn=@fn;

      --------------------------------------------------------------------------------------------------------
      -- PRE 02: @spreadsheet exists,           OR EXCEPTION 58001, 'spreadsheet does not exist'
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: checking PRE 02';

      IF dbo.fnFileExists(@import_file) = 0 
         EXEC sp_raise_exception 58001, @import_file, ' does not exist'--, @fn=@fn

      --------------------------------------------------------------------------------------------------------
      -- PRE 03: @range not null or empty       OR EXCEPTION 58002, 'range must be specified'
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '025: checking PRE 03';
      EXEC sp_assert_not_null_or_empty @range, 'range must be specified', @ex_num=58002--, @fn=@fn;

      -------------------------------------------------------
      -- ASSERTION: Passed parameter validation
      -------------------------------------------------------
      EXEC sp_log 1, @fn, '030: Passed parameter validation';

      -------------------------------------------------------
      -- Process
      -------------------------------------------------------
      EXEC sp_log 1, @fn, '040: processing';
      DROP TABLE IF EXISTS temp;

      -- IMEX=1 treats everything as text
      SET @cmd = 
         CONCAT
         (
      'SELECT * INTO temp 
      FROM OPENROWSET
      (
          ''Microsoft.ACE.OLEDB.12.0''
         ,''Excel 12.0;IMEX=1;HDR=NO;Database='
         ,@import_file,';''
         ,''SELECT TOP 2 * FROM ',@range,'''
      )'
         );

      EXEC sp_log 1, @fn, '050: open rowset sql:
   ', @cmd;

      EXEC(@cmd);
      SELECT @fields = string_agg(CONCAT('concat (''['',','', column_name, ','']''',')'), ','','',') FROM list_table_columns_vw WHERE TABLE_NAME = 'temp';
      SELECT @cmd = CONCAT('SET @fields = (SELECT TOP 1 CONCAT(',@fields, ') FROM [temp])');
      EXEC sp_log 1, @fn, '060: get fields sql:
   ', @cmd;

      EXEC sp_executesql @cmd, N'@fields VARCHAR(4000) OUT', @fields OUT;
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      EXEC sp_log 4, @fn, '500: parameters, 
import_file:  [', @import_file,']
range:        [', @range,']'
;
      THROW
   END CATCH
   EXEC sp_log 1, @fn, '99: leaving, OK';
END
/*
DECLARE @fields VARCHAR(MAX);
EXEC sp_get_fields_from_xl_hdr 'D:\Dev\Repos\Farming\Data\Distributors.xlsx!Distributors$A:H', @fields OUT;
PRINT @fields;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =========================================================
-- Author:      Terry Watts
-- Create date: 06-DEc-2024
-- Description: compares 2 SQL_VARIANTs
-- RULES:
-- R01: if a < b return 1, 0 otherwise
-- R02: if types are same then a normal comparison should be used
-- R03: NULL < NULL returns 0
-- R04: NULL < NON NULL returns 1
-- R05: NON NULL < NULL returns 0
-- R06: different types try to convert to strings and then compare
--
-- Postconditions
-- Post 01: if a < b return 1
-- Post 02: if types are same then a normal comparison should be used
-- Post 03: NULL < NULL returns 0
-- Post 04: NULL < NON NULL returns 1
-- Post 05: NON NULL < NULL returns 0
-- Post 06: different types try to convert to strings and then compare
-- =========================================================
CREATE FUNCTION [dbo].[fnIsLessThan]( @a SQL_VARIANT, @b SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   DECLARE 
       @aTxt   VARCHAR(4000)
      ,@bTxt   VARCHAR(4000)
      ,@typeA  VARCHAR(50)
      ,@typeB  VARCHAR(50)
      ,@ret    BIT
      ,@res    INT

   ------------------------------------------------------
   -- Handle Null NULL
   ------------------------------------------------------
   IF @a IS NULL AND @b IS NULL RETURN 0;

   ------------------------------------------------------
   -- Handle Null not NULL scenarios
   ------------------------------------------------------
   IF @a IS NULL AND @b IS NOT NULL RETURN 1;
   IF @a IS NOT NULL AND @a IS NULL RETURN 0;

   ------------------------------------------------------
   -- ASSERTION: Both a and b are not NULL
   ------------------------------------------------------

   ------------------------------------------------------
   -- Handle different types
   ------------------------------------------------------
   SELECT @typeA = CONVERT(VARCHAR(500),SQL_VARIANT_PROPERTY(@a, 'BaseType'))
         ,@typeB = CONVERT(VARCHAR(500),SQL_VARIANT_PROPERTY(@b, 'BaseType'))
    ;

   IF @typeA <> @typeB
   BEGIN
      SELECT @aTxt = CONVERT(VARCHAR(500),@a)
            ,@bTxt = CONVERT(VARCHAR(500),@b);

      RETURN iif(@aTxt < @bTxt, 1, 0);
   END

   ------------------------------------------------------
   -- ASSERTION: Both a and b are the same type
   ------------------------------------------------------

   ------------------------------------------------------
   -- Handle types where the variant < operator
   -- does not return correct value
   ------------------------------------------------------

   ------------------------------------------------------
   -- Handle general case where variant < operator works
   ------------------------------------------------------

   RETURN iif(@a<@b, 1, 0);
END
/*
EXEC test.test_054_fnIsLT
EXEC tSQLt.Run 'test.test_054_fnIsLT';
EXEC tSQLt.RunAll;
PRINT DB_Name()

   DECLARE 
       @a      SQL_VARIANT = 2
      ,@b      SQL_VARIANT = '2'
      ,@aTxt   VARCHAR(4000) = CONVERT(VARCHAR(500),@a)
      ,@bTxt   VARCHAR(4000) = CONVERT(VARCHAR(500),@b)
      ;
   PRINT iif(@a<@b, 1, 0);

   DECLARE 
       @a      SQL_VARIANT =  2
      ,@b      SQL_VARIANT = 'abc'
      ,@aTxt   VARCHAR(4000)
      ,@bTxt   VARCHAR(4000)
      ;

   SELECT @aTxt = CONVERT(VARCHAR(500),@a)
         ,@bTxt = CONVERT(VARCHAR(500),@b)

   PRINT iif(@a<@b, 1, 0);
   PRINT iif(@b<@a, 1, 0);
   PRINT iif(@aTxt<@bTxt, 1, 0);
   PRINT iif(@bTxt<@aTxt, 1, 0);
   PRINT CONCAT('[',@aTxt, ']');
   PRINT CONCAT('[',@bTxt, ']');
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: asserts that a is greater than b
--              raises an exception if not
-- =============================================
CREATE   PROCEDURE [dbo].[sp_assert_gtr_than]
       @a         SQL_VARIANT
      ,@b         SQL_VARIANT
      ,@msg       VARCHAR(200)  = NULL
      ,@msg2      VARCHAR(200)  = NULL
      ,@msg3      VARCHAR(200)  = NULL
      ,@msg4      VARCHAR(200)  = NULL
      ,@msg5      VARCHAR(200)  = NULL
      ,@msg6      VARCHAR(200)  = NULL
      ,@msg7      VARCHAR(200)  = NULL
      ,@msg8      VARCHAR(200)  = NULL
      ,@msg9      VARCHAR(200)  = NULL
      ,@msg10     VARCHAR(200)  = NULL
      ,@msg11     VARCHAR(200)  = NULL
      ,@msg12     VARCHAR(200)  = NULL
      ,@msg13     VARCHAR(200)  = NULL
      ,@msg14     VARCHAR(200)  = NULL
      ,@msg15     VARCHAR(200)  = NULL
      ,@msg16     VARCHAR(200)  = NULL
      ,@msg17     VARCHAR(200)  = NULL
      ,@msg18     VARCHAR(200)  = NULL
      ,@msg19     VARCHAR(200)  = NULL
      ,@msg20     VARCHAR(200)  = NULL
      ,@ex_num    INT            = 53502
      ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE
       @fnThis VARCHAR(35) = 'sp_assert_gtr_than'
      ,@aTxt   VARCHAR(100)= CONVERT(VARCHAR(100), @a)
      ,@bTxt   VARCHAR(100)= CONVERT(VARCHAR(100), @b)

   EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';

   -- a>b -> b<a 
   IF dbo.fnIsLessThan(@b ,@a) = 1
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, @a:[',@aTxt, '] IS GTR THN @b:[', @bTxt, ']';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fnThis, '020: [',@aTxt, '] IS GTR THN [', @bTxt, '] IS FALSE, raising exception';

   EXEC sp_raise_exception
          @msg1   = @msg
         ,@msg2   = @msg2
         ,@msg3   = @msg3
         ,@msg4   = @msg4
         ,@msg5   = @msg5
         ,@msg6   = @msg6
         ,@msg7   = @msg7
         ,@msg8   = @msg8
         ,@msg9   = @msg9
         ,@msg10  = @msg10
         ,@msg11  = @msg11
         ,@msg12  = @msg12
         ,@msg13  = @msg13
         ,@msg14  = @msg14
         ,@msg15  = @msg15
         ,@msg16  = @msg16
         ,@msg17  = @msg17
         ,@msg18  = @msg18
         ,@msg19  = @msg19
         ,@msg20  = @msg20
         ,@ex_num = @ex_num
         ,@fn     = @fn
   ;
END
/*
EXEC sp_assert_gtr_than 4, 5;
EXEC sp_assert_gtr_than 5, 4;
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_055_sp_assert_gtr_than';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================================================================
-- Author:      Terry Watts
-- Create date: 25-FEB-2024
-- Description: Creates the SQL to read data from an Excel file
--
-- Changes:
-- 08-MAR-2024: increased @spreadsheet_file parameter len from 60 to 500 as the file path was being truncated
-- =============================================================================================================
CREATE   FUNCTION [dbo].[fnCrtOpenRowsetSqlForXlsx]
(
    @table              VARCHAR(60)
   ,@fields             VARCHAR(MAX)  -- comma sep field string
   ,@spreadsheet_file   VARCHAR(500)
   ,@range              VARCHAR(120)  -- like 'Corrections_221008$A:P' OR 'Corrections_221008$'
   ,@new                BIT
)
RETURNS VARCHAR(MAX)
AS
BEGIN
   DECLARE
    @cmd                VARCHAR(MAX)
   ,@nl                 NCHAR(2)=NCHAR(13)+NCHar(10);

   -- New table: select fields into table   , existing table: insert into table (fields)   
   IF @new = 1 SET @cmd = CONCAT('SELECT ', @fields, ' INTO [', @table, ']')
   ELSE        SET @cmd = CONCAT('INSERT INTO [', @table,'] (', @fields, ')', @nl,'SELECT ', @fields);

   -- Fixup the range ensure [] and $
   SET @range = dbo.fnFixupXlRange(@range);

   SET @cmd = CONCAT(@cmd, '
FROM OPENROWSET
(
    ''Microsoft.ACE.OLEDB.12.0''
   ,''Excel 12.0;HDR=YES;Database='
   ,@spreadsheet_file,';''
   ,''SELECT * FROM ',@range,'''
)'
   );

   RETURN @cmd;
END
/*
PRINT dbo.fnCrtOpenRowsetSqlForXlsx(
 'ImportCorrectionsStaging'
,'id,command,search_clause,search_clause_cont,not_clause,replace_clause, case_sensitive, Latin_name, common_name, local_name, alt_names, note_clause, crops, doit, must_update, comments'
,'D:\Dev\Repos\Farming\Data\ImportCorrections 221018 230816-2000.xlsx'
,'Sheet1$:A:S'
,0
);
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===========================================================
-- Author:      Terry Watts
-- Create date: 31-JAN-2024
-- Description: imports an Excel sheet into an existing table
-- returns the row count [optional]
-- 
-- Postconditions:
-- POST01: IF @expect_rows set then expect at least 1 row to be imported or EXCEPTION 56500 'expected some rows to be imported'
--
-- Changes:
-- 05-MAR-2024: parameter changes: made fields optional; swopped @table and @fields order
-- 08-MAR-2024: added @expect_rows parameter defult = yes(1)
-- ===========================================================
CREATE   PROCEDURE [dbo].[sp_import_XL_existing]
(
    @import_file  VARCHAR(500)              -- include path, (and range if XL)
   ,@range        VARCHAR(100)              -- like 'Corrections_221008$A:P' OR 'Corrections_221008$'
   ,@table        VARCHAR(60)               -- existing table
   ,@clr_first    BIT            = 1         -- if 1 then delete the table contets first
   ,@fields       VARCHAR(4000)  = NULL      -- comma separated list
   ,@expect_rows  BIT            = 1
   ,@row_cnt      INT            = NULL  OUT -- optional rowcount of imported rows
   ,@start_row    INT            = NULL
   ,@end_row      INT            = NULL
)
AS
BEGIN
   DECLARE 
    @fn           VARCHAR(35)   = N'sp_import_XL_existing'
   ,@cmd          VARCHAR(4000)

   EXEC sp_log 1, @fn,'005: starting
import_file:[', @import_file,']
range      :[', @range      ,']
table      :[', @table      ,']
clr_first  :[', @clr_first  ,']
fields     :[', @fields     ,']
expect_rows:[', @expect_rows,']
start_row  :[', @start_row  ,']
end_row    :[', @end_row    ,']'
;

   ----------------------------------------------------------------------------------
   -- Process
   ----------------------------------------------------------------------------------
   BEGIN TRY
      IF @clr_first = 1
      BEGIN
         EXEC sp_log 1, @fn,'010: clearing data from table';
         SET @cmd = CONCAT('DELETE FROM [', @table,']');
         EXEC( @cmd)
      END
      EXEC sp_log 1, @fn,'007';

      IF @fields IS NULL
      BEGIN
         EXEC sp_log 1, @fn,'010: getting fields from XL hdr';
         IF @fields IS NULL 
            EXEC sp_get_flds_frm_hdr_xl @import_file, @fields OUT, @range; -- , @range
      END

      EXEC sp_log 1, @fn,'015: importing data';
      SET @cmd = dbo.fnCrtOpenRowsetSqlForXlsx(@table, @fields, @import_file, @range, 0);
      EXEC sp_log 1, @fn, '020 open rowset sql:
', @cmd;

      EXEC( @cmd);
      SET @row_cnt = @@rowcount;
      EXEC sp_log 1, @fn, '22: imported ', @row_cnt,' rows';

      ----------------------------------------------------------------------------------
      -- Check post conditions
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'025: Checking post conditions';
      IF @expect_rows = 1 EXEC sp_assert_gtr_than @row_cnt, 0, 'expected some rows to be imported';--, @fn=@fn;

      ----------------------------------------------------------------------------------
      -- Processing complete
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '950: processing complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: caught exception';
      EXEC sp_log_exception @fn;
      EXEC sp_log 4, @fn, '510:';
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving OK, imported ', @row_cnt,' rows';
END
/*
EXEC tSQLt.Run 'test.test_010_sp_import_TypeStaging';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===========================================================================================
-- Author:      Terry Watts
-- Create date: 31-JAN-2024
-- Description: Excel sheet importer into a new table
-- returns the row count [optional]
-- 
-- Postconditions:
-- POST01: IF @expect_rows set then expect at least 1 row to be imported or EXCEPTION 56500 'expected some rows to be imported'
--
-- Changes:
-- 05-MAR-2024: parameter changes: made fields optional; swopped @table and @fields order
-- 08-MAR-2024: added @expect_rows parameter defult = yes(1)
-- ===========================================================================================
CREATE   PROCEDURE [dbo].[sp_import_XL_new]
(
    @import_file  VARCHAR(400)        -- path to xls
   ,@range        VARCHAR(100)        -- like 'Corrections_221008$A:P' OR 'Corrections_221008$'
   ,@table        VARCHAR(60)         -- new table
   ,@fields       VARCHAR(4000) = NULL-- comma separated list
   ,@row_cnt      INT            = NULL  OUT -- optional rowcount of imported rows
   ,@expect_rows  BIT            = 1
   ,@start_row    INT            = NULL
   ,@end_row      INT            = NULL
)
AS
BEGIN
   DECLARE 
    @fn           VARCHAR(35)   = N'IMPRT_XL_NEW'
   ,@cmd          VARCHAR(4000)

   EXEC sp_log 2, @fn,'000: starting:
@import_file:[', @import_file, ']
@range      :[', @range, ']
@table      :[', @table, ']
@fields     :[', @fields, ']
@start_row  :[', @start_row,']
@end_row    :[', @end_row  ,']'
;

   SET @cmd = CONCAT('DROP table if exists [', @table, ']');
   EXEC( @cmd)

   IF @fields IS NULL EXEC sp_get_flds_frm_hdr_xl @import_file, @range, @fields OUT; -- , @range

   EXEC sp_log 2, @fn,'010: importing data';
   SET @cmd = ut.dbo.fnCrtOpenRowsetSqlForXlsx(@table, @fields, @import_file, @range, 1);
   EXEC sp_log 2, @fn,'020: import cmd:
', @cmd;
   EXEC( @cmd);

   SET @row_cnt = @@rowcount;
   IF @expect_rows = 1 EXEC sp_assert_gtr_than @row_cnt, 0, 'expected some rows to be imported';

   EXEC sp_log 2, @fn, '999: leaving OK, imported ', @row_cnt,' rows';
END
/*
EXEC dbo.sp_import_XL_new 'D:\Dev\Repos\Farming_Dev\Data\ForeignKeys.xlsx', 'Sheet1$', 'ForeignKeys';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry watts
-- Create date: 30-MAR-2020
-- Description: assert the given file exists or throws exception @ex_num* 'the file[<@file>] does not exist', @state
-- * if @ex_num default: 53200, state=1
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_file_exists]
    @file      VARCHAR(500)
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT             = 53200
   ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE
       @fn_       VARCHAR(35)   = N'ASSERT_FILE_EXISTS'
      ,@msg       VARCHAR(MAX)

   EXEC sp_log @log_level, @fn_, '000: checking file [', @file, '] exists';

   IF dbo.fnFileExists( @file) = 1
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fn, '010: OK,File [',@file,'] exists';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   SET @msg = CONCAT('File [',@file,'] does not exist');
   EXEC sp_log 3, @fn, '020:', @msg, ' raising exception';

   EXEC sp_raise_exception
       @ex_num = @ex_num
      ,@msg1   = @msg
      ,@msg2   = @msg1
      ,@msg3   = @msg2 
      ,@msg4   = @msg3 
      ,@msg5   = @msg4 
      ,@msg6   = @msg5 
      ,@msg7   = @msg6 
      ,@msg8   = @msg7 
      ,@msg9   = @msg8 
      ,@msg10  = @msg9 
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@msg20  = @msg19
      ,@fn     = @fn
   ;
END
/*
EXEC sp_assert_file_exists 'non existant file', ' second msg',@fn='test fn', @state=5  -- expect ex: 53200, 'the file [non existant file] does not exist', ' extra detail: none', @state=1, @fn='test fn';
EXEC sp_assert_file_exists 'C:\bin\grep.exe'   -- expect OK
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================================================
-- Author:      Terry Watts
-- Create date: 19-Sep-2024
--
-- Description: Gets the file extension from the supplied file path 
--              without the dot prefix
--
-- Tests:
--
-- CHANGES:
-- 240919: made return null if no extension - not '' as is the case with split fn
-- =================================================================================
CREATE   FUNCTION [dbo].[fnGetFileExtension](@path VARCHAR(MAX))
RETURNS VARCHAR(200)
AS
BEGIN
   DECLARE
    @t TABLE
    (
       id int IDENTITY(1,1) NOT NULL
      ,val VARCHAR(200)
    );

   DECLARE
       @val VARCHAR(4000)
      ,@ndx INT = -1

   INSERT INTO @t(val)
   SELECT value from string_split(@path,'.'); -- ASCII 92 = Backslash
   SET @val = (SELECT TOP 1 val FROM @t ORDER BY id DESC);

   IF dbo.fnLen(@val) = 0 SET @val = NULL;

   RETURN @val;
END
/*
-- For tests see test.test_092_fnGetFileExtension
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==========================================================================================================
-- Author:      Terry Watts
-- Create date: 15-MAR-2024
-- Description: gets the fields from the first row of a tsv file and returns as csl in the @fields out param
--
-- PRECONDITIONS:
-- PRE 01: @file_path must be specified   OR EXCEPTION 58000, 'file must be specified'
-- PRE 02: @file_path exists,             OR EXCEPTION 58001, 'file does not exist'
-- 
-- POSTCONDITIONS:
-- POST01: returns @file_type =
--          1    if tsv file
--          0    if csv file
--          NULL if undecided (when file has only 1 column)
--
-- CALLED BY: sp_get_get_hdr_flds
--
-- TESTS: test.test_sp_get_fields_from_tsv_hdr
--
-- CHANGES:
-- 05-MAR-2024: put brackets around the field names to handle spaces reserved words etc.
-- 05-MAR-2024: added parameter validation
-- 14-NOV-2024: changed the rtn name from s_get_fields_from_tsv_hdr to [sp_get_fields_from_txt_file_hdr
-- 02-DEC-2024: handling csv or tsv files, optionaly displaying the header,
--              returning the file type 0: txt, 1: tsv
-- ==========================================================================================================
CREATE PROCEDURE [dbo].[sp_get_flds_frm_hdr_txt]
    @file            VARCHAR(500)        -- include path
   ,@fields          VARCHAR(2000) OUT   -- comma separated list
   ,@display_tables  BIT = 0
   ,@file_type       BIT OUT -- 0:txt, 1: tsv
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)   = N'sp_get_flds_frm_hdr_txt'
      ,@cmd       VARCHAR(4000)
      ,@msg       VARCHAR(100)
      ,@row_cnt   INT
      ,@tab_cnt   INT            = 0
      ,@comma_cnt INT            = 0

   EXEC sp_log 2, @fn, '000: starting:
file          :[', @file,']
fields        :[',@fields        ,']
display_tables:[',@display_tables,']
';

   BEGIN TRY
      SET @file_type = NULL -- initially
      -------------------------------------------------------
      -- Param validation, fixup
      -------------------------------------------------------
      EXEC sp_log 1, @fn, '010: validating inputs';

      --------------------------------------------------------------------------------------------------------
      -- PRE 01: @file_path must be specified   OR EXCEPTION 58000, 'file must be specified'
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: checking PRE 01';
      EXEC dbo.sp_assert_not_null_or_empty @file, 'file must be specified', @ex_num=58000--, @fn=@fn;

      --------------------------------------------------------------------------------------------------------
      -- PRE 02: @file_path exists,             OR EXCEPTION 58001, 'file does not exist'
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: checking PRE 02: @file_path must exist';
      EXEC sp_assert_file_exists @file, @ex_num = 58001, @fn=@fn;

      -------------------------------------------------------
      -- ASSERTION: Passed parameter validation
      -------------------------------------------------------
      EXEC sp_log 1, @fn, '040: ASSERTION: validation passed';

      -------------------------------------------------------
      -- Process
      -------------------------------------------------------
      EXEC sp_log 1, @fn, '050: importing file hdr row';
      DROP TABLE IF EXISTS hdrCols;

      CREATE TABLE hdrCols
      (fields VARCHAR(MAX));

      ---------------------------------------------------------------
      -- Get the entire header row as 1 column in tmp.fields
      ---------------------------------------------------------------
      SET @cmd = 
         CONCAT
         (
'BULK INSERT [hdrCols] FROM ''', @file, '''
WITH
(
   DATAFILETYPE    = ''Char''
  ,FIRSTROW        = 1
  ,LASTROW         = 1
  ,ERRORFILE       = ''D:\Logs\GET_FLDS_FRM_HDR_TSV.log''
  ,FIELDTERMINATOR = ''\n''
  ,ROWTERMINATOR   = ''\n''
  ,CODEPAGE       = 65001  
);
   ');-- -- CODEPAGE = 1252

      EXEC sp_log 1, @fn, '060:sql: ',@cmd;
      EXEC(@cmd);

      IF @display_tables = 1 SELECT TOP 10 * FROM hdrCols;

      ---------------------------------------------------------------
      -- Tidy the hdr row up
      ---------------------------------------------------------------
      UPDATE hdrCols SET fields = REPLACE(fields, '"','');
      SET @row_cnt = (SELECT COUNT(*) FROM hdrCols);
      EXEC sp_log 1, @fn, '070: @row_cnt: ',@row_cnt;

       ---------------------------------------------------------------
      -- Which is more commas or tabs?
      -- NB: if only 1 column then it does not matter which
      -- but could use the file extension as a guide
      -- csv - comma, tsv: tab, txt ?? could be either
      ---------------------------------------------------------------
      SELECT @tab_cnt   = COUNT(*) FROM hdrCols CROSS APPLY string_split(fields, NCHAR(9)) ;
      SELECT @comma_cnt = COUNT(*) FROM hdrCols CROSS APPLY string_split(fields, ',');
      EXEC sp_log 1, @fn, '080';
      IF ((@tab_cnt = @comma_cnt) AND (@comma_cnt=0))
      BEGIN
      EXEC sp_log 1, @fn, '090';
         DECLARE @ext VARCHAR(10)
         -- implies 1 field so try to get from file extension
         SET @ext = dbo.fnGetFileExtension(@file);
         PRINT @ext;

         SELECT 
             @tab_cnt   = iif(@ext='tsv', 1, 0)
            ,@comma_cnt = iif(@ext='csv', 1, 0) -- .txt can be either - now way then of knowing csv or tsv with 1 col in file
         ;

         EXEC sp_log 3, @fn, '100: file only contains 1 column, so can only deduce from the file ext .tsv or .csv, else will return NULL';
      END

       EXEC sp_log 1, @fn, '110';
     -- Replace tabs with , this works ok with CSVs also
      UPDATE hdrCols SET fields = REPLACE(fields, NCHAR(9), ',');
      SET @fields = (SELECT TOP 1 fields FROM hdrCols);
      EXEC sp_log 1, @fn, '120: fields:[',@fields, ']';
      EXEC sp_assert_gtr_than @row_cnt, 0, 'header row not found (no rows inmported)';

      ---------------------------------------------------------------
      -- SET @file_type       BIT OUT -- 0:txt, 1: tsv, NULL: UNDECIDED
       ---------------------------------------------------------------
     SET @file_type = 
         case
            WHEN (@tab_cnt = @comma_cnt) THEN NULL -- TAB   separated file
            WHEN (@tab_cnt > @comma_cnt) THEN 1    -- COMMA separated file
            ELSE                              0    -- UNDECIDED
         END;

     set @msg       = iif(@file_type = 1, 'tsv', 'csv');

   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      EXEC sp_log 4, @fn, '500: bulk insert command was:
',@cmd;
      DROP TABLE IF EXISTS hdrCols;
      THROW;
   END CATCH

   DROP TABLE IF EXISTS hdrCols;
   EXEC sp_log 2, @fn, '999: leaving, OK, @file_type: ',@msg;
END
/*
EXEC tSQLt.Run 'test.test_020_sp_get_flds_frm_hdr_txt';

-----------------------------------------------------------
DECLARE
    @fields       VARCHAR(4000)
   ,@file_type    BIT
;
EXEC dbo.sp_get_flds_frm_hdr_txt 'D:\Dev\Farming\Data\LRAP-240910.txt', @fields  OUT, @file_type = @file_type, @display_tables=1; -- comma separated list
PRINT @fields;
-----------------------------------------------------------
*/

GO
GO

CREATE TYPE [dbo].[ChkFldsNotNullDataType] AS TABLE(
	[ordinal] [int] NOT NULL,
	[col] [varchar](60) NOT NULL,
	[sql] [varchar](4000) NOT NULL
)

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================
-- Author:      Terry Watts
-- Create date: 24-NOV-2023
--
-- Description: removes square brackets from string
-- in any position in the string
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
--    [ ] brackets removed
--
-- Tests:
-- =============================================
CREATE   FUNCTION [dbo].[fnDeSquareBracket](@s VARCHAR(4000))
RETURNS VARCHAR(4000)
AS
BEGIN
   RETURN REPLACE(REPLACE(@s, '[', ''), ']', '');
END
/*
   EXEC test.sp_crt_tst_rtns 'dbo.fnDeSquareBracket', 69
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


--================================================================================================
-- Author:           Terry Watts
-- Create date:      15-Nov-2024
-- Description: check the supplied columns are not null
--
-- PRECONDITIONS: none
--
-- POSTCONDITIONS:
-- POST 01: returns 0 and no inccurrences in any of the specified fields in the specified table 
-- OR throws exception 56321, msg: 'mandatory field:['<@table?'].'<field> has Null value
--================================================================================================
CREATE   PROCEDURE [dbo].[sp_chk_flds_not_null]
    @table            VARCHAR(60)
   ,@non_null_flds    VARCHAR(1000)= NULL
   ,@display_results  BIT           = 0
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)   = N'sp_chk_flds_not_null'
   ,@max_len_fld  INT
   ,@col          VARCHAR(32)
   ,@msg          VARCHAR(200)
   ,@sql          NVARCHAR(MAX)
   ,@ndx          INT = 1
   ,@end          INT
   ,@nl           NCHAR(2) = NCHAR(13) + NCHAR(10)
   ,@flds         ChkFldsNotNullDataType
    ;

   EXEC sp_log 1, @fn, '000: starting:
table           :[', @table          , ']
non_null_flds   :[', @non_null_flds  , ']
display_results :[', @display_results, ']'
   ;

   IF @non_null_flds IS NULL
      RETURN;

   BEGIN TRY
      SET @sql = CONCAT('SELECT @max_len_fld = MAX(dbo.fnLen(column_name)) FROM list_table_columns_vw WHERE table_name = ''', @table, ''' AND is_txt = 1;');
      EXEC sp_log 0, @fn, '010: getting max field len: @sql:', @sql;
      EXEC sp_executesql @sql, N'@max_len_fld INT OUT', @max_len_fld OUT;
      EXEC sp_log 1, @fn, '020: @max_len_fld: ', @max_len_fld;

      ----------------------------------------------------------------
      -- Create script to run non null chks on a set of fields
      ----------------------------------------------------------------
      EXEC sp_log 1, @fn, '010: Creating script to run non null chks on a set of fields';
      INSERT INTO @flds (ordinal, col, sql) 
      SELECT
          ordinal
         ,value
         ,CONCAT
         (
            'IF EXISTS (SELECT 1 FROM ['
            , @table,'] WHERE ',dbo.fnPadRight( CONCAT('[',value,']'), @max_len_fld+2), ' IS NULL) EXEC sp_raise_exception 56321, ''mandatory field:['
            , @table,'].',dbo.fnPadRight(CONCAT('[',value,'] has Null value'';'), @max_len_fld+20)
         ) as sql
         FROM
         (
            SELECT ordinal, TRIM(dbo.fnDeSquareBracket(value)) as value FROM string_split( @non_null_flds, ',', 1)
         ) X

      IF @display_results = 1 SELECT * FROM @flds;

      ----------------------------------------------------------------
      -- Execute script: run non null chks on each required field
      ----------------------------------------------------------------
      SELECT @end = COUNT(*) FROM @flds;

      WHILE @ndx < = @end
      BEGIN
         SELECT 
             @sql = sql
            ,@col = col
         FROM @flds
         WHERE ordinal = @ndx;

         SET @msg = CONCAT('030: checking col: ', dbo.fnPadRight( CONCAT( '[', @col, ']'), @max_len_fld +1), ' has no NULL values');
         SET @msg = CONCAT('040: check sql: ', @sql);
         EXEC sp_log 1, @fn, @msg;
         EXEC (@sql);
         SET @ndx = @ndx + 1
      END
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, 'ordinal: ', ordinal, ' @sql: ', @nl, @sql;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: there are no null values in the checked columns';
END
/*
EXEC tSQLt.Run 'test.test_030_sp_chk_flds_not_null';
SELECT * FROM @flds
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

--===========================================================
-- Author:      Terry watts
-- Create date: 18-MAY-2020
-- Description: lists routine details
-- ===========================================================
CREATE VIEW [dbo].[SysRtns_vw]
AS
SELECT TOP 2000
    SCHEMA_NAME([schema_id])              AS schema_nm
   ,[name]                                AS rtn_nm
   ,IIF([type] IN ('P','PC'), 'P', 'F')   AS rtn_ty
   ,dbo.fnTrim([type])                    AS ty_code
   ,[type_desc]                           AS ty_nm
   ,IIF([type] IN ('FS','FT','PC'),1,0)   AS is_clr
   ,is_ms_shipped
   ,DATEFROMPARTS(YEAR(create_date), MONTH(create_date), Day(create_date)) AS created
   ,DATEFROMPARTS(YEAR(modify_date), MONTH(modify_date), Day(modify_date)) AS modified
FROM sys.objects
    WHERE
     [type] IN ('P', 'FN', 'TF', 'IF', 'AF', 'FT', 'IS', 'PC', 'FS')
ORDER BY [schema_nm], [type], [name]
;
/*
SELECT * FROM SysRtns_vw WHERE ty_code = 'P' AND schema_nm IN ('dbo','test')
SELECt top 500 * from sys.objects WHERE name like 'sp_%'
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==============================================================================================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2023
--
-- Description: splits a qualified rtn name 
-- into a row containing the schema_nm and the rtn_nm
-- removes square brackets
--
-- RULES:
-- @qrn  schema   rtn
-- a.b   a        b
-- a     dbo      a
-- NULL  null     null
-- ''    null     null
--
-- Preconditions
-- PRE 02: if schema is not specifed in @qrn and there are more than 1 rtn with the rtn nm
--          but differnt schema then raise div by zero exception

-- Postconditions:
-- Post 01: if schema is not specifed then get it from the sys rtns PROVIDED ONLY ONE rtn named the @rtn_nm
-- 
-- Changes:
-- 231117: handle [ ] wrappers
-- 240403: handle errors like null @qual_rtn_nm softly as per rules above
-- 241207: changed schema from test to dbo
-- 241227: default schema is now the schema found in the sys rtns for the given rtn in @qrn
--         will throw a div by zero error if PRE 02 violated
-- ==============================================================================================================
CREATE FUNCTION [dbo].[fnSplitQualifiedName]
(
   @qrn VARCHAR(150) -- qualified routine name
)
RETURNS @t TABLE
(
    schema_nm  VARCHAR(50)
   ,rtn_nm     VARCHAR(100)
)
AS
BEGIN
   DECLARE
    @n          INT
   ,@schema_nm  VARCHAR(50)
   ,@rtn_nm     VARCHAR(100)

   -- Remove [ ] wrappers
   SET @qrn = dbo.fnDeSquareBracket(@qrn);

   IF @qrn IS NOT NULL AND @qrn <> ''
   BEGIN
      SET @n = CHARINDEX('.',@qrn);

      -- if rtn nm not qualified then assume schema = dbo
      SET @schema_nm = iif(@n=0, 'dbo',SUBSTRING( @qrn, 1   , @n-1));
      SET @rtn_nm    = iif(@n=0,  @qrn,SUBSTRING( @qrn, @n+1, dbo.fnLen(@qrn)-@n))

      -- PRE 02: if schema is not specifed in @qrn and there are more than 1 rtn with the rtn nm
      --          but differnt schema then raise div by zero exception
      IF( CHARINDEX('.', @qrn) = 0)
      BEGIN
         DECLARE @cnt INT;
         SELECT @cnt = COUNT(*) FROM dbo.SysRtns_vw WHERE rtn_nm = @qrn;

         -- Raise div by zero exception
         IF @cnt > 1 SET @cnt = @cnt/0;
      END
   END

   INSERT INTO @t (schema_nm, rtn_nm)
   VALUES( @schema_nm,@rtn_nm);
   RETURN;
END
/*
SELECT * FROM fnSplitQualifiedName('test.fnGetRtnNmBits')
SELECT * FROM fnSplitQualifiedName('a.b')
SELECT * FROM fnSplitQualifiedName('a.b.c')
SELECT * FROM fnSplitQualifiedName('a')
SELECT * FROM fnSplitQualifiedName(null)
SELECT * FROM fnSplitQualifiedName('')
EXEC test.sp__crt_tst_rtns '[dbo].[fnSplitQualifiedName]';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================
-- Author:      Terry Watts
-- Create Date: 06-AUG-2023
-- Description: Checks that the given table is populated    or not
-- Normal mode: this checks to see if the table has atleast 1 row
--
-- However it can be use to Checks that the given table is NOT populated
-- by setting @exp_cnt to 0
--
-- Called by sp_chk_tbl_not_pop
-- ======================================================================
CREATE PROCEDURE [dbo].[sp_assert_tbl_pop]
    @table        VARCHAR(60)
   ,@msg          VARCHAR(MAX)  = NULL
   ,@display_msgs BIT           = 0
   ,@exp_cnt      INT           = NULL
   ,@ex_num       INT           = 56687
   ,@ex_msg       VARCHAR(500)  = NULL
   ,@fn           VARCHAR(35)   = N'*'
   ,@log_level INT              = 0
AS
BEGIN
   DECLARE 
    @fnThis       VARCHAR(35)   = N'sp_assert_tbl_pop'
   ,@sql          NVARCHAR(MAX)
   ,@act_cnt      INT           = -1
   ,@schema_nm    VARCHAR(50)
   ;

   SET NOCOUNT ON;

   SELECT 
       @table     = rtn_nm 
      ,@schema_nm = schema_nm
   FROM dbo.fnSplitQualifiedName(@table)
   ;

   SET @sql = CONCAT('SELECT @act_cnt = COUNT(*) FROM [', @schema_nm, '].[', @table, ']');
   EXEC sp_executesql @sql, N'@act_cnt INT OUT', @act_cnt OUT

   --IF @display_msgs = 1
   --BEGIN
   EXEC sp_log 1, @fnThis, @msg, ' table:[', @table, '] has ', @act_cnt, ' rows';
   --END

   IF @exp_cnt IS NOT null
   BEGIN
      IF @exp_cnt <> @act_cnt
      BEGIN
         IF @ex_msg IS NULL
            SET @ex_msg = CONCAT('Table: ', @table, ' row count: exp ',@exp_cnt,'  act:', @act_cnt);

         EXEC sp_log 4, @fnThis ,'040: @exp_cnt (', @exp_cnt, ')<> @act_cnt (', @act_cnt, ') raising exception: ',@ex_msg;
         EXEC sp_raise_exception @ex_num, @ex_msg, 1, @fn=@fn;
      END
   END
   ELSE
   BEGIN -- Check at least 1 row
      IF @act_cnt = 0
      BEGIN
         IF @ex_msg IS NULL
            SET @ex_msg = CONCAT('Table: ', @table, ' does not have any rows');

         EXEC sp_log 4, '070: table ',@table,' has no rows: ', @ex_msg;
         THROW @ex_num, @ex_msg, 1;
      END
   END
END
/*
   -- This should not create an exception as dummytable has rows
   EXEC dbo.sp_assert_tbl_po 'use'
   EXEC dbo.sp_assert_tbl_po 'dummytable'
   
   -- This should create the following exception:
   -- Msg 56687, Level 16, State 1, Procedure dbo.sp_assert_tbl_po, Line 27 [Batch Start Line 37]
   -- Table: [AppLog] does not have any rows
    
   EXEC dbo.sp_assert_tbl_po 'AppLog'
   IF EXISTS (SELECT 1 FROM [dummytable]) PRINT '1' ELSE PRINT '0'
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===========================================================
-- Author:      Terry watts
-- Create date: 20-SEP-2024
-- Description: Deletes the file on disk
--
-- Postconditions:
-- POST 01 raise exception if failed to delete the file
-- ===========================================================
CREATE PROCEDURE [dbo].[sp_delete_file]
    @file_path    VARCHAR(500)   = NULL
   ,@chk_exists   BIT = 0 -- chk exists in the first place
   ,@fn           VARCHAR(35)    = N'*'
AS
BEGIN
   DECLARE
    @fnThis       VARCHAR(35)   = N'SP DELETE_FILE'
   ,@cmd          VARCHAR(MAX)
   ,@msg          VARCHAR(1000)
   ;

   EXEC sp_log 1, @fnThis,'000: starting, deleting file:[',@file_path,']';
   DROP TABLE IF EXISTS #tmp;
   CREATE table #tmp (id INT identity(1,1), [output] NVARCHAR(4000))

   IF (dbo.fnFileExists(@file_path) <> 0)
   BEGIN
      --SET @cmd = CONCAT('INSERT INTO #tmp  EXEC xp_cmdshell ''del "', @file_path, '"'' ,NO_OUTPUT');
      SET @cmd = CONCAT('INSERT INTO #tmp  EXEC xp_cmdshell '' del "', @file_path, '"''');
      --PRINT @cmd;
      EXEC sp_log 1, @fnThis,'010: sql:[',@cmd,']';
      EXEC (@cmd);

      --IF EXISTS (SELECT TOP 2 1 FROM #tmp) SELECT * FROM #tmp;
   END
   ELSE -- file does not exist
      IF (@chk_exists = 1) -- POST 01 raise exception if failed to delete the file
         EXEC sp_raise_exception 58147, ' 020: file [',@file_path,'] does not exist but chk_exists specified', @fn=@fnThis;

   IF dbo.fnFileExists(@file_path) <> 0
   BEGIN
      IF EXISTS (SELECT TOP 2 1 FROM #tmp)
         SELECT @msg = [output] FROM #tmp where id = 1;

      EXEC sp_raise_exception 63500, '030: failed to delete file [', @file_path, '], reason: ',@msg, @fn=@fnThis;
   END

   EXEC sp_log 0, @fnThis,'999: leaving';
END
/*
EXEC sp_delete_file 'D:\Logs\a.txt';
EXEC sp_delete_file 'non exist file';
EXEC sp_delete_file 'D:\Logs\Farming.log';

EXEC xp_cmdshell 'del "D:\Logs\Farming.log"'


*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================================================================================
-- Author:      Terry Watts
-- Create date: 20-OCT-2024
-- Description: Imports a tab separated txt file into @table
--
-- Responsibilities:
-- R00: delete the log files beefore importing if they exist
-- R01: Import the table from the tsv file
-- R02: Remove double quotes
-- R03: Trim leading/trailing whitespace
-- R04: Remove in-field line feeds
-- R05: check the list of @non_null_flds fields do not have any nulls - if @non_null_flds supplied
--
-- Changes:
-- 20-OCT-2024: increased @spreadsheet_file parameter len from 60 to 500 as the file path was being truncated
-- 31-OCT-2024: cleans each imported text field for double quotes and leading/trailing white space
-- 05-NOV-2024: optionally display imported table: sometimes we need to do more fixup before data is ready
--              so when this is the case then dont display the table here, but do post import fixup in the 
--              calling sp first and then display the table
-- 11-NOV-2024: added an optional view to control field mapping
-- =============================================================================================================
CREATE PROCEDURE [dbo].[sp_import_txt_file]
    @table            VARCHAR(60)
   ,@file             VARCHAR(500)
   ,@folder           VARCHAR(600)  = NULL
   ,@field_terminator VARCHAR(2)    = NULL -- N'\t'
   ,@row_terminator   NCHAR(4)      = NULL -- N'\r\n'
   ,@codepage         INT           = 1252 -- 1252 for utf-8-bom or 65001 for 8-bom especiall if Â character appears in imported text
   ,@first_row        INT           = 2
   ,@last_row         INT           = NULL
   ,@clr_first        BIT           = 1
   ,@view             VARCHAR(120)  = NULL
   ,@format_file      VARCHAR(500)  = NULL
   ,@expect_rows      BIT           = 1
   ,@exp_row_cnt      INT           = NULL
   ,@non_null_flds    VARCHAR(1000) = NULL
   ,@display_table    BIT           = 0
   ,@row_cnt          INT           = NULL OUT
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)       = N'sp_import_txt_file'
   ,@cmd          NVARCHAR(MAX)
   ,@sql          VARCHAR(MAX)
   ,@nl           CHAR(2)           = CHAR(13)+CHAR(10)
   ,@line_feed    CHAR(1)           = CHAR(10)
   ,@bkslsh       CHAR(1)           = CHAR(92)
   ,@tab          CHAR(1)           = CHAR(9)
   ,@max_len_fld  INT
   ,@del_file     VARCHAR(1000)
   ,@error_file   VARCHAR(1000)
   ,@ndx          INT = 1
   ,@end          INT
   ,@line         VARCHAR(128) = REPLICATE('-', 100)
   ,@ex_num       INT
   ,@ex_msg       INT
   ;

   EXEC sp_log 1, @fn, '000: starting:
table           :[',@table             ,']
file            :[',@file              ,']
folder          :[',@folder            ,']
field_terminator:[',@field_terminator  ,']
first_row       :[',@first_row         ,']
last_row        :[',@last_row          ,']
clr_first       :[',@clr_first         ,']
view            :[',@view              ,']
format_file     :[',@format_file       ,']
row_terminator  :[',@row_terminator    ,']
expect_rows     :[',@expect_rows       ,']
exp_row_cnt     :[',@exp_row_cnt       ,']
non_null_flds   :[',@non_null_flds     ,']
display_table   :[',@display_table     ,']'
;

   BEGIN TRY
      ---------------------------------------------------
      -- Validating inputs
      ---------------------------------------------------
      IF @folder IS NOT NULL
         SET @file = CONCAT(@folder, @bkslsh, @file);

      IF @table IS NULL OR @table =''
         EXEC sp_raise_exception 53050, @fn, '010: error: table must be specified';

      EXEC sp_assert_not_null_or_empty @file, @fn, '020: error: file must be specified'
      IF @field_terminator IS NULL SET @field_terminator = @tab;
      IF @field_terminator NOT IN ( @tab,',','t') EXEC sp_raise_exception 53051, @fn, '030: error: field terminator must be either comma or tab';
      IF @row_terminator IS NULL OR @row_terminator='' SET @row_terminator = @nl;

      IF @first_row IS NULL OR @first_row < 1
         SET @first_row = 2;

      IF @last_row IS NULL OR @last_row < 1
         SET @last_row = 1000000;

      -- View is optional - defaults to the table stru
      IF @view IS NULL
         SET @view = @table;

      IF @clr_first = 1
      BEGIN
         SET @cmd = CONCAT('TRUNCATE TABLE [', @table,'];');
         EXEC sp_log 1, @fn, '040: clearing table fist: SQL: 
   ', @cmd;

         EXEC (@cmd);
      END

      ----------------------------------------------------------------------------------
      -- R00: delete the log files beefore importing if they exist
      ----------------------------------------------------------------------------------

      SET @error_file = CONCAT('D:',NCHAR(92),'logs',NCHAR(92),@table,'import.log');
      SET @del_file = @error_file;
      EXEC sp_log 1, @fn, '050: deleting log file ', @del_file;
      EXEC sp_delete_file @del_file;
      SET @del_file = CONCAT(@del_file, '.Error.Txt');
      EXEC sp_log 1, @fn, '030: deleting log file ',@del_file;
      EXEC sp_delete_file @del_file;

      ----------------------------------------------------------------------------------
      -- R01: Import the table from the tsv file
      ----------------------------------------------------------------------------------

      SET @cmd = 
         CONCAT('BULK INSERT [',@view,'] FROM ''',@file,''' 
   WITH
   (
       DATAFILETYPE    = ''Char''
      ,FIRSTROW        = ',@first_row, @nl
               );

   IF @last_row         IS NOT NULL 
   BEGIN
      EXEC sp_log 1, @fn, '060: @last_row is not null, =[',@last_row, ']';
      SET @cmd = CONCAT( @cmd, '   ,LASTROW        =   ', @last_row        , @nl);
   END

   IF @format_file      IS NOT NULL
   BEGIN
      EXEC sp_log 1, @fn, '070: @last_row is not null, =[',@last_row, ']';
      SET @cmd = CONCAT( @cmd, '   ,FORMATFILE     = ''', @format_file     , @nl);
   END

   if @field_terminator IS NOT NULL
   BEGIN
      EXEC sp_log 1, @fn, '080: @field_terminator is not null, =[',@field_terminator, ']';
      If @field_terminator = 't' SET @field_terminator = '\t';
      SET @cmd = CONCAT( @cmd, '   ,FIELDTERMINATOR= ''', @field_terminator, '''', @nl);
   END

   SET @cmd = CONCAT( @cmd, '  ,ERRORFILE      = ''',@error_file,'''', @nl
      ,'  ,MAXERRORS      = 100', @nl
      ,'  ,CODEPAGE       = ',@codepage, @nl
      ,');'
   );

      PRINT CONCAT( @nl, @line);
      EXEC sp_log 1, @fn, '090: importing file: SQL: 
   ', @cmd;

      PRINT CONCAT( @line, @nl);

      EXEC (@cmd);
      SET @row_cnt = @@ROWCOUNT;

      EXEC sp_log 1, @fn, '100: imported ', @row_cnt, ' rows';

      IF @expect_rows = 1 OR @exp_row_cnt IS NOT NULL
      BEGIN
         EXEC sp_log 1, @fn, '110: importing file: SQL';
         EXEC sp_assert_tbl_pop @table, @exp_cnt = @exp_row_cnt;
      END

      ----------------------------------------------------------------------------------------------------
      -- 31-OCT-2024: cleans each imported text field for double quotes and leading/trailing white space
      ----------------------------------------------------------------------------------------------------
      SET @cmd = CONCAT('SELECT @max_len_fld = MAX(dbo.fnLen(column_name)) FROM list_table_columns_vw WHERE table_name = ''', @table, ''' AND is_txt = 1;');
      EXEC sp_log 1, @fn, '120: getting max field len: @cmd:', @cmd;
      EXEC sp_executesql @cmd, N'@max_len_fld INT OUT', @max_len_fld OUT;
      EXEC sp_log 1, @fn, '130: @max_len_fld: ', @max_len_fld;

      ----------------------------------------------------------------------------------
      -- R02: Remove double quotes
      -- R03: Trim leading/trailing whitespace
      -- R04: Remove line feeds
      ----------------------------------------------------------------------------------

      WITH cte AS
      (
         SELECT dbo.fnPadRight(CONCAT('[', column_name, ']'), @max_len_fld+2) AS column_name,ROW_NUMBER() OVER (ORDER BY ORDINAL_POSITION) AS row_num, ordinal_position, DATA_TYPE, is_txt
         FROM list_table_columns_vw 
         WHERE table_name = @table AND is_txt = 1
      )
      ,cte2 AS
      (
         SELECT CONCAT('UPDATE [',@table,'] SET ') AS sql
         UNION ALL
         SELECT CONCAT( iif(row_num=1, ' ',','), column_name, ' = TRIM(REPLACE(REPLACE(',column_name, ', ''"'',''''), NCHAR(10), ''''))') 
         FROM cte
         UNION ALL
         SELECT CONCAT('FROM [',@table,'];')
      )
      SELECT @sql = string_agg(sql, @NL) FROM cte2;

      EXEC sp_log 1, @fn, '140: trim replacing double quotes, @sql:', @NL, @sql;
      --EXEC sp_log 4, @fn, '145: debug RETURN ******';RETURN;
      EXEC (@sql);
      --EXEC sp_log 4, @fn, '145: debug RETURN ******'; RETURN;

      ----------------------------------------------------------------------------------------------------
      -- 05-NOV-2024: optionally display imported table
      ----------------------------------------------------------------------------------------------------
      IF @display_table = 1
      BEGIN
         SET @cmd = CONCAT('SELECT * FROM [', @table,'];');
         EXEC (@cmd);
      END

     ----------------------------------------------------------------------------------------------------
      -- R05: check the list of @non_null_flds fields do not have any nulls - if @non_null_flds supplied
      ----------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '150: check mandatory fields for null values';

      EXEC sp_chk_flds_not_null
          @table
         ,@non_null_flds
         ;
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;--, ' launching notepad++ to display the error files';
      --SET @cmd = CONCAT('EXEC xp_cmdshell ''notepad++ ', @error_file, '''');
      --EXEC (@cmd);
      --SET @cmd = CONCAT('EXEC xp_cmdshell ''notepad++ ', @error_file, '.Error.txt''');
      --EXEC (@cmd);
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving, imported ',@row_cnt,' rows from: ',@file;
END
/*
EXEC tSQLt.Run 'test.test_024_sp_import_txt_file';
EXEC test.test_069_ImportPathWikiUrlTax;

EXEC sp_import_txt_file 'PathogenStaging','D:\Dev\Farming\Data\Pathogen.txt';
SELECT * FROM PathogenStaging;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================
-- Author:      Terry Watts
-- Create date: 08-FEB-2020
-- Description: returns true (1) if table exists else false (0)
-- schema default is dbo
-- =============================================================
CREATE   FUNCTION [dbo].[fnTableExists](@qrn VARCHAR(60))
RETURNS BIT
AS
BEGIN
   DECLARE
       @schema    VARCHAR(10)
      ,@table_nm  VARCHAR(60)
   ;

   SELECT
       @schema    = schema_nm
      ,@table_nm  = rtn_nm
   FROM fnSplitQualifiedName(@qrn);

   RETURN iif(EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @table_nm AND TABLE_SCHEMA = @schema), 1, 0);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================================================================
-- Author:      Terry Watts
-- Create date: 03-Nov-2023
--
-- Description: Gets the file name optionally with the extension from the supplied file path
--
-- Tests:
--
-- CHANGES:
-- 240307: added @with_ext flag parameter to signal to get either the file with or without the extension
-- ======================================================================================================
CREATE   FUNCTION [dbo].[fnGetFileNameFromPath](@path VARCHAR(MAX), @with_ext BIT)
RETURNS VARCHAR(200)
AS
BEGIN
   DECLARE
    @t TABLE
    (
       id int IDENTITY(1,1) NOT NULL
      ,val VARCHAR(200)
    );

   DECLARE 
       @val VARCHAR(4000)
      ,@ndx INT = -1

   INSERT INTO @t(val)
   SELECT value from string_split(@path, NCHAR(92)); -- ASCII 92 = Backslash
   SET @val = (SELECT TOP 1 val FROM @t ORDER BY id DESC);

   IF @with_ext = 0
   BEGIN
      SET @ndx = CHARINDEX('.', @val);

      SET @val = IIF(@ndx=0, @val, SUBSTRING(@val, 1, @ndx-1));
   END

   RETURN @val;
END
/*
EXEC test.test_084_fnGetFileNameFromPath;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ================================================================================================================================================
-- Author:      Terry Watts
-- Create date: 25-FEB-2024
-- Description: imports a txt (csv or tsv) or xlsx file
--
-- Parameters:    Mandatory,optional M/O
-- @import_file  [M] the import source file can be a tsv or xlsx file
--                   if an XL file then the normal format for the sheet is field names in the top row including an id for ease of debugging 
--                   data issues
-- @table        [O] the table to import the data to. 
--                if an XL file defaults to sheet name if not Sheet1$ otherwise file name less the extension
--                if a tsv defaults to file name less the extension
-- @view         [O] if a tsv this is the view used to control which columns are used n the Bulk insert command
--                   the default is NULL when the view name is constructed as import_<table name>_vw
-- @range        [O] for XL: like 'Corrections_221008$A:P' OR 'Corrections_221008$' default is 'Sheet1$'
-- @fields       [O] for XL: comma separated list
-- @clr_first    [O] if 1 then delete the table contents first           default is 1
-- @is_new       [O] if 1 then create the table - this is a double check default is 0
-- @expect_rows  [O] optional @expect_rows to assert has imported rows   default is 1
--
-- Preconditions: none
--
-- Postconditions:
-- POST01: @import file must not be null or ''             OR exception 63240, 'import_file must be specified'
-- POST02: @import file must exist                         OR exception 63241, 'import_file must exist'
-- POST03: if @is_new is false then (table must exist      OR exception 63242, 'table must exist if @is_new is false')
-- POST04: if @is_new is true  then (table must not exist  OR exception 63243, 'table must not exist if @is_new is true'))
-- 
-- RULES:
-- RULE01: @table:  if xl import then @table must be specified or deducable from the sheet name or file name OR exception 63245
-- RULE02: @table:  if a tsv then must specify table or the file name is the table 
-- RULE03: @view:   if a tsv file then if the view is not specified then it is set as Import<table>_vw
-- RULE04: @range:  if an Excel file then range defaults to 'Sheet1$'
-- RULE05: @fields: if an Excel file then @fields is optional
--                  if not specified then it is taken from the excel header (first row)
-- RULE07: @is_new: if new table and is an excel file and @fields is null then the table is created with fields taken from the spreadsheet header.
--
-- Changes:
-- 240326: added an optional root dir which can be specified once by client code and the path constructed here
-- ================================================================================================================================================
CREATE PROCEDURE [dbo].[sp_import_file]
    @import_file  VARCHAR(1000)
   ,@import_root  VARCHAR(1000)  = NULL
   ,@table        VARCHAR(60)    = NULL
   ,@view         VARCHAR(60)    = NULL
   ,@range        VARCHAR(100)   = N'Sheet1$'   -- POST09 for XL: like 'Corrections_221008$A:P' OR 'Corrections_221008$'
   ,@field_sep    VARCHAR(1)     = NULL
   ,@fields       VARCHAR(4000)  = NULL         -- for XL: comma separated list
   ,@clr_first    BIT            = 1            -- if 1 then delete the table contents first
   ,@is_new       BIT            = 0            -- if 1 then create the table - this is a double check
   ,@first_row    INT            = NULL
   ,@last_row     INT            = NULL
   ,@expect_rows  BIT            = 1            -- optional @expect_rows to assert has imported rows
   ,@row_cnt      INT            = NULL OUT     -- optional count of imported rows
AS
BEGIN
   SET NOCOUNT ON;

   DECLARE
    @fn              VARCHAR(35)= N'sp_import_file'
   ,@bckslsh         VARCHAR(1) = NCHAR(92)
   ,@tab             VARCHAR(1) = NCHAR(9)
   ,@nl              VARCHAR(2) = NCHAR(13) + NCHAR(10)
   ,@ndx             INT
   ,@file_name       VARCHAR(128)
   ,@table_exists    BIT
   ,@is_xl_file      BIT
   ,@txt_file_ty     BIT -- 0:txt, 1: tsv
   ,@msg             VARCHAR(500)

   PRINT '';
   EXEC sp_log 1, @fn, '000: starting';

   EXEC sp_log 1, @fn, '001: parameters,
import_file:  [', @import_file,']
table:        [', @table,']
view:         [', @view,']
range:        [', @range,']
fields:       [', @fields,']
clr_first:    [', @clr_first,']
is_new        [', @is_new,']
expect_rows   [', @expect_rows,']
first_row     [', @first_row,']
last_row      [', @last_row,']
';

   BEGIN TRY
      EXEC sp_log 1, @fn, '005: initial checks';
      EXEC sp_log 0, @fn, '010: checking POST01';
      ----------------------------------------------------------------------------------------------------------
      -- POST01: @import file must not be null or '' OR exception 63240, 'import_file must be specified'
      ----------------------------------------------------------------------------------------------------------
      IF @import_file IS NULL OR @import_file =''
      BEGIN
         SET @msg = 'import file must be specified';
         EXEC sp_log 4, @fn, '011 ',@msg;
         THROW 63240, @msg, 1;
      END

      IF @import_root IS NOT NULL
      BEGIN
         SET @import_file = CONCAT(@import_root, @bckslsh, @import_file);
         EXEC sp_log 1, @fn, '010: ,
modified import_file:  [', @import_file,']';
      END

      ----------------------------------------------------------------------------------------------------------
   -- POST02: @import file must exist  OR exception 63241, 'import_file must exist'
      ----------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '025: checking POST02';
      IF dbo.fnFileExists(@import_file) <> 1
      BEGIN
         EXEC sp_log 1, @fn, '030: checking POST02'
         SET @msg = CONCAT('import file [',@import_file,'] must exist');
         EXEC sp_log 4, @fn, '040 ',@msg;
         THROW 63241, @msg, 1;
      END

      EXEC sp_log 1, @fn, '050';
      SET @is_xl_file = IIF( CHARINDEX('.xlsx', @import_file) > 0, 1, 0);

      ----------------------------------------------------------------------------------------------------------
      -- Handle defaults
      ----------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '060: handle defaults';
      IF @range     IS NULL SET @range =  N'Sheet1$';
      IF @clr_first IS NULL SET @clr_first = 1;

      IF @table IS NULL
      BEGIN
         EXEC sp_log 1, @fn, '070: @table not specified so getting table';

         IF @is_xl_file = 1
         BEGIN
            ----------------------------------------------------------------------------------------------------------
            -- POST06: @table: if xl import then @table must be specified or deducable from the sheet name or file name OR exception 63245
            ----------------------------------------------------------------------------------------------------------
            EXEC sp_log 1, @fn, '080: is an XL import, @range:[',@range,']';

            IF SUBSTRING(@range, 1, 7)<> 'Sheet1$'
            BEGIN
               SET @ndx   = CHARINDEX('$', @range);
               SET @table = SUBSTRING(@range, 1, @ndx-1);
               EXEC sp_log 1, @fn, '083: range is not Sheet1$, table: [',@table,']';
            END
            ELSE
            BEGIN
               IF @ndx = 1 SET @ndx = dbo.fnLen(@range);
               SET @table = dbo.fnGetFileNameFromPath(@import_file,0);
               EXEC sp_log 1, @fn, '083: range is Sheet1$, table: [',@table,']';
            END
         END
         ELSE
         BEGIN
             EXEC sp_log 1, @fn, '090: is text import';
           ----------------------------------------------------------------------------------------------------------
            -- POST07: @table: if a tsv then must specify table or the file name is the table
            ----------------------------------------------------------------------------------------------------------
            SET @table = dbo.fnGetFileNameFromPath(@import_file,0);
         END

         EXEC sp_log 1, @fn, '100: chk table exists';

         IF dbo.fnTableExists(@table)=0
         BEGIN
            EXEC sp_log 1, @fn, '110: deduced table name:[', @table,'] does not exist, setting @table NULL';
            SET @table = NULL;
         END

         EXEC sp_log 1, @fn, '120: deduced table name:[', @table,']';
      END

      EXEC sp_log 1, @fn, '130: table:[', @table,']';
      SET @table_exists = iif( @table IS NOT NULL AND dbo.fnTableExists(@table)<>0, 1, 0);

      ----------------------------------------------------------------------------------------------------------
      -- RULE03: @view:  if a tsv file then if the view is not specified then it is set as Import<table>_vw
      ----------------------------------------------------------------------------------------------------------
      IF @view IS NULL AND @table_exists = 1  AND @is_xl_file = 0 
      BEGIN
         SET @view = CONCAT('Import_',@table,'_vw');
         EXEC sp_log 1, @fn, '140: if a tsv file and the view is not specified then set view default value as Import_<table>_vw: [',@view,']'
      END

      ----------------------------------------------------------------------------------------------------------
      -- Parameter Validation
      ----------------------------------------------------------------------------------------------------------

      ----------------------------------------------------------------------------------------------------------
      -- RULE05: @fields:if an Excel file then @fields is optional
      --          if not specified then it is taken from the excel header (first row)
      -- RULE07: @is_new: if new table and is an excel file and @fields is null then the table is created with
      --         fields taken from the spreadsheet header.

      ----------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '150: checking rule 5,11';
      IF @fields IS NULL
      BEGIN
         IF @is_xl_file = 1
         BEGIN
            EXEC sp_get_flds_frm_hdr_xl @import_file, @range=@range, @fields=@fields OUT;
            EXEC sp_log 1, @fn, '160: is xl file and the fields are not specified then defaulting @fields to: [',@fields,']'
         END
         ELSE
         BEGIN
            EXEC sp_log 1, @fn, '170: calling sp_get_flds_frm_hdr_txt';
            EXEC sp_get_flds_frm_hdr_txt
                @file            = @import_file
               ,@fields          = @fields OUT
               ,@display_tables   = 0
               ,@file_type        = @txt_file_ty OUT -- 0:txt, 1: tsv
               ;

            EXEC sp_log 1, @fn, '180: ret frm sp_get_flds_frm_hdr_txt';
            -- try by name
            IF @field_sep IS NULL
               SET @field_sep = iif(@txt_file_ty=0, 'txt','tsv');
         END
      END

      EXEC sp_log 1, @fn, '190';
      --------------------------------------------------------------------------------------------------------------------
   -- POST03: if @is_new is false then (table must exist OR exception 63242, 'table must exist if @is_new is false')
      --------------------------------------------------------------------------------------------------------------------
      IF @is_new = 0 AND @table_exists = 0
      BEGIN
         SET @msg = 'table must exist if @is_new is false';
         EXEC sp_log 4, @fn, '200 ',@msg;
         THROW 63244, @msg, 1;
      END

      EXEC sp_log 1, @fn, '210';
      -----------------------------------------------------------------------------------------------------------------
   -- POST04: if @is_new is true then (table does not exist  OR ex 63243, 'table must not exist if @is_new is true'))
      -----------------------------------------------------------------------------------------------------------------
      IF @is_new = 1 AND @table_exists = 1
      BEGIN
         SET @msg = 'table must not exist if @is_new is true';
         EXEC sp_log 4, @fn, '220 ',@msg;
         THROW 63243, @msg, 1;
      END

      --****************************************
      -- Import the file
      --****************************************
      EXEC sp_log 1, @fn, '230: Importing file';

      IF @is_xl_file = 1
      BEGIN
         ----------------------------------------------------------------------------------------------------------
         -- Import Excel file
         ----------------------------------------------------------------------------------------------------------
         -- Parameter Validation
         EXEC sp_log 1, @fn, '240: Importing Excel file, fixup the range:',@range,'|';

         -- Fixup the range
         SET @range = dbo.fnFixupXlRange(@range);
         EXEC sp_log 1, @fn, '250: Importing Excel file, fixed up the range:',@range,'|';

         ----------------------------------------------------------------------------------------------------------
         -- RULE05: @fields:if an Excel file then @fields is optional
         --          if not specified then it is taken from the excel header (first row)
         -- RULE07: @is_new: if new table and if an Excel file and @fields is null 
         --         then the table is created with fields taken from the spreadsheet header
         ----------------------------------------------------------------------------------------------------------
         --EXEC sp_log 1, @fn, '085: calling sp_get_fields_from_xl_hdr';
         --EXEC sp_get_fields_from_xl_hdr @import_file, @range, @fields OUT;
         --EXEC sp_log 1, @fn, '087: ret frm sp_get_fields_from_xl_hdr';

         IF @is_new = 1
         BEGIN
            ----------------------------------------------------------------------------------------------------------
            -- Importing Excel file to new table
            ----------------------------------------------------------------------------------------------------------
            EXEC sp_log 1, @fn, '260: Importing Excel file to new table';
            EXEC sp_import_XL_new @import_file, @range, @table, @fields, @row_cnt=@row_cnt OUT;
         END
         ELSE
         BEGIN
            ----------------------------------------------------------------------------------------------------------
            -- Importing Excel file to existing table @range,
            ----------------------------------------------------------------------------------------------------------
            EXEC sp_log 1, @fn, '270: Importing Excel file to existing table';
            EXEC sp_import_XL_existing @import_file,  @table, @clr_first, @fields, @end_row=@first_row/*,@last_row=@last_row*/, @row_cnt=@row_cnt OUT;
            EXEC sp_log 1, @fn, '280:';
         END

         EXEC sp_log 1, @fn, '290: Imported Excel file';
      END
      ELSE
      BEGIN
         ----------------------------------------------------------------------------------------------------------
         -- Importing txt file
         ----------------------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn, '300: Importing tsv file';

         ----------------------------------------------------------------------------------------------------------
         -- POST12: @is_new: if this is set then the table is created with fields based on the spreadsheet header
         ----------------------------------------------------------------------------------------------------------

         --EXEC sp_bulk_import_tsv @import_file, @view, @table, @clr_first, @first_row=@first_row,@last_row=@last_row, @row_cnt=@row_cnt OUT;
         EXEC sp_import_txt_file
             @table           = @table
            ,@file            = @import_file
            ,@field_terminator= @field_sep
            ,@row_terminator  = N'\r\n'
            ,@first_row       = @first_row
            ,@last_row        = @last_row
            ,@clr_first       = @clr_first
            ,@view            = @view
            ,@format_file     = NULL
            ,@expect_rows     = 1
            ,@exp_row_cnt     = NULL
            ,@non_null_flds   = NULL
            ,@display_table   = 0
            ,@row_cnt         = @row_cnt OUT
      END

      ----------------------------------------------------------------------------------------------------------
      -- Checking post conditions
      ----------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '310: Checking post conditions'

      IF @expect_rows = 1
         EXEC sp_assert_tbl_pop @table;

      ---------------------------------------------------------------------
      -- Completed processing OK
      ---------------------------------------------------------------------
      EXEC sp_log 1, @fn, '320: Completed processing OK'
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;

      EXEC sp_log 1, @fn, '520: parameters:
import_file:  [', @import_file,']
import_root:  [', @import_root,']
table:        [', @table,']
view:         [', @view,']
range:        [', @range,']
fields:       [', @fields,']
clr_first:    [', @clr_first,']
is_new        [', @is_new,']
expect_rows   [', @expect_rows,']
';

      EXEC sp_log 1, @fn, '530: state:
   @table_exists:  [', @table_exists,']
   @is_xl_file     [', @is_xl_file,']';

      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving OK, imported ',@row_cnt,' rows to the ',@table,'  table from ',@import_file;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_085_sp_bulk_import';
EXEC test.test_085_sp_import_file;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ================================================
-- Author:      Terry Watts
-- Create date: 04-JAN-2021
-- Description: determines if a sql_variant is an
-- approximate type: {float, real or numeric}
-- test: [test].[t 025 fnIsFloat]
-- ================================================
CREATE   FUNCTION [dbo].[fnIsFloatType](@ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('float','real','numeric'), 1, 0);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is of type GUID
-- ====================================================================
CREATE   FUNCTION [dbo].[fnIsGuidType](@v SQL_VARIANT)
RETURNS BIT
AS
BEGIN
/*   DECLARE @type SQL_VARIANT
   DECLARE @ty   VARCHAR(500)
   SELECT @type = SQL_VARIANT_PROPERTY(@v, 'BaseType');
   SET @ty = CONVERT(VARCHAR(500), @type);

   RETURN
      CASE
         WHEN @ty = 'uniqueidentifier' THEN  1
         ELSE                                0
         END;
*/
   RETURN iif(CONVERT(VARCHAR(500), SQL_VARIANT_PROPERTY(@v, 'BaseType')) = 'uniqueidentifier', 1, 0);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is an
-- integral type: {int, smallint, tinyint, bigint, money, smallmoney}
-- test: [test].[t 025 fnIsFloat]
--
-- Changes:
-- 241128: added optional check for non negative ints
-- ====================================================================
CREATE   FUNCTION [dbo].[fnIsIntType]( @ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('BIT','INT','SMALLINT','TINYINT','BIGINT','MONEY','SMALLMONEY'), 1, 0);
END
/*
SELECT dbo.fnIsInt('0',0) as [fnIsInt('0', 0)], dbo.fnIsInt('05',0) as [fnIsInt(05,0)]
SELECT dbo.fnIsInt('0',1) as [fnIsInt('0',1)], dbo.fnIsInt('05',1) as [dbo.fnIsInt('05',1)]
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 08-DEC-2024
-- Description: Returns true if a time type
--              Handles single and array types like INT and VARCHAR(MAX)
-- ====================================================================
CREATE   FUNCTION [dbo].[fnIsTimeType](@ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('date','datetime','datetime2','datetimeoffset','smalldatetime','TIME'), 1, 0);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===================================================================
-- Author:      Terry Watts
-- Create date: 08-DEC-2024
-- Description: Gets the type category for a Sql Uerver datatype
-- e.g. Exact types : INT, MONEY 
-- Floating point types: float real
--
-- TESTS:
-- ===================================================================
CREATE   FUNCTION [dbo].[fnGetTypeCat](@ty VARCHAR(25))
RETURNS VARCHAR(25)
AS
BEGIN
   DECLARE @type SQL_VARIANT
   ;

   RETURN
      CASE
         WHEN dbo.fnIsIntType (@ty)     = 1 THEN 'Int'
         WHEN dbo.fnIsTextType(@ty)     = 1 THEN 'Text'
         WHEN dbo.fnIsTimeType(@ty) = 1 THEN 'Time'
         WHEN dbo.fnIsFloatType(@ty)    = 1 THEN 'Float'
         WHEN dbo.fnIsGuidType(@ty)     = 1 THEN 'GUID'
         END;
END
/*
EXEC test.sp__crt_tst_rtns '[dbo].[fnGetTypeCat]';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is of type BIT
-- ====================================================================
CREATE   FUNCTION [dbo].[fnIsBoolType](@v SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   RETURN iif( @v = 'bit', 1,0);
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =========================================================
-- Author:      Terry Watts
-- Create date: 05-JAN-2021
-- Description: function to compare values - includes an
--              approx equal check for floating point types
-- Returns 1 if equal, 0 otherwise
-- =========================================================
CREATE FUNCTION [dbo].[fnChkEquals]( @a SQL_VARIANT, @b SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   DECLARE
    @fn     VARCHAR(35)   = N'sp_fnChkEquals'
   ,@res    BIT
   ,@a_str  VARCHAR(4000) = CONVERT(VARCHAR(400), @a)
   ,@b_str  VARCHAR(4000) = CONVERT(VARCHAR(400), @b)
   ,@a_ty   VARCHAR(25)   = CONVERT(VARCHAR(25), SQL_VARIANT_PROPERTY(@a, 'BaseType'))
   ,@b_ty   VARCHAR(25)   = CONVERT(VARCHAR(25), SQL_VARIANT_PROPERTY(@b, 'BaseType'))
   ;

   -- NULL check
   IF @a IS NULL AND @b IS NULL
   BEGIN
      RETURN 1;
   END

   IF @a IS NULL AND @b IS NOT NULL
   BEGIN
      RETURN 0;
   END

   IF @a IS NOT NULL AND @b IS NULL
   BEGIN
      RETURN 0;
   END

   -- if both are floating point types, fnCompareFloats evaluates  fb comparison to accuracy +- epsilon
   -- any differnce less that epsilon is consider insignifacant so considers and b to =
   -- fnCompareFloats returns 1 if a>b, 0 if a==b, -1 if a<b
   IF (dbo.[fnIsFloatType](@a_ty) = 1) AND (dbo.[fnIsFloatType](@b_ty) = 1)
   BEGIN
      RETURN iif(dbo.[fnCompareFloats](CONVERT(FLOAT(24), @a), CONVERT(FLOAT(24), @b)) = 0, 1, 0);
   END

   -- if both are int types
   IF (dbo.fnIsIntType(@a_ty) = 1) AND (dbo.fnIsIntType(@b_ty) = 1)
      RETURN iif(CONVERT(BIGINT, @a) = CONVERT(BIGINT, @b), 1, 0);

   -- if both are string types
   IF (dbo.fnIsTextType(@a_ty) = 1) AND (dbo.fnIsTextType(@b_ty) = 1)
      RETURN iif(@a_str = @b_str, 1, 0);

   -- if both are boolean types
   IF (dbo.fnIsBoolType(@a_ty) = 1) AND (dbo.fnIsBoolType(@b_ty) = 1)
      RETURN iif(CONVERT(BIT, @a) = CONVERT(BIT, @b), 1, 0);

   -- if both are datetime types
   IF (dbo.fnIsTimeType(@a_ty) = 1) AND (dbo.fnIsTimeType(@b_ty) = 1)
      RETURN iif( CONVERT(DATETIME, @a) = CONVERT(DATETIME, @b), 1, 0);

   -- if both are guid types
   IF (dbo.fnIsGuidType(@a_ty) = 1) AND (dbo.fnIsGuidType(@b_ty) = 1)
      RETURN iif(CONVERT(UNIQUEIDENTIFIER, @a) = CONVERT(UNIQUEIDENTIFIER, @b), 1, 0);

   ----------------------------------------------------
   -- Compare by type cat
   ----------------------------------------------------

   DECLARE
    @a_cat  VARCHAR(25)
   ,@b_cat  VARCHAR(25)

   SET @a_cat = [dbo].[fnGetTypeCat](@a_ty);
   SET @b_cat = [dbo].[fnGetTypeCat](@b_ty);

   if(@a_cat = @b_cat)
   BEGIN
      IF @a_cat = 'Int'
      BEGIN
         SET @res = iif(CONVERT(BIGINT, @a) = CONVERT(BIGINT, @b), 1, 0);
      END
      ELSE IF @a_cat = 'Float'
      BEGIN
         SET @res = iif(CONVERT(FLOAT(24), @a) = CONVERT(FLOAT(24), @b), 1, 0);
      END
      ELSE IF @a_cat = 'Text'
      BEGIN
         SET @res = iif(CONVERT(VARCHAR(8000), @a) = CONVERT(VARCHAR(8000), @b), 1, 0);
      END
      ELSE IF @a_cat = 'Time'
      BEGIN
         SET @res = iif(CONVERT(DATETIME2, @a) = CONVERT(DATETIME2, @b), 1, 0);
      END
      ELSE IF @a_cat = 'GUID'
      BEGIN
         SET @res = iif(CONVERT(UNIQUEIDENTIFIER, @a) = CONVERT(UNIQUEIDENTIFIER, @b), 1, 0);
      END

      RETURN @res;
   END

   ----------------------------------------------------------------------
   -- Can compare Floats with integral types -> convert both to big float
   ----------------------------------------------------------------------
   IF (@a_cat='Int' AND @b_cat='Float') OR (@a_cat='Float' AND @b_cat='Int')
   BEGIN
      RETURN iif(CONVERT(FLOAT(24), @a) = CONVERT(FLOAT(24), @b), 1, 0);
   END

   ----------------------------------------------------
   -- Final option: compare by converting to text
   ----------------------------------------------------
   SET @res = iif(@a_str = @b_str, 1, 0)
   RETURN @res;
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry watts
-- Create date: 21-JAN-2020
-- Description: 1 line check null or mismatch and throw message
--              ASSUMES data types are the same
-- =============================================
CREATE   PROCEDURE [dbo].[sp_assert_equal]
    @a         SQL_VARIANT
   ,@b         SQL_VARIANT
   ,@msg0      VARCHAR(200)   = NULL
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT             = 50001
   ,@fn        VARCHAR(35)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
DECLARE
    @fnThis VARCHAR(35) = 'sp_assert_equal'
   ,@aTxt   VARCHAR(100)= CONVERT(VARCHAR(20), @a)
   ,@bTxt   VARCHAR(100)= CONVERT(VARCHAR(20), @b)

   EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';

   IF dbo.fnChkEquals(@a ,@b) <> 0
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, @a:[',@aTxt, '] = @b:[', @bTxt, ']';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fnThis, '020: @a:[',@aTxt, '] <> @b:[', @bTxt, '], raising exception';

   EXEC sp_raise_exception
       @msg0   = @msg0 
      ,@msg1   = @msg1 
      ,@msg2   = @msg2 
      ,@msg3   = @msg3 
      ,@msg4   = @msg4 
      ,@msg5   = @msg5 
      ,@msg6   = @msg6 
      ,@msg7   = @msg7 
      ,@msg8   = @msg8 
      ,@msg9   = @msg9 
      ,@msg10  = @msg10
      ,@msg11  = @msg11
      ,@msg12  = @msg12
      ,@msg13  = @msg13
      ,@msg14  = @msg14
      ,@msg15  = @msg15
      ,@msg16  = @msg16
      ,@msg17  = @msg17
      ,@msg18  = @msg18
      ,@msg19  = @msg19
      ,@msg20  = @msg20
      ,@ex_num = @ex_num
      ,@fn     = @fn
END
/*
   EXEC tSQLt.RunAll;
   EXEC sp_assert_equal 1, 1;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================
-- Author:      Terry Watts
-- Create date: 15-MAR-2024
-- Description:
--    Imports the LRAP data xls file, format spec = 221018
--
-- PRECONDITIONS:
-- file format spec = 221018
-- S1 and S2 are truncted
--
-- POSTCONDITIONS:
-- POST 01: S1 populated, s2 not
--
-- RESPONSIBILITIES:
-- R01: Clear the S1 and S2 tables
-- R02: Import the LRAP data file
-- R03: assign the import id to new data
--
-- TESTS:
--
-- CHANGES:
-- 
-- ======================================================================================
CREATE PROCEDURE [dbo].[sp_import_LRAP_file_xls_221018]
    @import_file  VARCHAR(500)  -- include path, (and range if XL)
   ,@clr_first    BIT
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)   = 'IMPRT_LRAP_FILE_XLS_221018'
   ,@row_cnt      INT
   ,@table        VARCHAR(35)   = 'Staging1'
   ,@table_exists INT

   EXEC sp_log 1, @fn, '00: starting
import_file:[', @import_file, ']
clr_first  :[', @clr_first  , ']
';

   --EXEC sp_register_call @fn;
   --------------------------------------------------------------------
   -- Processing start'
   --------------------------------------------------------------------
   SET @table_exists = dbo.fnTableExists(@table);
   EXEC sp_assert_equal 1, @table_exists, 'table ', @table, ' does not exist';

   ----------------------------------------------------------------------------
   -- 1. import the LRAP register file using the appropriate format importer
   ----------------------------------------------------------------------------
   -- 230721: new format
      EXEC sp_log 2, @fn, '15: import the LRAP register file (221018 fmt)';
      EXEC sp_import_file
          @import_file  = @import_file
         ,@table        = @table
--         ,@range        = @range
         ,@fields       = NULL         -- for XL: comma separated list
         ,@clr_first    = 1            -- if 1 then delete the table contents first
         ,@is_new       = 0            -- if 1 then create the table - this is a double check
         ,@expect_rows  = @clr_first   -- optional @expect_rows to assert has imported rows
         ,@row_cnt      = @row_cnt OUT  -- optional count of imported rows
         ;

   --------------------------------------------------------------------
   -- Processing complete'
   --------------------------------------------------------------------
   EXEC sp_log 2, @fn,'80: processing complete';
END
   EXEC sp_log 1, @fn, '99: leaving';
/*
EXEC sp_Import_CallRegister 'D:\Dev\Repos\Farming\Data\CallRegister.xlsx';
EXEC sp_reset_CallRegister;
EXEC sp_import_LRAP_file_xls_221018 'D:\Dev\Repos\Farming\Data\LRAP-221018-230813.xlsx', 'LRAP-221018 230813$A:N';
SELECT * FROM staging1;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================
-- Author:      Terry Watts
-- Create date: 15-MAR-2024
-- Description:
--    Imports the LRAP data xls file, format spec = 221018
--
-- PRECONDITIONS: 
-- file format spec = 221018
-- S1 and S2 are truncted
--
-- POSTCONDITIONS:
-- POST 01: S1 populated, s2 not
--
-- RESPONSIBILITIES:
-- R01: Clear the S1 and S2 tables
-- R02: Import the LRAP data file
-- R03: assign the import id to new data
--
-- TESTS:
--
-- CHANGES:
-- 
-- ======================================================================================
CREATE PROCEDURE [dbo].[sp_import_LRAP_file_xls_230721]
    @import_file  VARCHAR(500)  -- include path, (and range if XL)
   ,@clr_first    BIT
   --    ,@range        VARCHAR(100)  = N'Sheet1$'
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)   = 'IMPRT_LRAP_FILE_XLS_230721'
   ,@row_cnt         INT

   EXEC sp_log 1, @fn, '00: starting
import_file:[',@import_file,']
clr_first  :[', @clr_first  , ']
';

   --EXEC sp_register_call @fn;

   --------------------------------------------------------------------
   -- Processing start'
   --------------------------------------------------------------------
--   SET @range = ut.dbo.fnFixupXlRange(@range);

   ----------------------------------------------------------------------------
   -- 1. import the LRAP register file using the appropriate format importer
   ----------------------------------------------------------------------------
   -- 230721: new format
      EXEC sp_log 2, @fn, '15: import the LRAP register file (221018 fmt)';
      EXEC sp_import_file
          @import_file  = @import_file
         ,@table        = 'Staging1'
--         ,@range        = @range
         ,@fields       = NULL         -- for XL: comma separated list
         ,@clr_first    = 1            -- if 1 then delete the table contents first
         ,@is_new       = 0            -- if 1 then create the table - this is a double check
         ,@expect_rows  = 1            -- optional @expect_rows to assert has imported rows
         ,@row_cnt      = @row_cnt OUT  -- optional count of imported rows
         ;

   --------------------------------------------------------------------
   -- Processing complete'
   --------------------------------------------------------------------
   EXEC sp_log 2, @fn,'80: processing complete';
END
   EXEC sp_log 1, @fn, '99: leaving';
/*
EXEC sp_import_LRAP_file_xls_230721 'D:\Dev\Repos\Farming\Data\LRAP-231025-231103.xlsx';
SELECT * FROM staging1;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[CallRegister](
	[id] [int] NOT NULL,
	[rtn] [varchar](50) NULL,
	[limit] [int] NULL,
	[count] [int] NULL,
	[updated] [datetime] NULL,
 CONSTRAINT [PK_SessionContext] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].[CallRegister] ADD  CONSTRAINT [DF_SessionContext_count]  DEFAULT ((0)) FOR [count]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =====================================================================================
-- Author       Terry Watts
-- Create date: 07-FEB-2024
-- Description: Registers a routine call and checks the call count against the limit
--
-- CHECKED PRECONDITIONS: PRE 01: @rtn must be registered
--
-- Changes:
-- 240414: faciltate multiple calls for example as in testing tSQLt.Runall
-- =====================================================================================
CREATE   PROCEDURE [dbo].[sp_register_call]
   @rtn VARCHAR(128)
AS
BEGIN
   DECLARE
       @fn VARCHAR(35) = 'REGISTER_CALL'
      ,@error_msg VARCHAR(500)
      ,@key       VARCHAR(128)
      ,@count     INT
      ,@limit     INT
      ,@enforce_single_call_flg BIT = COALESCE(dbo.fnGetSessionContextAsInt(N'ENFORCE_SINGLE_CALL'), 1);

   SET NOCOUNT ON;

   -- If testing ignore the single call system
   IF @enforce_single_call_flg = 0
      RETURN;

   SELECT
       @count = [count]
      ,@limit = limit
   FROM CallRegister
   WHERE rtn = @rtn;

   IF @count IS NOT NULL
   BEGIN
      SET @limit = (SELECT limit FROM CallRegister WHERE rtn = @rtn);

      -- Increment the call count
      UPDATE CallRegister 
      SET
         [count] = @count + 1
         ,updated = GetDate()
      WHERE rtn = @rtn;

      if(@count >= @limit)
      BEGIN
         SET @error_msg = CONCAT(@rtn, ' has already been called ',@limit,' times - this is the call limit for this routine');
         EXEC sp_log 4, @fn, @error_msg;
         THROW 56214, @error_msg, 1;
      END

   END
   ELSE
   BEGIN
      -- CHECKED PRECONDITIONS: PRE 01: @rtn must be registered
      SET @error_msg = CONCAT('The routine: ',@rtn, ' has not been registered');
      EXEC sp_log 4, @fn, @error_msg;
      THROW 53948, @error_msg, 1;
   END

   SET NOCOUNT OFF;
END


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================
-- Author:      Terry Watts
-- Create date: 15-MAR-2024
--    2. imports the LRAP register Excel file
-- PRECNDITIONS: S1, S2 truncated
-- POSTCONDITIONS:
-- POST 01:
-- TESTS:
-- CHANGES:
-- ======================================================================================
CREATE PROCEDURE [dbo].[sp_import_LRAP_file_xls]
    @import_file  VARCHAR(500)  -- include path, (and range if XL)
   ,@import_id    INT = 1-- handles imports ids: acceptable values: (1,2) {1:221018, 2:230721} default: 221018
   ,@clr_first    BIT
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)   = 'IMPRT_LRAP_FILE_XLS'
   ,@error_msg    VARCHAR(500)
   ,@is_xl        BIT

   --SET @import_id = dbo.fnGetImportIdFromName(@import_file);

   EXEC sp_log 1, @fn, '00: starting
import_file:[',@import_file,']
import_id:  [',@import_id     ,']';

   BEGIN TRY
      EXEC sp_register_call @fn;

      --------------------------------------------------------------------
      -- Processing start'
      --------------------------------------------------------------------
      --SET @range = dbo.fnFixupXlRange(@range);

      ------------------------------------------------------------------------------
      -- 3. import the LRAP register file using the appropriate format importer
      ------------------------------------------------------------------------------
      ----------------------------------------------------------------------------
      -- 1. import the LRAP register file using the appropriate format importer
      ----------------------------------------------------------------------------
      -- 230721: new format
      IF      @import_id = 1 -- 221018
      BEGIN -- currently only 2 versions: 221018, 230721. default: 221018
         EXEC sp_log 2, @fn, '15: import the LRAP register file (221018 fmt)';
         EXEC sp_import_LRAP_file_xls_221018 @import_file, @clr_first;
      END
      ELSE IF @import_id = 2 -- 230721
      BEGIN
         EXEC sp_log 2, @fn, '20: import the LRAP register file (230721 fmt)';
         EXEC sp_import_LRAP_file_xls_230721 @import_file, @clr_first;
      END
      ELSE -- Unrecognised import id
      BEGIN
         SET @error_msg = CONCAT('Unrecognised import id: ', @import_id);
         EXEC sp_log 4, @fn, '25: ', @error_msg;
         EXEC sp_raise_exception 56471, @error_msg;
      END

      --------------------------------------------------------------------
      -- Processing complete';
      --------------------------------------------------------------------
      EXEC sp_log 2, @fn,'80: processing complete';
      END TRY
      BEGIN CATCH
         EXEC sp_log_exception @fn;
         THROW;
      END CATCH
END
   EXEC sp_log 1, @fn, '99: leaving';
/*
EXEC sp_Reset_CallRegister;
EXEC sp_import_LRAP_file_xls 
    @LRAP_data_file  = 'D:\Dev\Repos\Farming_Dev\Data\LRAP-221018-230813.xlsx'
   ,@range           = 'LRAP-221018 230813$A:N'
   ,@import_id       = 221018;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[staging1](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[company] [varchar](500) NULL,
	[ingredient] [varchar](500) NULL,
	[product] [varchar](200) NULL,
	[concentration] [varchar](200) NULL,
	[formulation_type] [varchar](20) NULL,
	[uses] [varchar](200) NULL,
	[toxicity_category] [varchar](200) NULL,
	[registration] [varchar](100) NULL,
	[expiry] [varchar](200) NULL,
	[entry_mode] [varchar](200) NULL,
	[crops] [varchar](500) NULL,
	[pathogens] [varchar](1000) NULL,
	[rate] [varchar](200) NULL,
	[mrl] [varchar](200) NULL,
	[phi] [varchar](200) NULL,
	[phi_resolved] [varchar](120) NULL,
	[reentry_period] [varchar](250) NULL,
	[notes] [varchar](250) NULL,
	[comments] [varchar](500) NULL,
	[created] [datetime] NULL,
 CONSTRAINT [PK_staging1] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================================================
-- Author:      Terry Watts
-- Create date: 08-AUG-2023
-- Description: General import rtn for all LRAP imports
--
-- PRECONDITIONS: none
--
-- POSTCONDITIONS:
--    Ready to call the fixup routne
--
-- ERROR HANDLING by exception handling
--
-- CHANGES:
-- 231103: turned auto increment off so SET IDENTITY_INSERT ON/OFF not needed
-- 241006: increased max error count from default 10 to 1000
-- =============================================================================
CREATE   PROCEDURE [dbo].[sp_bulk_insert_LRAP]
    @import_tsv_file VARCHAR(360)
   ,@view            VARCHAR(60)
   ,@clr_first       BIT
AS
BEGIN
DECLARE
    @fn              VARCHAR(35)   = N'sp_bulk_insert_LRAP'
   ,@sql             NVARCHAR(4000)
   ,@RC              INT            = -1
   ,@error_msg       VARCHAR(500)
   ,@rowcnt          INT            = -1
   ,@cmd             NVARCHAR(4000)
   ,@notepad_path    VARCHAR(500)  = '"C:\Program Files\Notepad++\notepad++.exe" '
   ,@bckslsh         VARCHAR(1)    = NCHAR(92)
   ,@tab             VARCHAR(1)    = NCHAR(9)
   ,@nl              VARCHAR(2)    = NCHAR(13) + NCHAR(10)
   ;

   EXEC sp_log 2, @fn, '000:starting:
@import_tsv_file:[', @import_tsv_file, ']
@view           :[',@view            , ']
clr_first       :[',@clr_first       ,']
';

   BEGIN TRY
      EXEC sp_log 1, @fn, '010: deleting log files';
      SET @cmd = CONCAT('DEL D:',@bckslsh,'Logs',@bckslsh,'LRAPImportErrors.log.Error.Txt');
      EXEC xp_cmdshell @cmd, NO_OUTPUT;
      SET @cmd = CONCAT('DEL D:',@bckslsh,'Logs',@bckslsh,'LRAPImportErrors.log');
      EXEC xp_cmdshell @cmd, NO_OUTPUT;
      EXEC sp_log 2, @fn, '020: about to import ',@import_tsv_file;

      SET @sql = CONCAT(
         'BULK INSERT ',@view,' FROM ''', @import_tsv_file, '''
          WITH
          (
             FIRSTROW = 2
            ,FIELDTERMINATOR = ''',@tab,'''
            ,ROWTERMINATOR   = ''',@nl,'''   
            ,ERRORFILE       = ''D:',@bckslsh,'Logs',@bckslsh,'LRAPImportErrors.log''
            ,MAXERRORS       = 30
          );'
         );

         EXEC sp_log 2, @fn, '025: import sql:
', @sql;

        EXEC @RC = sp_executesql @sql;
        SET @rowcnt = @@ROWCOUNT;
        EXEC sp_log 2, @fn, '030: imported ',@import_tsv_file, ' ', @rowcnt, ' rows',@row_count=@rowcnt;

        IF @RC <> 0
        BEGIN
            SET @error_msg = CONCAT('import had errors: :', @RC, '
            Error mmsg: ', ERROR_MESSAGE(),
            ' File: ', @import_tsv_file);

            EXEC sp_log 4, @fn, '10: ', @error_msg;
            RETURN @RC;

            SET @cmd = CONCAT(@notepad_path, 'D:',@bckslsh,'Logs',@bckslsh,'LRAPImportErrors.log.Error.Txt')
            EXEC xp_cmdshell @cmd;
            SET @cmd = CONCAT(@notepad_path, 'D:',@bckslsh,'Logs',@bckslsh,'LRAPImportErrors.log')
            EXEC xp_cmdshell @cmd;
        END

      UPDATE staging1 
      SET created = FORMAT (getdate(), 'yyyy-MM-dd hh:mm')

   END TRY
   BEGIN CATCH
      SET @error_msg = Error_Message();
      EXEC sp_log 4, @fn, '50: caught exception: ',@error_msg;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '99: Bulk_insert of [', @import_tsv_file, ' leaving';
   RETURN @RC;
END
/*
TRUNCATE TABLE Staging1 
EXEC sp_bulk_insert_LRAP 'D:\Dev\Repos\Farming\Data\LRAP-231025-231103.txt', 'RegisteredPesticideImport_230721_vw', '2'
SELECT * FROM staging1 -- WHERE Id > 5710;
SELECT * FROM RegisteredPesticideImport_230721_vw
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ========================================================
-- Author:      Terry Watts
-- Create date: 01-AUG-2023
--
-- Description: Imports the Ph Dep Ag Pesticide register FMT: 230721 into S1
-- This imports each entire row into the staging1 table
--
-- PROCESS:
-- 1. download the Ph DepAg Registered Pesticides LRAP-221018.pdf from the Ph GovT Pha site
-- 2. exportentire pdf to Excel
-- 3. export as a tsv
-- 4.replace the singly LF line endings using notepad++:
-- 4.1:  replace ([^\r])\n  with \1
-- 4.2: save (and close) the file to the exports\tsv folder: D:\Data\Biz\Banana Farming\LRAP EXPORTS-221018\TSVs
--
-- 5: SQL Server:
-- 5.1 run EXEC [dbo].[sp_bulk_insert_Ph DepAg Registered Pesticides LRAP] 'D:\Data\Biz\Banana Farming\LRAP EXPORTS-221018\TSVs\Ph DepAg Registered Pesticides LRAP-221018 001-099.tsv'
-- 6. run [dbo].[sp_process Ph DepAg Registered Pesticides LRAP]
--
-- PRECONDITIONS:
--    rows with this version already deleted
--
-- POSTCONDITIONS:
--    CovidStaging1 staging column populated with the entire import row
--
-- Tests:
--    [test 012 sp_jh_imp_stg_1_bulk_insert]
-- ========================================================
CREATE PROCEDURE [dbo].[sp_bulk_insert_pesticide_register_221018]
    @import_file VARCHAR(360)
   ,@clr_first       BIT
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)   = N'_BLK_INSRT PEST REG 221018'
   ,@RC              INT            = -1

   EXEC sp_log 2, @fn, '000: starting
import_file:[',@import_file,']
clr_first  :[',@clr_first  ,']
';
   EXEC @RC = sp_bulk_insert_LRAP @import_tsv_file = @import_file, @view='RegisteredPesticideImport_221018_vw', @clr_first=@clr_first;--, @import_nm='221018';
   EXEC sp_log 2, @fn, '99; return OK, bulk_insert of @import_file';
   RETURN @RC;
END
/*
TRUNCATE TABLE Staging1;
EXEC sp_bulk_insert_pesticide_register_221018 'D:\Dev\Repos\Farming\Data\Ph DepAg Registered Pesticides LRAP-221018 Export\LRAP-221018 230809-0815.tsv';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==============================================================================================================================================================================
-- Author:      Terry Watts
-- Create date: 19-JUN-2023
--
-- Description: Imports the Ph Dep Ag Pesticide register
-- staging table temp
-- This imports each entire row into the stagingcolumn
--
-- CALLEd BY: sp__main_import_pesticide_register
--
-- PROCESS:
-- 1. download the Ph DepAg Registered Pesticides LRAP-221018 001-099.pdf from
-- 2. split it down into 100 page pdfs as is too large for conversion 
-- 2.1: by using the pro pdf editor / edit/ Organise pages/select first 100 pages/ right click /Extract  {delete after extract} and OK to R U sure U want to delete pages 1-99
-- 2.2: save: choose a different location like: Ph DepAg Registered Pesticides LRAP-221018 001-099.pdf
-- 2.3: repeat the above steps till no pages left
-- 2.2: then extracted file like Ph DepAg Registered Pesticides LRAP-221018 001-099.tsv
-- 3. export each 100 page section pdf to Excel
-- 4. use Excel to:
-- 4.1 add 2 columns at the start sht, row and populate the sheet no (int) and the row number - 1-30 for each row on the sheet
-- 4.2 export as a tsv
-- 5: replace the singly LF line endings using notepad++:
-- 5.1:  replace ([^\r])\n  with \1
-- 5.2: save (and close) the file to the exports\tsv folder: D:\Data\Biz\Banana Farming\LRAP EXPORTS-221018\TSVs
-- 6: SQL Server
-- 6.1 run EXEC [dbo].[sp_bulk_insert_Ph DepAg Registered Pesticides LRAP] 'D:\Data\Biz\Banana Farming\LRAP EXPORTS-221018\TSVs\Ph DepAg Registered Pesticides LRAP-221018 001-099.tsv'
-- 7. run [dbo].[sp_process Ph DepAg Registered Pesticides LRAP]
--
-- PRECONDITIONS:
--    rows with this version already deleted
--
-- POSTCONDITIONS:
--    CovidStaging1 staging column populated with the entire import row
--
-- Tests:
--    [test 012 sp_jh_imp_stg_1_bulk_insert]
-- ==============================================================================================================================================================================
CREATE PROCEDURE [dbo].[sp_bulk_insert_pesticide_register_230721]
    @imprt_csv_file    VARCHAR(360)
   ,@clr_first    BIT
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)   = N'BLK_INSRT PEST REG 230721'
      ,@RC        INT            = -1
      ,@import_nm VARCHAR(20)

   --SET @import_nm = dbo.fnGetSessionValueImportId();

   EXEC sp_log 2, @fn, '000: starting
imprt_csv_file:[',@imprt_csv_file, ']
clr_first     :[',@clr_first,      ']
';

   --EXEC sp_register_call @fn;
   EXEC @RC = sp_bulk_insert_LRAP @imprt_csv_file, 'RegisteredPesticideImport_230721_vw',@clr_first=@clr_first;
   EXEC sp_log 2, @fn, 'Bulk_insert of [', @imprt_csv_file, ' leaving, @RC: ', @RC;
   RETURN @RC;
END
/*
EXEC sp_bulk_insert_pesticide_register_230721 'D:\Dev\Repos\Farming\Data\LRAP-231025-231103.txt';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================================================================================================================
-- Author:      Terry Watts
-- Create date: 05-OCT-2024
--
-- Description: Imports the Ph Dep Ag Pesticide register version 240502, 240910
-- to the staging table
--
-- CALLEd BY: sp__main_import_pesticide_register
--
-- PROCESS:
-- 1. download the Ph DepAg Registered Pesticides LRAP-221018 001-099.pdf from
-- 2. split it down into 100 page pdfs as is too large for conversion 
-- 2.1: by using the pro pdf editor / edit/ Organise pages/select first 100 pages/ right click /Extract  {delete after extract} and OK to R U sure U want to delete pages 1-99
-- 2.2: save: choose a different location like: Ph DepAg Registered Pesticides LRAP-221018 001-099.pdf
-- 2.3: repeat the above steps till no pages left
-- 2.2: then extracted file like Ph DepAg Registered Pesticides LRAP-221018 001-099.tsv
-- 3. export each 100 page section pdf to Excel
-- 4. use Excel to:
-- 4.1 add 2 columns at the start sht, row and populate the sheet no (int) and the row number - 1-30 for each row on the sheet
-- 4.2 export as a tsv
-- 5: replace the singly LF line endings using notepad++:
-- 5.1:  replace ([^\r])\n  with \1
-- 5.2: save (and close) the file to the exports\tsv folder: D:\Data\Biz\Banana Farming\LRAP EXPORTS-221018\TSVs
-- 6: SQL Server
-- 6.1 run EXEC [dbo].[sp_bulk_insert_Ph DepAg Registered Pesticides LRAP] 'D:\Data\Biz\Banana Farming\LRAP EXPORTS-221018\TSVs\Ph DepAg Registered Pesticides LRAP-221018 001-099.tsv'
-- 7. run [dbo].[sp_process Ph DepAg Registered Pesticides LRAP]
--
-- PRECONDITIONS:
--    rows with this version already deleted
--    the import file has an added row id column and all column single LF EOL have been removed
--
-- POSTCONDITIONS:
--    CovidStaging1 staging column populated with the entire import row
--
-- Tests:
--    
-- ==============================================================================================================================================================================
CREATE   PROCEDURE [dbo].[sp_bulk_insert_pesticide_register_240502]
     @imprt_csv_file    VARCHAR(360)
   ,@clr_first    BIT
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)   = N'BLK_INSRT PEST REG 240502'
      ,@RC        INT            = -1
      ,@import_nm VARCHAR(20)

   --SET @import_nm = dbo.fnGetSessionValueImportId();

   EXEC sp_log 2, @fn, '000: starting
imprt_csv_file:[',@imprt_csv_file, ']
clr_first     :[',@clr_first,      ']
]';

   EXEC @RC = sp_bulk_insert_LRAP @imprt_csv_file, 'RegisteredPesticideImport_230721_vw',@clr_first=@clr_first;--, @import_nm;
   EXEC sp_log 2, @fn, 'Bulk_insert of [', @imprt_csv_file, ' leaving, @RC: ', @RC;
   RETURN @RC;
END
/*-------------------------------------------------------------------------------------------
EXEC sp_reset_callRegister;
TRUNCATE TABLE staging1;
EXEC sp_bulk_insert_pesticide_register_240502 'D:\Dev\Farming\Data\LRAP-240910.txt';
SELECT * FROM staging1;

   DECLARE
       @fn              VARCHAR(35)   = N'BLK INSRT LRAP'
      ,@cmd             VARCHAR(4000)
      ,@notepad_path    VARCHAR(500) = '"C:\program Files\notepad++\notepad++.exe" '

   SET @cmd = CONCAT('''', '"C:\bin\SQL_Notepad.bat" ', ' D:\Logs\LRAPImportErrors.log.Error.Txt''');
   PRINT @cmd;
   EXEC xp_cmdshell @cmd;

EXEC xp_cmdshell '"C:\bin\SQL_Notepad.bat"  D:\Logs\LRAPImportErrors.log.Error.Txt'

-------------------------------------------------------------------------------------------
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================================================
-- Author:      Terry Watts
-- Create date: 15-MAR-2024
-- Description:
--    Imports the LRAP register tab separated data file based on format spec (@import_id)
--    Can be either .xlsx or tab separated file (.txt)
--
-- PRECONDITIONS: 
-- S1 and S2 are truncted
--
-- POSTCONDITIONS:
-- POST 01: S1 populated, s2 not
--
-- RESPONSIBILITIES:
-- R01: Clear the S1 and S2 tables
-- R02: Import the LRAP data file
-- R03: assign the import id to new data
--
-- TESTS:
-- CHANGES:
-- ======================================================================================
CREATE   PROCEDURE [dbo].[sp_import_LRAP_file_tsv]
    @import_file  VARCHAR(500)        -- include path, (and range if XL)
   ,@import_id    INT  -- handles imports ids {1:221018, 2:230721} default: 221018
   ,@clr_first    BIT
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)   = 'sp_import_LRAP_file_tsv'
      ,@is_xl     BIT

   EXEC sp_log 2, @fn, '000: starting
import_file:[',@import_file,']
import_id:  [',@import_id  ,']
clr_first  :[',@clr_first  ,']
';

   --EXEC sp_register_call @fn;

   BEGIN TRY
      --------------------------------------------------------------------
      -- Processing start'
      --------------------------------------------------------------------

      ----------------------------------------------------------------------------
      -- 1. import the LRAP register file using the appropriate format importer
      ----------------------------------------------------------------------------
      -- 230721: new format
      IF      @import_id = 1 -- 221018
      BEGIN -- currently only 2 versions: 221018, 230721. default: 221018
         EXEC sp_log 2, @fn, '010: calling sp_bulk_insert_pesticide_register_221018 ', @import_file;
         EXEC sp_bulk_insert_pesticide_register_221018 @import_file,@clr_first;
      END
      ELSE IF @import_id = 2 -- 230721
      BEGIN
         EXEC sp_log 2, @fn, '020: calling sp_bulk_insert_pesticide_register_230721 ', @import_file;
         EXEC sp_bulk_insert_pesticide_register_230721 @import_file,@clr_first;
      END
      ELSE IF @import_id = 3 -- 230721
      BEGIN
         EXEC sp_log 2, @fn, '030: calling sp_bulk_insert_pesticide_register_240502 ', @import_file;
         EXEC sp_bulk_insert_pesticide_register_240502 @import_file,@clr_first;
      END
      ELSE -- Unrecognised import id
      BEGIN
         EXEC sp_raise_exception 56471, '500 Unrecognised import id: ', @import_id,@fn=@fn;
      END
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   --------------------------------------------------------------------
   -- Processing complete'
   --------------------------------------------------------------------
   EXEC sp_log 2, @fn, '900: processing complete';
   EXEC sp_log 2, @fn, '999: leaving';
END
/*
EXEC sp_Reset_CallRegister;
EXEC sp_import_LRAP_file_tsv 'D:\Dev\Farming\Data\LRAP-240910.txt', 3;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==================================================================
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- Description: returns the file row id key for the current s2 fixup
-- ==================================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupStgIdKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'FIXUP_STG_ID';
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==============================================================
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- Description: returns the file row id for the current s2 fixup
-- ==============================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupStgId]()
RETURNS INT
AS
BEGIN
   RETURN dbo.fnGetSessionContextAsInt(dbo.fnGetCtxFixupStgIdKey());
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ============================================================
-- Author:      Terry Watts
-- ALTER date: 06-JAN-2025
-- Description: returns the current s2 fixup search clause key
-- ============================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupRepClsKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'REPLACE_CLAUSE';
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ============================================================
-- Author:      Terry Watts
-- Create date: 27-DEC-2021
-- Description: Get session context as a string 
-- RETURNS      value for the key if pressent in 
--              the session map or NULL if not exists
--
-- See Also: fnGetSessionContextAsInt, sp_set_session_context
-- ============================================================
CREATE   FUNCTION [dbo].[fnGetSessionContextAsString](@key NVARCHAR(100))
RETURNS VARCHAR(MAX)
BEGIN
   RETURN CONVERT(VARCHAR(MAX), SESSION_CONTEXT(@key));
END
/*
EXEC sp_set_session_context N'Debug', '1';
PRINT dbo.fnGetSessionContextAsString(N'Debug');
PRINT dbo.fnGetSessionContextAsInt(N'Debug');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =========================================================
-- Author:      Terry Watts
-- ALTER date: 06-JAN-2025
-- Description: returns the current s2 fixup search clause
-- =========================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupRepCls]()
RETURNS NVARCHAR(500)
AS
BEGIN
   RETURN dbo.fnGetSessionContextAsString(dbo.fnGetCtxFixupRepClsKey());
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===========================================================================================
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- Description: returns the rtn log level key for the given UQ rtn name in the session context
-- ===========================================================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupRowIdKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'FIXUP_ROW_ID';
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===========================================================================================
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- Description: returns the rtn log level key for the given UQ rtn name in the session context
-- ===========================================================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupRowId]()
RETURNS INT
AS
BEGIN
   RETURN dbo.fnGetSessionContextAsInt(dbo.fnGetCtxFixupRowIdKey());
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ============================================================
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- Description: returns the current s2 fixup search clause key
-- ============================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupSrchClsKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'SEARCH_CLAUSE';
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =========================================================
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- Description: returns the current s2 fixup search clause
-- =========================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupSrchCls]()
RETURNS NVARCHAR(500)
AS
BEGIN
   RETURN dbo.fnGetSessionContextAsString(dbo.fnGetCtxFixupSrchClsKey());
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==================================================================
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- Description: returns the file row id key for the current s2 fixup
-- ==================================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupFileKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'FIXUP_FILE_NM';
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==============================================================
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- Description: returns the file row id for the current s2 fixup
-- ==============================================================
CREATE FUNCTION [dbo].[fnGetCtxFixupFile]()
RETURNS NVARCHAR(500)
AS
BEGIN
   RETURN dbo.fnGetSessionContextAsString(dbo.fnGetCtxFixupFileKey());
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[S2UpdateLog](
	[_id] [int] IDENTITY(1,1) NOT NULL,
	[fixup_id] [int] NULL,
	[id] [int] NULL,
	[old_pathogens] [varchar](400) NULL,
	[new_pathogens] [varchar](400) NULL,
	[old_crops] [varchar](400) NULL,
	[new_crops] [varchar](400) NULL,
	[old_entry_mode] [varchar](100) NULL,
	[new_entry_mode] [varchar](100) NULL,
	[old_chemical] [varchar](100) NULL,
	[new_chemical] [varchar](100) NULL,
 CONSTRAINT [PK_S2UpdateLog] PRIMARY KEY CLUSTERED 
(
	[_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_S2UpdateLog_fixup_id] ON [dbo].[S2UpdateLog]
(
	[fixup_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_S2UpdateLog_s2] ON [dbo].[S2UpdateLog]
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[S2UpdateSummary](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[fixup_row_id] [int] NULL,
	[imp_file_nm] [varchar](255) NULL,
	[xl_row] [int] NULL,
	[row_cnt] [int] NULL,
	[search_clause] [varchar](255) NULL,
	[replace_clause] [varchar](255) NULL,
 CONSTRAINT [PK_S2UpdateSummary] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_S2UpdateSummary_fixup] ON [dbo].[S2UpdateSummary]
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_S2UpdateSummary_rows] ON [dbo].[S2UpdateSummary]
(
	[row_cnt] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

GO
GO

CREATE TYPE [dbo].[staging2_tbl] AS TABLE(
	[id] [int] NOT NULL,
	[company] [varchar](70) NULL,
	[ingredient] [varchar](250) NULL,
	[product] [varchar](100) NULL,
	[concentration] [varchar](100) NULL,
	[formulation_type] [varchar](7) NULL,
	[uses] [varchar](100) NULL,
	[toxicity_category] [int] NULL,
	[registration] [varchar](65) NULL,
	[expiry] [varchar](30) NULL,
	[entry_mode] [varchar](60) NULL,
	[crops] [varchar](250) NULL,
	[pathogens] [varchar](360) NULL,
	[rate] [varchar](200) NULL,
	[mrl] [varchar](200) NULL,
	[phi] [varchar](200) NULL,
	[phi_resolved] [varchar](120) NULL,
	[reentry_period] [varchar](250) NULL,
	[notes] [varchar](250) NULL,
	[comments] [varchar](500) NULL,
	[created] [datetime] NULL,
	PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (IGNORE_DUP_KEY = OFF)
)

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =========================================================================
-- Description: handles the loggong and cjecks during the S2 fixup process
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:      
-- Tests:       
-- Author:      Terry Watts
-- Create date: 08-FEB-2025
-- =========================================================================
CREATE PROCEDURE [dbo].[sp_update_trigger_s2_crops]
    @inserted staging2_tbl READONLY
   ,@deleted  staging2_tbl READONLY
AS
BEGIN
   SET NOCOUNT ON;

   DECLARE
    @fn               VARCHAR(35) = N'S2_UPDATE_TRIGGER'
   ,@fixup_row_id     INT       -- xl row id
   ,@imp_file_nm      VARCHAR(400)
   ,@msg              VARCHAR(4000)
   ,@nl               VARCHAR(2) = CHAR(13) + CHAR(10)
   ,@new_crops        VARCHAR(4000)
   ,@old_crops        VARCHAR(4000)
   ,@replace_clause   VARCHAR(4000)
   ,@row_cnt          INT
   ,@search_clause    VARCHAR(4000)
   ,@xl_row           INT       -- xl row id
   ;

   SELECT @row_cnt = COUNT(*) FROM @inserted;

   SET @fixup_row_id   = dbo.fnGetCtxFixupRowId();
   SET @search_clause  = dbo.fnGetCtxFixupSrchCls();
   SET @replace_clause = dbo.fnGetCtxFixupRepCls();
   SET @xl_row         = dbo.fnGetCtxFixupStgId();
   SET @imp_file_nm    = dbo.fnGetCtxFixupFile();

   EXEC sp_log 1, @fn, '000: starting @fixup_row_id: ',@fixup_row_id, ', @imp_file_nm: [',@imp_file_nm, '], @fixup_stg_id: ', @xl_row, ', @search_clause: [',@search_clause,']';

   ---------------------------------------------------------------------------------------
   -- Log update summary
   ---------------------------------------------------------------------------------------
   INSERT INTO S2UpdateSummary 
          (fixup_row_id, xl_row, row_cnt, search_clause, replace_clause, imp_file_nm)
   SELECT @fixup_row_id,@xl_row,@row_cnt,@search_clause,@replace_clause,@imp_file_nm;

   EXEC sp_log 1, @fn, '010: @fixup_row_id: ',@fixup_row_id;

   ---------------------------------------------------------------------------------------
   -- Log update details
   ---------------------------------------------------------------------------------------
   INSERT INTO S2UpdateLog (fixup_id, id, old_pathogens, new_pathogens, old_crops, new_crops, old_entry_mode, new_entry_mode, old_chemical, new_chemical)
   SELECT @fixup_row_id, d.id, d.pathogens, i.pathogens,d.crops, i.crops,d.entry_mode, i.entry_mode,d.ingredient,i.ingredient
   FROM @inserted i JOIN @deleted d ON i.id=d.id
   WHERE i.pathogens <> d.pathogens OR i.crops<> d.crops;

   -- Once inserted in to the log tables run invariant chks
   IF @imp_file_nm LIKE '%Crops%'
   BEGIN
      
      IF EXISTS 
      (
         SELECT 1 FROM @inserted i JOIN @deleted d ON i.id = d.id
         WHERE i.crops LIKE '%beanbean%' AND d.crops NOT LIKE '%beanbean%'
      )
      BEGIN
         SELECT @imp_file_nm AS [file], @fixup_row_id AS fixup_row, @xl_row, i.id
         ,i.entry_mode AS i_entry_mode, d.entry_mode AS d_entry_mode
         ,i.crops AS i_crops, d.crops AS d_crops
         FROM @inserted i JOIN @deleted d ON i.id = d.id
         ;

         SELECT TOP  1
          @new_crops = i.crops
         ,@old_crops = d.crops
         FROM @inserted i JOIN @deleted d ON i.id = d.id
         ;

         SET @msg = CONCAT(
          'update error beanbean'                , @nl
         ,'file:          ' ,@imp_file_nm        , @nl
         ,'row:           ' ,@xl_row             , @nl
         ,'search_clause  [',@search_clause, ']' , @nl
         ,'replace_clause:[',@replace_clause,']' , @nl
         ,'old crops:     [',@old_crops,']'      , @nl
         ,'new crops:     [',@new_crops,']'      , @nl
         );

         print CONCAT('019: *** ERROR:', @msg);
         EXEC sp_log 4, @fn, '020: ',@msg;
         EXEC sp_log 4, @fn, '021: '      , @nl
         ,'new crops:     [',@new_crops,']'      , @nl
         ;

         EXEC sp_raise_exception 53152, @msg, @fn=@fn;
      END
   END
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_<proc_nm>';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[staging2](
	[id] [int] NOT NULL,
	[company] [varchar](70) NULL,
	[ingredient] [varchar](250) NULL,
	[product] [varchar](100) NULL,
	[concentration] [varchar](100) NULL,
	[formulation_type] [varchar](7) NULL,
	[uses] [varchar](100) NULL,
	[toxicity_category] [int] NULL,
	[registration] [varchar](65) NULL,
	[expiry] [varchar](30) NULL,
	[entry_mode] [varchar](60) NULL,
	[crops] [varchar](250) NULL,
	[pathogens] [varchar](360) NULL,
	[rate] [varchar](200) NULL,
	[mrl] [varchar](200) NULL,
	[phi] [varchar](200) NULL,
	[phi_resolved] [varchar](120) NULL,
	[reentry_period] [varchar](250) NULL,
	[notes] [varchar](250) NULL,
	[comments] [varchar](500) NULL,
	[created] [datetime] NULL,
 CONSTRAINT [PK_staging2] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_s1_tst_221018_chemical] ON [dbo].[staging2]
(
	[ingredient] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_s1_tst_221018_crops] ON [dbo].[staging2]
(
	[crops] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_ss1_tst_221018_pathogens] ON [dbo].[staging2]
(
	[pathogens] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_staging2_chemical] ON [dbo].[staging2]
(
	[ingredient] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_staging2_crops] ON [dbo].[staging2]
(
	[crops] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_staging2_pathogens] ON [dbo].[staging2]
(
	[pathogens] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

ALTER TABLE [dbo].[staging2]  WITH CHECK ADD  CONSTRAINT [FK_staging2_staging1] FOREIGN KEY([id])
REFERENCES [dbo].[staging1] ([id])

ALTER TABLE [dbo].[staging2] CHECK CONSTRAINT [FK_staging2_staging1]

SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

-- =========================================================
-- Author:      Terry Watts
-- Create date: 30-JAN-2024
-- Description: debug aid - stores the current
--  corrections table fixup id stored  the session context
--  in S2UpdateLog
--  and inserts a summary row in the S2UpdateSummary table
-- It watches for changes in crops, entry_mode, pathogens
-- =========================================================
CREATE TRIGGER [dbo].[sp_Staging2_update_trigger]
ON [dbo].[staging2] AFTER UPDATE
AS
BEGIN

   DECLARE
       @inserted staging2_tbl
      ,@deleted  staging2_tbl

   INSERT INTO @inserted SELECT * FROM inserted;
   INSERT INTO @deleted  SELECT * FROM deleted;
   EXEC sp_update_trigger_s2_crops @inserted, @deleted

   RETURN;
END
/*
   SET NOCOUNT ON;
   DECLARE
    @fn               VARCHAR(35) = N'S2_UPDATE_TRIGGER'
   ,@fixup_row_id     INT       -- xl row id
   ,@imp_file_nm      VARCHAR(400)
   ,@msg              VARCHAR(200)
   ,@nl               VARCHAR(2) = CHAR(13) + CHAR(10)
   ,@new_crops        VARCHAR(200)
   ,@old_crops        VARCHAR(200)
   ,@replace_clause   VARCHAR(200)
   ,@row_cnt          INT
   ,@search_clause    VARCHAR(200)
   ,@xl_row           INT       -- xl row id

   SELECT @row_cnt = COUNT(*) FROM inserted;

   SET @fixup_row_id   = dbo.fnGetCtxFixupRowId();
   SET @search_clause  = dbo.fnGetCtxFixupSrchCls();
   SET @replace_clause = dbo.fnGetCtxFixupRepCls();
   SET @xl_row         = dbo.fnGetCtxFixupStgId();
   SET @imp_file_nm    = dbo.fnGetCtxFixupFile()
   EXEC sp_log 1, @fn, '000: starting @fixup_row_id: ',@fixup_row_id, ', @imp_file_nm: [',@imp_file_nm, '], @fixup_stg_id: ', @xl_row, ', @search_clause: [',@search_clause,']';

   ---------------------------------------------------------------------------------------
   -- Log update summary
   ---------------------------------------------------------------------------------------
   INSERT INTO S2UpdateSummary 
          (fixup_row_id, xl_row, row_cnt, search_clause, replace_clause, imp_file_nm)
   SELECT @fixup_row_id,@xl_row,@row_cnt,@search_clause,@replace_clause,@imp_file_nm;

   EXEC sp_log 1, @fn, '010: @fixup_row_id: ',@fixup_row_id;

   ---------------------------------------------------------------------------------------
   -- Log update details
   ---------------------------------------------------------------------------------------
   INSERT INTO S2UpdateLog (fixup_id, id, old_pathogens, new_pathogens, old_crops, new_crops, old_entry_mode, new_entry_mode, old_chemical, new_chemical)
   SELECT @fixup_row_id, d.id, d.pathogens, i.pathogens,d.crops, i.crops,d.entry_mode, i.entry_mode,d.ingredient,i.ingredient
   FROM deleted d JOIN inserted i ON d.id=i.id
   WHERE d.pathogens <> i.pathogens OR d.crops<> i.crops OR d.entry_mode <> i.entry_mode;

   -- Once inserted in to the log tables run invariant chks
   IF @imp_file_nm LIKE '%Crops%'
   BEGIN
      IF EXISTS 
      (
         SELECT 1 FROM inserted i JOIN deleted d ON i.id = d.id
         WHERE i.crops LIKE '%Green beansbeans%' AND d.crops NOT LIKE '%Green beansbeans%'
      )
--      OR (crops LIKE '%Lettuce and otherCrucifers%'))
      BEGIN
         SELECT @imp_file_nm AS [file], @fixup_row_id AS fixup_row, @xl_row, i.id
         ,i.entry_mode AS i_entry_mode, d.entry_mode AS d_entry_mode
         ,i.crops AS i_crops, d.crops AS d_crops
         FROM inserted i JOIN deleted d ON i.id = d.id
         ;

         SELECT TOP  1
          @new_crops = i.crops
         ,@old_crops = d.crops
         FROM inserted i JOIN deleted d ON i.id = d.id
         ;

         SET @msg = CONCAT(
          'update error'                         , @nl
         ,'file:          ' ,@imp_file_nm        , @nl
         ,'row:           ' ,@xl_row             , @nl
         ,'search_clause  [',@search_clause, ']' , @nl
         ,'replace_clause:[',@replace_clause,']' , @nl
         ,'new crops:     [',@new_crops,']'      , @nl
         ,'old crops:     [',@old_crops,']'      , @nl
         );

         EXEC sp_log 4, @fn, '020: ',@msg;
         EXEC sp_raise_exception 53152, @msg, @fn=@fn;
      END
   END
END
*/
/*
PRINT Ut.dbo.fnGetSessionContextAsInt(N'COR_LOG_FLG');
*/

ALTER TABLE [dbo].[staging2] ENABLE TRIGGER [sp_Staging2_update_trigger]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ========================================================================================
-- Author:      Terry Watts
-- Create date: 15-MAR-2023
-- Description: returns 1 if the the file name has an .xlsx extension, 0 otherwise
--    0 = case insensitive, 1 = case sensitive
--
-- Postconditions:
--   POST01: returns 1 if the the file name has an .xlsx extension, 0 otherwise
-- ========================================================================================
CREATE   FUNCTION [dbo].[fnIsExcel](@filePath VARCHAR(500))
RETURNS BIT
AS
BEGIN
   RETURN IIF( @filePath IS NULL OR CHARINDEX('.xlsx', @filePath) = 0, 0, 1);
END
/*
   EXEC test.test_fnIsExcel;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================
-- Procedure:   <proc_nm>
-- EXEC tSQLt.Run 'test.test_021_sp_import_LRAP_file';
-- Description:
--    1. imports 1 LRAP files
--    2. returns the incremented fixup count
--
-- Author:      Terry Watts
-- Create date: 15-MAR-2024
--
-- Design: EA: Model.Conceptual Model.LRAP Import
-- Tests:
---- Preconditions: none
--
-- Responsibilities:
-- R01: Clear the S1 and S2 tables
-- R02: Import the LRAP data file
--
-- Postconditions:
-- POST 01: Staging1 contains all the rows from the import files
--
-- Called by: LRAP_Imprt_S02_ImprtStaticData
--
-- Changes:
--
-- ======================================================================================
CREATE PROCEDURE [dbo].[sp_import_LRAP_file]
    @import_file  VARCHAR(500)  -- include path, (and range if XL)
   ,@import_id    INT            --  1,2,3,4
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)   = 'sp_import_LRAP_file'
      ,@is_xl     BIT

      --------------------------------------------------------------------
      -- Determine the file type
      --------------------------------------------------------------------
   SET @is_xl = dbo.fnIsExcel(@import_file);

   EXEC sp_log 2, @fn, '000: starting
import_file: [', @import_file, ']
import_id: [', @import_id, ']
is_xl:     [', @is_xl,']'
;

   BEGIN TRY
      --------------------------------------------------------------------
      -- R01: Clear the S1 and S2 tables
      --------------------------------------------------------------------
      -- Drop and recreate the FKs
      EXEC sp_log 1, @fn, '010: truncating S1, s2';
      ALTER TABLE [dbo].[staging2] DROP CONSTRAINT [FK_staging2_staging1]
      TRUNCATE TABLE Staging1;
      TRUNCATE TABLE Staging2;
      ALTER TABLE [dbo].[staging2] WITH CHECK ADD  CONSTRAINT [FK_staging2_staging1] FOREIGN KEY([id]) REFERENCES [dbo].[staging1] ([id])
      ALTER TABLE [dbo].[staging2] CHECK CONSTRAINT [FK_staging2_staging1]

      ------------------------------------------------------------------------------
      -- 3. R02: Incrementally import the File to S1
      ------------------------------------------------------------------------------
      if @is_xl = 1
      BEGIN
         -- is excel file
         EXEC sp_log 1, @fn, '020:importing xls: calling sp_import_LRAP_file_xls';
         EXEC sp_import_LRAP_file_xls @import_file, @import_id, @clr_first=0;
      END
      ELSE
      BEGIN
         -- is tsv file
         EXEC sp_log 1, @fn, '030:importing tsv: calling sp_import_LRAP_file_tsv';
         EXEC sp_import_LRAP_file_tsv @import_file, @import_id, @clr_first=0;
      END

      ------------------------------------------------------------------------------
      -- Validate postconditions
      ------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '050: validating postconditions';
      --POST 01: s1 contains rows
      EXEC sp_assert_tbl_pop 'staging1';
      EXEC sp_log 1, @fn, '060: ASSERTION: validated postconditions';

      --------------------------------------------------------------------
      -- Processing complete';
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn,'400: processing complete';
      END TRY
      BEGIN CATCH
         EXEC Ut.dbo.sp_log_exception @fn;
         THROW
      END CATCH
   EXEC sp_log 2, @fn, '999: leaving';
   END
/*
EXEC tSQLt.Run 'test.test_021_sp_import_LRAP_file';

EXEC tSQLt.RunAll;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==================================================================================================
-- Author:      Terry Watts
-- Create date: 31-JAN-2024
-- 
-- Description: Imports the corrections Excel file for the Ph Dep Ag Pesticide register
-- staging table 
-- This:
-- 1: imports the corrections data sheet: @imprt_xls_file into the ImportCorrectionsStaging table
-- NB does NOT truncate tables as it may be used many times with different files incrementally
-- RETURNS:
--    0 if OK, else OS error code
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
--    POST01: ImportCorrectionsStaging table clean populated or error
--    POST02: ImportCorrections truncated
--    POST03: @import_xls_file must exist OR exception 64871 thrown
--    POST04: openrowset cmd succeeded    OR exception 64872 thrown
--    POST05: at least 1 row was imported OR exception 64873 thrown
--
-- THROWS:
-- 64871 if @import_xls_file does not exist
-- 64872 if openrowset cmd errored
-- 64873 if no rows were imported
--
-- Tests:
--
-- Changes:
--    240201: changed to use direct XL import: sp_import_XL_existing
-- ==================================================================================================
CREATE   PROCEDURE [dbo].[sp_import_corrections_xls]
    @import_xls_file VARCHAR(360) -- Full path to import file
   ,@range           VARCHAR(100) = 'Sheet1$A:S'
   ,@row_cnt         INT           = -1   OUT
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)  = N'sp_import_corrections_xls'
   ,@sql             VARCHAR(MAX)
   ,@error_msg       VARCHAR(500)
   ,@file_exists     INT
   ;

   EXEC sp_log 2, @fn, '000: starting, 
file:  [', @import_xls_file, ']
@range:[',@range,']';

   BEGIN TRY
      -- Set defaults
      IF @range IS NULL SET @range = 'Sheet1$A:S'

      ----------------------------------------------------------------------------
      -- Parameter validation
      ----------------------------------------------------------------------------
      -- chk if file exists
      EXEC sp_log 1, @fn, '005: chk if file exists';
      EXEC xp_fileexist @import_xls_file, @file_exists OUT;

      -- POST03: @import_xls_file must exist OR exception 64871 thrown
      IF @file_exists = 0
      BEGIN
         SET @error_msg = CONCAT(@import_xls_file, ' does not exist');
         EXEC sp_log 4, @fn, '010: ', @error_msg;
         THROW 64871, '',1;
      END

      ----------------------------------------------------------------------------
      -- ASSERTION: file exists
      ----------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '015: ASSERTION: file exists';

      ----------------------------------------------------------------------------
      -- Import file
      ----------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: importig file: calling sp_import_XL_existing';

      EXEC sp_import_XL_existing
          @import_file  = @import_xls_file
 --        ,@range        = @range
         ,@table        = 'ImportCorrectionsStaging'
         ,@clr_first    = 1
         ,@fields       = 'id,command,search_clause,search_clause_cont,not_clause,replace_clause, case_sensitive, Latin_name, common_name, local_name, alt_names, note_clause, crops, doit, must_update, comments'
         ,@row_cnt      = @row_cnt OUT
         ,@expect_rows  = 1
         ;

      EXEC sp_log 1, @fn, '021';
      EXEC sp_log 1, @fn, '025: imported file OK (', @row_cnt, ' rows)';

      ----------------------------------------------------------------------------
      -- Checking post conditions
      -- POST04: openrowset cmd succeeded   OR exception 64872 thrown
      ----------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: Checking post conditions';
      -- POST01: ImportCorrectionsStaging table clean populated or error:  sp_import_XL_existing @clr_first = 1
      -- POST02: ImportCorrections truncated
      -- POST03: @import_xls_file must exist OR exception 64871 thrown     sp_import_XL_existing 
      -- POST04: openrowset cmd succeeded    OR exception 64872 thrown     sp_import_XL_existing 
      -- POST05: at least 1 row was imported OR exception 64873 thrown     sp_import_XL_existing @expect_rows  = 1

      IF @row_cnt = 0
      BEGIN
         SET @error_msg = 'No rows were imported';
         EXEC sp_log 4, @fn, @error_msg;
         THROW 64873, @error_msg, 1;
      END
   END TRY
   BEGIN CATCH
      SET @error_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '50: caught exception: ',@error_msg;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '99: leaving, OK';
   RETURN;
END
/*
EXEC sp_import_corrections_xls 'D:\Dev\Repos\Farming\Data\ImportCorrections 221018 230816-2000.xlsx'

SELECT * FROM ImportCorrectionsStaging
EXEC sp_import_corrections_xls 'D:\Dev\Repos\Farming\Data\ImportCorrections 231025 231106-0000.xlsx'

EXEC tSQLt.Run 'test.test_sp_import_correction_files_xls'
TRUNCATE TABLE ImportCorrectionsStaging;
TRUNCATE TABLE ImportCorrections;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ImportCorrectionsStaging](
	[id] [int] NOT NULL,
	[action] [varchar](50) NULL,
	[command] [varchar](max) NULL,
	[table_nm] [varchar](max) NULL,
	[field_nm] [varchar](50) NULL,
	[search_clause] [varchar](max) NULL,
	[filter_field_nm] [varchar](max) NULL,
	[filter_op] [varchar](8) NULL,
	[filter_clause] [varchar](250) NULL,
	[not_clause] [varchar](max) NULL,
	[exact_match] [varchar](max) NULL,
	[cs] [varchar](max) NULL,
	[replace_clause] [varchar](max) NULL,
	[field2_nm] [varchar](max) NULL,
	[field2_op] [varchar](8) NULL,
	[field2_clause] [varchar](max) NULL,
	[must_update] [varchar](max) NULL,
	[comments] [varchar](max) NULL,
	[created]  AS (getdate())
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

ALTER TABLE [dbo].[ImportCorrectionsStaging] ADD  CONSTRAINT [DF_ImportCorrectionsStaging_must_update]  DEFAULT ((0)) FOR [must_update]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ========================================================================================================
-- Author:      Terry Watts
-- Create date: 28-JUN-2023
--
-- Description: Called immediatly after import to fixup the
-- Removes any  wrapping double quotes "
-- The import data issues like our wrapping [] used to highlight
-- leading/trailing spaces
--
-- PRECONDITIONS:
--    corrections staging Bulk import done
--
-- POSTCONDITIONS:
--    Ready to process the pesticide register import
--    Clean bulk insert to tble from file
--    POST01: No wrapping " or {} in the following fields:
--    search_clause, not_clause,replace_clause, latin_name, common_name, local_name, alt_names, crops, note_clause
--    If error throws exception
--
-- Sets the following defaults:
--    doit -> 1
--    must_update to 1
--
-- ERROR HANDLING by exception handling
--
-- Tests:
--    test 012 sp_jh_imp_stg_1_bulk_insert
--
-- Called by the min import corrections routine
--
-- CHANGES:
-- 230710: wrapping barckets are now {} to avoid clash with regex [] brackets
-- 230712: rtn is now responsible for its own chk: - throw exception if error
-- 240201: XL imports using openrowset to the xl file directly limit the field width to 255
--         so we are using a second field to hold chars 256-end then concat this to the search field here
-- ========================================================================================================
CREATE PROCEDURE [dbo].[sp_fixup_import_corrections]
AS
BEGIN
   DECLARE
       @fn     VARCHAR(35)   = N'sp_fixup_import_corrections]'
      ,@sql    VARCHAR(4000)
      ,@msg    VARCHAR(500)
      ;

   EXEC sp_log 1, @fn, '000: starting';
   --EXEC sp_register_call @fn;

   -- Remove wrapping "
   EXEC sp_log 1, @fn, '010: remove wrapping double quotes from the following columns: search_clause, not_clause, replace_clause, crops, chk';

   -- REMOVE the first 2 imported header rows
   --DELETE FROM ImportCorrectionsStaging WHERE id2<3;

   UPDATE ImportCorrectionsStaging
   SET
       [action]       = dbo.fnTrim2( [action]       , '"')
      ,table_nm       = dbo.fnTrim2( table_nm       , '"')
      ,field_nm       = dbo.fnTrim2( field_nm       , '"')
      ,search_clause  = dbo.fnTrim2( search_clause  , '"')
      ,filter_field_nm= dbo.fnTrim2( filter_field_nm, '"')
      ,filter_clause  = dbo.fnTrim2( filter_clause  , '"')
      ,not_clause     = dbo.fnTrim2( not_clause     , '"')
      ,replace_clause = dbo.fnTrim2( replace_clause , '"')
      ,field2_nm      = dbo.fnTrim2( field2_nm      , '"')
      ,field2_clause  = dbo.fnTrim2( field2_clause  , '"')
      ,must_update    = dbo.fnTrim2( must_update    , '"')
      ,comments       = dbo.fnTrim2( comments       , '"')
      ,exact_match    = dbo.fnTrim2( exact_match    , '"')
   ;

   -- we do use regex - but they wont have an opening [
   EXEC sp_log 1, @fn, '020: remove wrapping []{}';

   -- 10-JUL-2023: Wrapping brackets are now {} to avoid clash with regex [] brackets
   UPDATE ImportCorrectionsStaging  
   SET
        search_clause  = dbo.fnTrim2( search_clause,  '{')
       ,replace_clause = dbo.fnTrim2( replace_clause, '{')
       ,not_clause     = dbo.fnTrim2( not_clause,     '{')
       ;

   EXEC sp_log 1, @fn, '030: remove wrapping []{}';
   UPDATE ImportCorrectionsStaging
   SET
        search_clause  = dbo.fnTrim2( search_clause,  '}')
       ,replace_clause = dbo.fnTrim2( replace_clause, '}')
       ,not_clause     = dbo.fnTrim2( not_clause,     '}')
       ;

   -- 240201: XL imports using openrowset to the xl file directly limit the field width to 255
   --         so we are using a second field to hold chars 256-end then concat this to the search field here
   --EXEC sp_log 1, @fn, '040: joining search_clause and  search_clause_cont => search_clause';
   --UPDATE ImportCorrectionsStaging SET search_clause = CONCAT(search_clause, search_clause_cont);

   -- Run checks
   EXEC sp_log 1, @fn, '050: running checks';
   IF EXISTS
   (
      SELECT 1 from ImportCorrectionsStaging 
      WHERE 
         search_clause  LIKE '{%'
      OR search_clause  LIKE '%}'
      OR replace_clause LIKE '{%'
      OR replace_clause LIKE '%}'
      OR not_clause     LIKE '{%'
      OR not_clause     LIKE '%}'

      OR search_clause  LIKE '"%'
      OR search_clause  LIKE '%"'
      OR replace_clause LIKE '"%'
      OR replace_clause LIKE '%"'
      OR not_clause     LIKE '"%'
      OR not_clause     LIKE '%"'
  )
   BEGIN
      SET @msg = '060: [sp_fixup_import_corrections_staging failed: {,}or " still exist in in search_clause or replace_clause or not_clause';
      EXEC sp_log 4, @fn, @msg;
      THROW 58126, @msg, 1;
   END

   EXEC sp_log 1, @fn, '999: leaving OK';
   RETURN 0;
END
/*
EXEC sp_fixup_import_corrections_staging;
EXEC sp_copy_corrections_staging_to_mn;
SELECT id, search_clause, replace_clause, chk FROM ImportCorrectionsStaging WHERE replace_clause like '%{%';
SELECT id, search_clause, replace_clause, chk FROM ImportCorrectionsStaging WHERE replace_clause like '%}%';
SELECT id, search_clause, replace_clause, chk FROM ImportCorrectionsStaging
WHERE id =43;
SELECT id, search_clause, replace_clause  FROM ImportCorrections WHERE search_clause  like '%{%';
SELECT id, search_clause, replace_clause  FROM ImportCorrections WHERE replace_clause like '%}%';
SELECT id, search_clause, replace_clause  FROM ImportCorrections WHERE replace_clause like '%"%';

SELECT * FROM ImportCorrectionsStaging;
EXEC sp_fixup_import_corrections_staging;
SELECT Count(*) from ImportCorrectionsStaging;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================
-- Author:      Terry Watts
-- Create date: 28-JUN-2023
-- 
-- Description: Imports the ImportCorrectionsStaging table
-- This:
-- 1: truncates the ImportCorrections and ImportCorrectionsStaging tables
-- 2: imports the corrections data sheet: @imprt_tsv_file into the ImportCorrectionsStaging table
--
-- RETURNS:
--    0 if OK, else OS error code
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
--    POST01: ImportCorrectionsStaging table clean populated or error
--    POST02: ImportCorrections truncated
--    POST03: @import_tsv_file must exist OR exception 64871 thrown
--    POST04: bulk insert cmd succeeded   OR exception 64872 thrown
--    POST05: at least 1 row was imported OR exception 64873 thrown
--    POST06: @row_cnt contains the number of rows imported from @import_tsv_file
--
-- THROWS:
-- 64871 if @import_tsv_file does not exist
-- 64872 if bulk insert cmd errored
-- 64873 if no rows were imported
-- 
-- Tests:
--    test.test_sp_import_correction_files
--
-- Changes:
-- 231109: added exceptions thrown if errors (see POSTCONDITIONS  )
-- ======================================================================
CREATE PROCEDURE [dbo].[sp_import_corrections_tsv]
    @import_tsv_file VARCHAR(360) -- Full path to import file
   ,@row_cnt         INT   = NULL      OUT
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)  = N'import_corrections_tsv'
   ,@sql             NVARCHAR(MAX)
   ,@rc              INT   = 1
   ,@error_msg       VARCHAR(1000)
   ,@file_exists     INT
   ,@nl              NCHAR(2) = NCHAR(13)+NCHAR(10)
   ;

   EXEC sp_log 2, @fn, '000: starting, file: [', @import_tsv_file, ']';

   BEGIN TRY

      EXEC sp_log 1, @fn, '010: deleting import log files';

      EXEC xp_cmdshell 'DEL D:\Logs\PesticideRegisterImportCorrectionsErrors.log.Error.Txt', NO_OUTPUT;
      EXEC xp_cmdshell 'DEL D:\Logs\PesticideRegisterImportCorrectionsErrors.log'          , NO_OUTPUT;

      -- chk if file exists
      EXEC sp_log 1, @fn, '020: checking the import file exists';
      EXEC xp_fileexist @import_tsv_file, @file_exists OUT;

      -- POST03: @import_tsv_file must exist OR exception 64871 thrown
      IF @file_exists = 0
      BEGIN
         SET @error_msg = CONCAT(@import_tsv_file, ' does not exist');
         EXEC sp_log 4, @fn, '030: ', @error_msg;
         THROW 64871, '',1;
      END

      EXEC sp_log 1, @fn, '040: import file exists';

      SET @sql = CONCAT
      (
         'BULK INSERT ImportCorrectionsStaging_vw FROM ''', @import_tsv_file, '''
         WITH
         (
             FIRSTROW        = 2
            ,FIELDTERMINATOR = ''\t''
            ,ROWTERMINATOR   = ''\n''
            ,ERRORFILE       = ''D:\Logs\PesticideRegisterImportCorrectionsErrors.log''
         );'
      );

      EXEC sp_log 2, @fn, '050: exec import sql:',@nl,
@sql;

      EXEC @RC = sp_executesql @sql;
      SET @row_cnt = @@ROWCOUNT
      EXEC sp_log 2, @fn, '050: imported ', @row_cnt, ' rows';

      -- POST04: bulk insert cmd succeeded   OR exception 64872 thrown
      IF @RC <> 0
      BEGIN
         SET @error_msg = ERROR_MESSAGE();
         EXEC sp_log 4, @fn, '060: error raised during bulk insert cmd :', @RC, ' Error msg: ', @error_msg, ' File: ', @import_tsv_file;
         THROW 64872, @error_msg,1;
      END

      -- POST05: at least 1 row was imported OR exception 64873 thrown
      IF @row_cnt = 0
      BEGIN
         SET @error_msg = '070: No rows were imported';
         EXEC sp_log 4, @fn, @error_msg;
         THROW 64873, @error_msg, 1;
      END

      --SET IDENTITY_INSERT ImportCorrections ON;
   END TRY
   BEGIN CATCH
       EXEC sp_log 4, @fn, '500: caught exception'
      --SET IDENTITY_INSERT ImportCorrections ON;
      SET @error_msg = CONCAT('import file: ',@import_tsv_file,' ', ERROR_MESSAGE());
      EXEC sp_log 4, @fn, '501: caught exception: ',@error_msg, ' see the import log files: D:\Logs\PesticideRegisterImportCorrectionsErrors.log*';
      EXEC sp_log 4, @fn, '510: @sql:
     ', @sql;

     DECLARE @ex_num INT = ERROR_NUMBER();

      THROW @ex_num, @error_msg, 1;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving';
   RETURN @RC;
END
/*
EXEC tSQLt.Run 'test.test_sp_import_correction_files'

----------------------------------------------------------------------------------------------
EXEC sp_Reset_CallRegister;
TRUNCATE TABLE ImportCorrectionsStaging;
TRUNCATE TABLE ImportCorrections;
EXEC sp_import_corrections_file 'D:\Dev\Farming\Data\ImportCorrections 240910.txt'
SELECT * FROM ImportCorrections_vw;
SELECT * FROM ImportCorrectionsStaging;
SELECT * FROM ImportCorrections;
----------------------------------------------------------------------------------------------
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================================
-- Author:      Terry Watts
-- Create date: 20-SEP-2024
--
-- Description: Gets the file details from the supplied file path:
--    [Folder, File name without ext, extension, fn_pos, dot_pos, len]
--
-- Tests:
--
-- CHANGES:
-- ======================================================================================================
CREATE FUNCTION [dbo].[fnGetFileDetails]( @filePath VARCHAR(600))
RETURNS
@t TABLE
(
    filePath     VARCHAR(600)
   ,folder       VARCHAR(500)
   ,fileNm       VARCHAR(200)
   ,fileNmNoExt  VARCHAR(200)
   ,ext          VARCHAR(60)
   ,filePathRev  VARCHAR(600)
   ,[len]        INT
   ,slashpos     INT
   ,slashRevPos  INT
   ,dotPos       INT
   ,dotRevPos    INT
)
AS
BEGIN
DECLARE
    @fn           VARCHAR(35)='sp_fnGetFileDetails'
   ,@slashPos     INT
   ,@slashRevPos  INT
   ,@dotPos       INT
   ,@dotRevPos    INT
   ,@len          INT
   ,@fileNm       VARCHAR(200)
   ,@fileNmNoExt  VARCHAR(200)
   ,@fileNmRev    VARCHAR(200)
   ,@folder       VARCHAR(500)
   ,@ext          VARCHAR(60)
   ,@filePathRev  VARCHAR(1000)
   ,@bckslsh      VARCHAR(1) = NCHAR(92)
;

      SET @len         = dbo.fnLen(@filePath);
      SET @filePathRev = REVERSE(@filePath);
      SET @slashRevPos = CHARINDEX(@bckslsh, @filePathRev);
      SET @dotRevPos   = CHARINDEX('.', @filePathRev);
      SET @dotPos      = iif(@dotRevPos=0, 0, @len - @dotRevPos+1);
      SET @slashPos    = @len - @slashRevPos+1;

   -- Beware empty file path
      IF (@len > 0) AND (@slashRevPos > 1)
      BEGIN
         SET @folder     = REVERSE(SUBSTRING(@filePathRev, @slashRevPos+1, @len - @slashRevPos+1));
         SET @fileNmRev  = SUBSTRING(@filePathRev, @dotRevPos+1, @slashRevPos-@dotRevPos-1);
         SET @fileNm     = REVERSE(SUBSTRING(@filePathRev, 1, @slashRevPos-1));
         SET @ext        = REVERSE(SUBSTRING(@filePathRev, 1, @dotRevPos-1));
         SET @fileNmNoExt= SUBSTRING(@filePath, @slashPos+1, @dotPos-@slashPos-1);
      END

      IF(CHARINDEX(@bckslsh, @filePath) = 0)
      BEGIN
         SET @fileNm     = @filePath;
         SET @ext        = iif(@len>1 AND (@len-@dotPos > 0), SUBSTRING(@filePath, @dotPos+1, @len-@dotPos), NULL);
         SET @slashPos   = 0
         SET @folder     = NULL
         SET @fileNmNoExt= SUBSTRING(@filePath, @slashPos+1, iif(@dotPos = 0, @len,@dotPos-@slashPos-1))
      END

      INSERT INTO @t( filePath, folder, FileNm, fileNmNoExt, ext, filePathRev,[len], slashPos, slashRevPos, dotPos, dotRevPos)
      VALUES        (@filePath,@folder,@fileNm,@fileNmNoExt,@ext,@filePathRev,@len ,@slashPos,@slashRevPos,@dotPos,@dotRevPos);
   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_096_fnGetFileDetails';
SELECT * FROM dbo.fnGetFileDetails('Caller')

SELECT * FROM dbo.fnGetFileDetails('D:\Dev\Farming\Data\CallRegister.txt.abc')
SELECT * FROM dbo.fnGetFileDetails('D:\Dev\Farming\Data\CallRegister.abc')
SELECT * FROM dbo.fnGetFileDetails('CallRegister.abc.txt')
SELECT * FROM dbo.fnGetFileDetails('')
SELECT * FROM dbo.fnGetFileDetails(NULL)

                   20
D:\Dev\Farming\Data\CallRegister.txt
                17
txt.retsigeRllaC\ataD\gnimraF\veD\:D

            13
CallRegister.txt
SELECT * FROM dbo.fnGetFileDetails('D:\Dev\Farming\Tests\test_096_GetFileDetails\CallRegister.abc.txt')

SELECT * FROM dbo.fnGetFileDetails('LRAP-221018.txt')
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===============================================================================================
-- Author:      Terry Watts
-- Create date: 15-MAR-2023
-- Description:
--  returns a 1 row table holding the file path and the range from the @filePath_inc_rng parameter
--
-- Postconditions:
--   POST01: returns 1 row [file_path, range]
-- ===============================================================================================
CREATE FUNCTION [dbo].[fnGetRangeFromFileName](@filePath_inc_rng VARCHAR(600))
RETURNS
@t TABLE
(
    file_nm   VARCHAR(100)
   ,file_path VARCHAR(500)
   ,[range]   VARCHAR(605)
   ,ext       VARCHAR(20)
   ,ndx       INT
)
AS
BEGIN
   DECLARE
      @file_path  VARCHAR(500)
     ,@file_nm    VARCHAR(100)
     ,@range      VARCHAR(60)
     ,@ndx        INT
     ,@ext        VARCHAR(20)

   SET @ndx       = CHARINDEX('!',@filePath_inc_rng);
   SET @file_path = IIF(@ndx=0, @filePath_inc_rng,  SUBSTRING(@filePath_inc_rng, 1, @ndx-1));

   SELECT
       @ext    = ext
      ,@file_nm= fileNm
   FROM dbo.fnGetFileDetails(@file_path)
   ;

   SET @range= IIF
   (
      @ext IN('xlsx', 'xls')
      ,IIF(
            @ndx=0
            ,'Sheet1$'
            ,SUBSTRING(@filePath_inc_rng, @ndx+1, dbo.fnLen(@filePath_inc_rng)-@ndx)
         )
      ,NULL
   ); -- Excel range has a max len of 31

   INSERT INTO @t(file_nm, file_path, [range], ext, ndx) VALUES (@file_nm, @file_path, @range, @ext, @ndx);
   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_013_fnGetRangeFromFileName';
SELECT * FROM dbo.fnGetFileDetails('D:\Dev\Farming\Tests\test_066\LRAP-221018-2.txt');
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ImportCorrections](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[action] [varchar](12) NULL,
	[command] [varchar](50) NULL,
	[table_nm] [varchar](50) NULL,
	[field_nm] [varchar](50) NULL,
	[search_clause] [varchar](700) NULL,
	[filter_field_nm] [varchar](50) NULL,
	[filter_op] [varchar](10) NULL,
	[filter_clause] [varchar](250) NULL,
	[not_clause] [varchar](500) NULL,
	[exact_match] [bit] NULL,
	[cs] [bit] NULL,
	[replace_clause] [varchar](500) NULL,
	[field2_nm] [varchar](50) NULL,
	[field2_op] [varchar](8) NULL,
	[field2_clause] [varchar](250) NULL,
	[must_update] [bit] NULL,
	[comments] [varchar](max) NULL,
	[created] [datetime] NULL,
	[update_cnt] [int] NULL,
	[select_sql] [varchar](max) NULL,
	[update_sql] [varchar](max) NULL,
	[result_msg] [varchar](500) NULL,
	[row_id] [int] NULL,
	[stg_file] [varchar](100) NULL,
 CONSTRAINT [PK_ImportCorrections] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

ALTER TABLE [dbo].[ImportCorrections] ADD  CONSTRAINT [DF_ImportCorrections_must_update]  DEFAULT ((0)) FOR [must_update]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===============================================================================================
-- Author:      Terry Watts
-- Create date: 08-NOV-2023
--
-- Description:
--    imports 1 file, either a tsv or excel file
--    initially cleans out ImportCorrectionsStaging and ImportCorrections (resets stging id2 key)
--    imports all the correction files to ImportCorrectionsStaging
--    does fixup of ImportCorrectionsStaging
--    merges ImportCorrectionsStaging to ImportCorrections
--
-- Notes:
-- Incrementally add to ImportCorrections as this may be part of a multiple corrections file import
--
-- Parameters:
--    @cor_file_ir:      holds the file name and the possible excel range like <file path>!<sheet nm>$<range>
--    @cor_file_row_cnt: cor rows from the cor file
--
-- PRECONDITIONS - none?
--
-- POSTCONDITIONS:     ASSERTION                                                 OR
-- POST 01: import file must be specified                                        EX 52412
-- POST 02: import file must exist                                               EX 64871
-- POST 03: Import data has either replace clause, a cmd is IN ('SKIP','SQL','STOP') or a notes clause   EX 52413
-- POST 04: @row_cnt contains the count of rows for this file only (not inceremental)
--
-- CHANGES:
-- 240322: only handles 1 file: either a tsv or excel file
-- 241130: check that corrections import data has either replace clause, a SQL cmd or a notes clause
-- ===============================================================================================
CREATE PROCEDURE [dbo].[sp_import_cor_file]
    @cor_file_ir        VARCHAR(MAX) -- file path including range if an Excel file
   ,@cor_file_row_cnt   INT =NULL OUT
AS
BEGIN
DECLARE
    @fn           VARCHAR(35)   = N'sp_import_cor_file'
   ,@file_path    VARCHAR(250)  = NULL -- 1 import file from the import files parameter list
   ,@file_nm      VARCHAR(60)
   ,@range        VARCHAR(32)
   ,@error_msg    VARCHAR(200)
   ,@ext          VARCHAR(20)
   ,@import_id    INT            = NULL
   ,@msg          VARCHAR(500)  = ''
   ,@file_exists  INT            = -1
   ,@row_id       INT
   ,@is_csv_file  BIT

   SET NOCOUNT ON;

   BEGIN TRY
      EXEC sp_log 1, @fn,'000: starting:
cor_file_ir:[',@cor_file_ir,'] -- optionally includes range 
';

      ------------------------------------------------------------------------------------------------
      -- Get the file path and the possible excel range from the @cor_file_ir parameter
      ------------------------------------------------------------------------------------------------
      SELECT
          @file_path = file_path
         ,@range     = [range]
         ,@ext       = ext
         ,@file_nm   = file_nm
      FROM dbo.fnGetRangeFromFileName(@cor_file_ir);

      --SELECT * FROM dbo.fnGetRangeFromFileName(@cor_file_ir);
      SET @is_csv_file = IIF(@ext='txt', 1, 0);

      --------------------------------------------------------------------------------------------------------
      -- Modified params
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '010: Modified params
file_path:  :[',@file_path  ,']
range:      :[',@range      ,']
ext:        :[',@ext        ,']
is_csv_file :[',@is_csv_file,']
';

      EXEC sp_log 1, @fn, '020: truncating staging table ready for this batch';
      TRUNCATE TABLE ImportCorrectionsStaging;

      --------------------------------------------------------------------------------------------------------
      -- Validating params
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: validating params';

      -- POST 01: import file must be specified                                        EX 52412
      EXEC sp_assert_not_null_or_empty @file_path, ',import file must be specified', @ex_num=52412;

      -- POST 02: import file must exist or EX 64871
      -- POST06: @row_cnt contains the number of rows imported from @import_tsv_file
      EXEC sp_assert_file_exists @file_path,'import file ', @ex_num=64871;

      --------------------------------------------------------------------------------------------------------
      -- ASSERTION: params validated
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '040: ASSERTION: params validated';

      --------------------------------------------------------------------------------------------------------
      -- Process
      --------------------------------------------------------------------------------------------------------
      -- Run the import

      EXEC sp_log 1, @fn, '050: run the import ', @cor_file_ir, @range, ' @is_csv_file: ', @is_csv_file;

      -- Handle either TSV or Excel file
      -- POST 03: import file must exist OR EX 64871
      --    delegated to sp_import_corrections_tsv,sp_import_corrections_xls
      IF @is_csv_file = 1
         EXEC sp_import_corrections_tsv @file_path, @row_cnt = @cor_file_row_cnt OUT;
      ELSE
         EXEC sp_import_corrections_xls @file_path, @range, @cor_file_row_cnt OUT;

      EXEC sp_log 1, @fn, '060: returned frm the import_corrections rtn @cor_file_row_cnt: ', @cor_file_row_cnt;

      --------------------------------------------------------------------------------------------------------
      -- Fixup import_corrections  like the XL 255 bug
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '070: fixup import_corrections like the XL 255 buge   ';
      EXEC sp_fixup_import_corrections;

      EXEC sp_log 1, @fn, '080: copying correction staging to corrections table   ';

      -- Incrementally add to ImportCorrections as this may be part of a multiple corrections file import
      INSERT INTO ImportCorrections
                 ( [action],command, table_nm, field_nm, search_clause, filter_field_nm, filter_clause, not_clause, exact_match, replace_clause, field2_nm, field2_clause, must_update, comments, created, row_id, stg_file)
      SELECT       [action],command, table_nm, field_nm, search_clause, filter_field_nm, filter_clause, not_clause, exact_match, replace_clause, field2_nm, field2_clause, must_update, comments, created, id,     @file_nm
      FROM ImportCorrectionsStaging;

      --------------------------------------------------------------------------------------------------------
      -- Check postconditions
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'800: checking postconditions';
      -- POST 01: must be at least 1 corrections file import.                           EX 52410
      EXEC sp_assert_tbl_pop 'ImportCorrections';

      SET @row_id =
      (
         SELECT TOP 1 id FROM ImportCorrections
         WHERE replace_clause IS NULL AND field2_clause IS NULL AND ([action] NOT IN ('SKIP','SQL','STOP') AND command NOT IN ('SKIP','SQL','STOP'))
      );

      -- POST 04: Import data has either replace clause, a cmd is IN ('SKIP','SQL','STOP') a notes clause   EX 52413
      IF @row_id IS NOT NULL
      BEGIN
         -- Display the offending row
         SELECT * FROM ImportCorrections WHERE id = @row_id;
         EXEC sp_raise_exception 52413, 'import row: ', @row_id, ' Either replace_clause must be specified or (command=(''SKIP'',''SQL'',''STOP'') or notes field is specified)',@fn=@fn;
      END

      --------------------------------------------------------------------------------------------------------
      -- Completed processing
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'950: Completed processing';
   END TRY
   BEGIN CATCH
      SET @error_msg =  ERROR_MESSAGE()
      EXEC sp_log 4, @fn, '500: caught exception: ', @error_msg;
      THROW;
   END CATCH

   -- SELECT * FROM AppLog;
   EXEC sp_log 2, @fn,'999: leaving';
END
/*
EXEC tSQLt.Run'test.test_039_sp_import_cor_file';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[CorFiles](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[file] [nvarchar](60) NULL,
	[row_cnt] [int] NULL,
	[fixup_cnt] [int] NULL,
 CONSTRAINT [PK_CorFiles] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [IX_CorFiles] UNIQUE NONCLUSTERED 
(
	[file] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ImportState](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[import_root] [varchar](450) NULL,
	[import_file] [varchar](150) NULL,
	[cor_files] [varchar](500) NULL,
	[start_stage] [int] NULL,
	[stop_stage] [int] NULL,
	[start_row] [int] NULL,
	[stop_row] [int] NULL,
	[restore_s1_s2] [bit] NULL,
	[restore_s3_s2] [bit] NULL,
	[log_level] [int] NULL,
	[import_eppo] [bit] NULL,
	[import_id] [int] NULL,
	[file_type] [varchar](10) NULL,
	[cor_file_cnt] [int] NULL,
 CONSTRAINT [PK_ImportState] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =====================================================================================================
-- Author:      Terry Watts
-- Create date: 14-DEC-2024
-- Description: imports all the corrections files
--              using the staging table to import a file then merges to the main corfiles table
--
-- Parameters:
-- @crtns_files:  comma separated list of file names without path
-- @import_root   the folder holding the files 
-- @clr_first     if set then clears the ImportCorrectionsStaging and ImportCorrectionsStaging tables
--
-- Notes:
-- @clr_first WILL only be applied ONCE , if specified, to ImportCorrections table
--
-- RESPONSIBILITIES:
-- R01: iniItially cleare the maIN IMPORTCORRECTION TABLE
-- R02: import all the specified corrections files
--
-- PRECONDITIONS:
-- PRE 01: ImportState and CorFiles table pop
--
-- POSTCONDITIONS:
-- POST 01: @clr_first ImportCorrectionsStaging and ImportCorrections clean populated else added
-- POST 02: updates CorFiles with the row count for each import file
--
-- Design
-- EA: Model.Use Case Model.LRAP Import.Import the LRAP Corrections files.Import the LRAP corrections files ACT
-- Import the LRAP corrections files_ActivityGraph
--
-- TESTS: test_006_sp_mn_imprt_stg_04_imp_ctrns
--
-- CHANGES:
-- =====================================================================================================
CREATE PROCEDURE [dbo].[sp_import_cor_files]
    @tot_cnt      INT         = 0    OUT -- total import correction rows from all cor files
   ,@file_cnt     INT         = NULL OUT
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)  = 'sp_import_cor_files'
   ,@import_root  VARCHAR(500)
   ,@cor_file     VARCHAR(100)
   ,@cor_path     VARCHAR(100)
   ,@cursor       CURSOR
   ,@file_row_cnt INT         = 0

   BEGIN TRY
      EXEC sp_log 1, @fn, '000: starting';
      
      --------------------------------------------------------------
      -- Validate preconditions
      --------------------------------------------------------------
      EXEC sp_log 1, @fn, '010: Validating preconditions';
      EXEC sp_assert_tbl_pop 'dbo.ImportState', @fn=@fn;
      EXEC sp_assert_tbl_pop 'dbo.CorFiles'   , @fn=@fn;

   SELECT
       @import_root = import_root
      ,@file_cnt    = cor_file_cnt
   FROM ImportState;

      --------------------------------------------------------------
      -- Validated preconditions
      --------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: ASSERTION: Validated preconditions';

   EXEC sp_log 1, @fn, '030: params:
import_root:[',@import_root,']
';

      --------------------------------------------------------------
      -- Process
      --------------------------------------------------------------
      EXEC sp_log 1, @fn, '040: Process';

      EXEC sp_log 1, @fn, '050: clearing ImportCorrections table';

      SET @tot_cnt  = 0;
      SET @file_cnt = 0;

      TRUNCATE TABLE ImportCorrections;

      -- Get the cor files 1 at a time in order and import them
      SET @cursor = CURSOR FOR SELECT [file] FROM CorFiles ORDER BY id;
      OPEN @cursor;

      EXEC sp_log 1, @fn, '060: about to import';

      -- For each file: add the import to the Import corrections Staging table
      FETCH NEXT FROM @cursor INTO @cor_file;
      WHILE (@@FETCH_STATUS = 0)
      BEGIN
         SET @file_cnt = @file_cnt + 1;
         -- Clear the staging table
         TRUNCATE TABLE ImportCorrectionsStaging;
         EXEC sp_log 1, @fn, '070: file[',@file_cnt,'] importing ',@cor_file;
         SET @cor_path = CONCAT(@import_root, '\', @cor_file);
         EXEC sp_log 1, @fn, '080: import file [', @file_cnt,']: ',@cor_path;

         ------------------------------------------------------
         -- Import the file to staging
         ------------------------------------------------------
         EXEC sp_log 1, @fn, '090: importing ', @cor_path;
         EXEC sp_import_cor_file @cor_path, @file_row_cnt OUT;
         EXEC sp_log 1, @fn, '100: imported. @row_cnt: ', @file_row_cnt, ' rows';
         SET @tot_cnt = @tot_cnt + @file_row_cnt; -- increment

         -- Set the file row cnt for the Import Summary Report
         UPDATE CorFiles SET row_cnt = @file_row_cnt WHERE [file] = @cor_file;

         EXEC sp_log 1, @fn, '110: imp file[', @file_cnt,'] completed ',@cor_path, ' import, ImportCorrections now has ', @tot_cnt, ' rows';
         FETCH NEXT FROM @cursor INTO @cor_file;
      END

         ------------------------------------------------------
      -- ASSERTION: ImportCorrections fully populated now
         ------------------------------------------------------

      SELECT @tot_cnt = COUNT(*) FROM ImportCorrections;
      -- PRE 01: at least 1 correction file passed in
      EXEC sp_assert_gtr_than @file_cnt, 0, '120: at least 1 correction file must be specified', @fn=@fn;

      --------------------------------------------------------------------
      -- Processing complete, get total corrections';
      --------------------------------------------------------------------
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving, OK, ImportCorrections now has ',@tot_cnt, ' rows, there were ', @file_cnt,' imports';
END
/*
EXEC tSQLt.Run 'test.test_001_import_cor_files';

EXEC tSQLt.RunAll;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

--========================================================================================================================
-- Author:      Terry Watts
-- Create date: 07-NOV-2024
-- Description: creates the update SQL for sp_update
--
-- Notes:
-- 1: beware replacing a short srch clause with a longer one that contains the 
--    srch clause as this if repeated will produce unwanted repitition
--
-- 2: beware replacing empty or null srch cls like '' - in this case d not use replace
-- 3: not like clause must not be a subset of the search clause - if so - dont use not like cls
-- TEST: T006 not like cls subset of srch cls
--
-- Tests: test_018_fnCrtUpdateSql see sp_gen_tst_dta_S2_tst and fnGetUnregisteredPathogensFromS3
-- xls order:
-- id, command, table, field, search_clause, filter_field, filter_clause, not_clause, replace_clause
--, field2_nm, field2_val, must_update, comments, exact_match
--
-- Preconditions:
-- PRE 01: @filter_op must be IN ('EQUALS'  OR 'IN')  OR Exception 56741, '@filter_op must be IN ('EQUALS'  OR 'IN') '
-- PRE 02: @field2_op must be IN ('REPLACE' OR 'ADD') OR Exception 56741, '@field2_op must be IN ('REPLACE' OR 'ADD')'
--
-- CHANGES:
-- 241205: updated @filter_op prm to one of {'LIKE' =, 'EQUALS', 'IN'}
-- 241213: re added case sensitive searches @cs=1, default: 0 (case insensitive search)
-- 241221: added the @extras prm to set 1 or more extra field values
-- 250107: @ not_clause: not like '' should not be scripted as NOT LIKE'%%' BUT like NOT LIKE''''
-- 250107: field2: if null or empty and ADD dont add comma only
-- ==============================================================================================
CREATE PROCEDURE [dbo].[sp_fnCrtUpdateSql]
(
    @table_nm        NVARCHAR(60)
   ,@field_nm        NVARCHAR(60)
   ,@search_clause   NVARCHAR(500)
   ,@filter_field_nm NVARCHAR(60) 
   ,@filter_op       NVARCHAR(6)    -- One of 'LIKE' 'EQUALS' 'IN'
   ,@filter_clause   NVARCHAR(500)  -- comma separated list do not wrap the comma separated values in  ' '
   ,@not_clause      NVARCHAR(400)
   ,@exact_match     BIT            -- Used to flag when to use UPDATE tbl set field = rplce cls or REPLACE(field, srch cls, rplce cls)
   ,@cs              BIT
   ,@replace_clause  NVARCHAR(500)
   ,@field2_nm       NVARCHAR(60)
   ,@field2_op       NVARCHAR(8)    -- 0 replace(default), 1 add
   ,@field2_clause   NVARCHAR(500)
   ,@extras          NVARCHAR(2000) -- sql clause to add one or more extra field values e,g 'comments=''some comment'' '
   ,@select_sql      NVARCHAR(4000) OUT
   ,@update_sql      NVARCHAR(4000) OUT
)
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)= 'sp_fnCrtUpdateSql'
   ,@cs_s            NVARCHAR(8)
   ,@nl              NCHAR(2)    = NCHAR(13) + NCHAR(10)
   ,@single_quote    NCHAR       = NCHAR(39) -- ASCII(39) is ' the single qote character
   ,@is_exact        BIT -- used to flag where to use UPDATE tbl set field =  val or UPDATE tbl set field = REPLACE(field, drch cls, replace cls)
   ,@Line1           VARCHAR(120) = REPLICATE('-', 100)
   ,@Line2           VARCHAR(120) = REPLICATE('*', 100)
   ,@filter_sql      NVARCHAR(MAX)
   ,@sql             NVARCHAR(MAX)
   ,@set_cls         NVARCHAR(MAX)
   ,@tab             NCHAR(3)=' '
   ,@where_cls       NVARCHAR(MAX)
   ;
   SET @cs_s = iif(@cs IS NULL, '<NULL>', CONVERT(NVARCHAR(8), @cs));
   EXEC sp_log 1, @fn, '000: starting
filter_op:[',@filter_op,']
field2_op:[',@field2_op,']
cs       :[',@cs_s     ,']
';
   -------------------------------------------------
   -- Defaults:
   -------------------------------------------------
   IF @filter_op IS NULL SET @filter_op = 'EQUALS';
   IF @field2_op IS NULL SET @field2_op = 'REPLACE';
   IF @cs        IS NULL SET @cs        = 0; -- case insensitve search
   IF @filter_op =  ''   SET @filter_op = '<EMPTY>';
   IF @field2_op =  ''   SET @field2_op = '<EMPTY>';

   EXEC sp_log 1, @fn, '005: params after setting defaults
filter_op:[',@filter_op,']
field2_op:[',@field2_op,']';

   -------------------------------------------------
   -- Validating Preconditions
   -------------------------------------------------
   EXEC sp_log 1, @fn, '010: validating preconditions';

   -- PRE 01: @filter_op must be IN ('EQUALS'  OR 'IN')  OR Exception 56741, '@filter_op must be IN ('EQUALS'  OR 'IN') '
   IF @filter_field_nm IS NOT NULL AND @filter_op NOT IN ('EQUALS', 'IN')
      EXEC sp_raise_exception 56741, '@filter_op must be IN (''EQUALS'' OR ''IN'') but was:[',@filter_op,']',@fn=@fn;

   -- PRE 02: @field2_op must be IN ('REPLACE' OR 'ADD') OR Exception 56741, '@field2_op must be IN ('REPLACE' OR 'ADD')'
   IF @field2_nm IS NOT NULL AND @field2_op NOT IN ('REPLACE', 'ADD') exec sp_raise_exception 56741, 'field2_op must be IN (''REPLACE'' OR ''ADD'') but was:[',@field2_op,']';

   EXEC sp_log 1, @fn, '020: validated  preconditions OK';

   WHILE 1=1
   BEGIN

      -------------------------------------------------
      -- Stage 1: set sql: UPDATE @table SET @field =
      -------------------------------------------------
      SET @set_cls = CONCAT
      (
          'SET', @nl,@tab
         ,' [',@field_nm,']='
      )

      -----------------------------------------------
      -- Assertion: sql: UPDATE @table SET @field = Replace clause
      -----------------------------------------------

      -------------------------------------------------------------------------------
      -- Stage 2: set sql = UPDATE @table SET @field = exact clause or Replace clause
         --  depending on if ( NUL or MT or EXACT) or not
      -------------------------------------------------------------------------------
      SET @is_exact = iif((@search_clause IS NULL) OR (dbo.fnLen(@search_clause) = 0) OR (@exact_match = 1), 1, 0);

      IF (@is_exact = 1)
      BEGIN
         -- Create exact clause
         SET @set_cls = CONCAT(@set_cls, '''', @replace_clause, '''');
      END
      ELSE
      BEGIN
         -- Create replace clause
          SET @set_cls = CONCAT(@set_cls, 'REPLACE([', @field_nm, '], ''', @search_clause, ''', ''',@replace_clause, ''')');
      END

      --------------------------------------------------------------------------------------------------------------------
      -- Assertion: sql: UPDATE @table SET @field = @replace_clause or =REPLACE(field, @search_clause, @replace_clause) NL
      --------------------------------------------------------------------------------------------------------------------

      ----------------------------------------------------------------
      -- Stage 3: add other set field clauses
      -- 250107: field2: if null or empty and ADD dont add comma only
      ----------------------------------------------------------------
      IF @field2_nm IS NOT NULL AND @field2_nm <> '' AND @field2_clause IS NOT NULL AND @field2_clause <> ''
      BEGIN
         SET @set_cls = 
         CONCAT
         (
             @set_cls, @NL, @tab,',[', @field2_nm, ']='
            ,iif( @field2_op='REPLACE'
                  ,CONCAT('''', @field2_clause, '''')                               -- REPLACE
                  ,CONCAT('CONCAT([', @field2_nm
                  , '], IIF(',@field2_nm,' IS NULL OR ',@field2_nm,'='''','''','','')',',''', @field2_clause, ''')')-- ADD
                )
         );

         ----------------------------------------------------
         -- Assertion: sql: contains all required set fields
         ----------------------------------------------------
      END

      -- Set any extra field values
      -- sql clause to add one or more extra field values e,g 'comments=''some comment'' '
      IF @extras IS NOT NULL
      BEGIN
         SET @set_cls =
         CONCAT
         (
             @set_cls, @NL, @tab, ',', @extras
         );
      END

      --======================================
      -- Stage 4 Add WHERE clauses
      --======================================
      -- EXEC sp_log 1, @fn, '040: Stage 4 starting - add WHERE clauses';
      SET @where_cls = CONCAT('WHERE', @NL, @tab,' [',@field_nm,']')
      -- EXEC sp_log 1, @fn, '051: is act: ', @is_exact;

      IF @is_exact = 1
      BEGIN
         -- EXEC sp_log 1, @fn, '053: in if @is_exact = 1 TRU brnch';
         SET @where_cls = CONCAT( @where_cls, '=''',@search_clause, '''');
      END
      ELSE
      BEGIN
         -- EXEC sp_log 1, @fn, '057: in if @is_exact = 1 FLS brnch';
         SET @where_cls = CONCAT( @where_cls, ' LIKE ''%', @search_clause,'%''');
      END

      ---------------------------------------------------------------
      -- Case sensitive
      ---------------------------------------------------------------
      if(@cs=1)
         SET @where_cls = CONCAT(@where_cls, ' COLLATE Latin1_General_CS_AS');

      ----------------------------------------------------------------------
      -- Stage 5 Add 'and search field not like clause'
      -- Only add this if @replace_clause is not a subset of @search_clause
      ----------------------------------------------------------------------
      IF CHARINDEX(@replace_clause, @search_clause) = 0
      BEGIN
         SET @where_cls = CONCAT( @where_cls, @NL
         ,'AND [',@field_nm,'] NOT LIKE ''%', @replace_clause, '%''');

         if(@cs=1)
            SET @where_cls = CONCAT(@where_cls, ' COLLATE Latin1_General_CS_AS');
      END

      ---------------------------------------------------------------
      -- Stage 6: If filter field is specified
      ---------------------------------------------------------------
      If @filter_field_nm IS NOT NULL AND @filter_field_nm IS NOT NULL
      BEGIN
         -- Depending on the filter_op: {'=' OR 'IN'}

         IF @filter_op = 'EQUALS'
         BEGIN
            -- EXEC sp_log 1, @fn, '160 filter op is ''EQUALS''';
            SET @filter_sql = CONCAT('=''', @filter_clause, '''');
         END
         ELSE
         BEGIN
            -- Wrap both the entire in clause in single quotes and the comma separated values in the list
            SELECT @filter_clause = string_agg( CONCAT('''', TRIM(value),''''), ',') FROM string_split(@filter_clause, ',')
            SET @filter_sql    = CONCAT(' IN (', @filter_clause,')' );
         END

         SET @where_cls = CONCAT(@where_cls, @nl, 'AND [', @filter_field_nm, ']', @filter_sql);
      END

      ---------------------------------------------------------------
      -- Stage 7: If not clause is specified
      -- 250107: not like '' should not be scripted as NOT LIKE'%%' BUT like NOT LIKE''''
      ---------------------------------------------------------------
      IF @not_clause Is NOT NULL
      BEGIN
         EXEC sp_log 1, @fn, '300 ******** adding not clause';
         IF @not_clause = ''
         BEGIN
            SET @where_cls = CONCAT( @where_cls, @NL
            ,'AND [',@field_nm,'] NOT LIKE ''''');
         END
         ELSE
         BEGIN
            SET @where_cls = CONCAT( @where_cls, @NL
            ,'AND [',@field_nm,'] NOT LIKE ''%', @not_clause, '%''');
         END
      END

     -- Terminate the statement
      SET @where_cls = CONCAT( @where_cls, @NL,';');

      SET @select_sql = CONCAT('SELECT * FROM ', @table_nm, @NL, @where_cls);
      SET @update_sql = CONCAT('UPDATE ', @table_nm, @NL, @set_cls, @NL, @where_cls);

      ---------------------------------------------------------------
      -- Completed SQL
      ---------------------------------------------------------------
      EXEC sp_log 1, @fn, '400 completed';
      PRINT @Line2;
      EXEC sp_log 1, @fn, '410: ',@nl,'Select SQL:',@nl, @select_sql;
      PRINT @Line1;
      EXEC sp_log 1, @fn, '420: ',@nl,'Update SQL:',@nl, @update_sql;
      PRINT @Line2;
      BREAK

   END -- WHILE 1=1
   EXEC sp_log 1, @fn, '999: leaving';
END
/*
EXEC tSQLt.Run 'test.test_018_fnCrtUpdateSql';
EXEC dbo.sp_appLog_display @dir = 0;
EXEC dbo.sp_appLog_display @fn='sp_fnCrtUpdateSql';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 25-NOV-2023
-- Description: returns the log level key
-- =============================================
CREATE FUNCTION [dbo].[fnGetLogLevelKey] ()
RETURNS NVARCHAR(50)
AS
BEGIN
   RETURN N'LOG_LEVEL';
END
/*
EXEC test.sp_crt_tst_rtns 'dbo.fnGetLogLevelKey', 
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================
-- Author:      Terry Watts
-- Create date: 25-NOV-2023
-- Description: returns the log level
-- =============================================
CREATE FUNCTION [dbo].[fnGetLogLevel]()
RETURNS INT
AS
BEGIN
   RETURN dbo.fnGetSessionContextAsInt(dbo.fnGetLogLevelKey());
END
/*
EXEC test.sp_crt_tst_rtns 'dbo.fnGetLogLevel', 80;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =================================================================================
-- Author:      Terry Watts
-- Create date: 07-NOV-2024
-- Description: general update rtn
-- updates the given field in the given table. 
--
-- @fixup_cnt: returns the number of rows updated by this rtn it is not culmulative
--
-- Tests:
--    Test_017_sp_update
--    test_018_fnCrtUpdateSql
--
-- Called By:
--    sp_update_s2
--
-- xls order:
-- id, command, table, field, search_clause
--, filter_field, filter_clause, not_clause
--, replace_clause, field2_nm, field2_val
--, must_update, comments, exact_match
--
-- CHANGES:
-- 241205: updated @filter_op prm to one of {'LIKE', 'EQUALS', 'IN'}
-- =================================================================================
CREATE PROCEDURE [dbo].[sp_update]
    @table_nm        NVARCHAR(60)
   ,@field_nm        NVARCHAR(60)
   ,@search_clause   NVARCHAR(500)
   ,@filter_field_nm NVARCHAR(60)  -- = NULL
   ,@filter_op       NVARCHAR(6)    -- One of {'LIKE', 'EQUALS', 'IN'}
   ,@filter_clause   NVARCHAR(400)  --= NULL
   ,@not_clause      NVARCHAR(400)  --= NULL
   ,@exact_match     BIT            --= 0 -- if set 1 then match the full field
   ,@cs              BIT
   ,@replace_clause  NVARCHAR(500)
   ,@field2_nm       NVARCHAR(60)
   ,@field2_op       NVARCHAR(8)    -- 0 replace(default), 1 add
   ,@field2_clause   NVARCHAR(500)
   ,@extras          NVARCHAR(2000) = NULL-- sql clause to add one or more extra field values e,g 'comments=''some comment'' '
   ,@fixup_cnt       INT            = NULL OUT
   ,@select_sql      NVARCHAR(4000) = NULL OUT -- can be stored on the corrections table, or for testing
   ,@update_sql      NVARCHAR(4000) = NULL OUT -- can be stored on the corrections table, or for testing
   ,@execute         BIT             = 1     -- if clr then just return the sqls dont actually update
AS
BEGIN
   SET NOCOUNT OFF;

   DECLARE
    @fn              VARCHAR(35)   = 'sp_update'
   ,@nl              NCHAR(2)       = NCHAR(13)+NCHAR(10)
   ,@error_msg       VARCHAR(4000)
   ,@log_level       INT = dbo.fnGetLogLevel()

   SET @fixup_cnt = 0;

   If @log_level < 1
      EXEC sp_log 0, @fn, '000: starting
table_nm       :[',@table_nm       , '] 
field_nm       :[',@field_nm       , ']
search_clause  :[',@search_clause  , ']
filter_field_nm:[',@filter_field_nm, ']
filter_op      :[',@filter_op      , ']
filter_clause  :[',@filter_clause  , ']
not_clause     :[',@not_clause     , ']
exact_match    :[',@exact_match    , ']
cs             :[',@cs             , ']
replace_clause :[',@replace_clause , ']
field2_nm      :[',@field2_nm      , ']
field2_op      :[',@field2_op      , ']
field2_clause  :[',@field2_clause  , ']
extras         :[',@extras         , ']
execute        :[',@execute        , ']
';

   EXEC sp_fnCrtUpdateSql
    @table_nm       = @table_nm
   ,@field_nm       = @field_nm
   ,@search_clause  = @search_clause
   ,@filter_field_nm= @filter_field_nm
   ,@filter_op      = @filter_op
   ,@filter_clause  = @filter_clause
   ,@not_clause     = @not_clause
   ,@exact_match    = @exact_match
   ,@cs             = @cs
   ,@replace_clause = @replace_clause
   ,@field2_nm      = @field2_nm
   ,@field2_op      = @field2_op
   ,@field2_clause  = @field2_clause
   ,@extras         = @extras
   ,@select_sql     = @select_sql OUT
   ,@update_sql     = @update_sql OUT

   BEGIN TRY
      EXEC sp_log 0, @fn,'010: executing update sql'

      IF @execute = 1
         EXEC (@update_sql);
      ELSE
         EXEC sp_log 2, @fn,'030: NOT EXECUTING UPDATE sql (@execute=0)';

      SET @fixup_cnt = @@rowcount;
      EXEC sp_log 1, @fn, '040:executed sql, updated ', @fixup_cnt, ' rows',@row_count = @fixup_cnt;
   END TRY
   BEGIN CATCH
      -- if exception came from EXEC (@update_sql); ERROR_PROC and ERROR_LINE() dont work properly
      SET @error_msg = CONCAT('(099): raised exception# ', ERROR_NUMBER(),': ', ERROR_MESSAGE());
      DECLARE @line VARCHAR(4000) = REPLICATE('+', dbo.fnLen(@error_msg) + 46);
      PRINT CONCAT(@nl, @line);
      EXEC sp_log 4, @fn, @error_msg;

      EXEC sp_log 0, @fn, '520: params
table_nm       :[',@table_nm       , '] 
field_nm       :[',@field_nm       , ']
search_clause  :[',@search_clause  , ']
filter_field_nm:[',@filter_field_nm, ']
filter_op      :[',@filter_op      , ']
filter_clause  :[',@filter_clause  , ']
not_clause     :[',@not_clause     , ']
exact_match    :[',@exact_match    , ']
cs             :[',@cs             , ']
replace_clause :[',@replace_clause , ']
field2_nm      :[',@field2_nm      , ']
field2_op      :[',@field2_op      , ']
field2_clause  :[',@field2_clause  , ']
extras         :[',@extras         , ']
execute        :[',@execute        , ']
';
      PRINT CONCAT(@line, @nl);
      THROW 70000, @error_msg, 1;
   END CATCH

   EXEC sp_log 0, @fn, '999: leaving, @fixup_cnt: ',@fixup_cnt;
END
/*
DECLARE @delta INT = 0
EXEC sp_update_s2 'entry_mode', 'Contact/selective','contact,selective';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

--========================================================================
-- Author:      Terry Watts
-- Create date: 06-NOV-2024
-- Description: general S2 update fixup rtn
--    fixes up any filed in staging 2
--
-- Exception handling: logs error and rethrows exception
-- 
-- Responsibilities:
-- R01: updates Staging2 using the supplied parameters
--
-- Tests:
--    027_sp_update_s2

-- xls order:
-- id, command, table, field, search_clause
--, filter_field, filter_clause, not_clause
--, replace_clause, field2_nm, field2_val
--, must_update, comments, exact_match
--
-- CHANGES:
-- 241205: updated @filter_op prm to one of {'LIKE', 'EQUALS', 'IN'}
--========================================================================
CREATE PROCEDURE [dbo].[sp_update_s2]
    @field           NVARCHAR(80)
   ,@search_clause   NVARCHAR(500)
   ,@filter_field_nm NVARCHAR(60)
   ,@filter_op       NVARCHAR(6)     -- One of 'LIKE' 'EQUALS' 'IN'
   ,@filter_clause   NVARCHAR(400)   -- comma separated list use ' ' - do not wrap items like 'Fred',Bill'
   ,@not_clause      NVARCHAR(400)
   ,@exact_match     BIT
   ,@cs              BIT
   ,@replace_clause  NVARCHAR(500)
   ,@note_clause     NVARCHAR(500)   --- appends to notes
   ,@comments        NVARCHAR(500)
   ,@fixup_cnt       INT            = NULL  OUT
   ,@select_sql      NVARCHAR(4000) = NULL  OUT
   ,@update_sql      NVARCHAR(4000) = NULL  OUT
   ,@execute         BIT            = 1     -- if clr then just return the sqls dont actually update
AS
BEGIN
   SET NOCOUNT OFF;
   DECLARE
       @fn        VARCHAR(35)   = 'sp_update_s2'
      ,@extras    NVARCHAR(2000) -- sql clause to add extra field values e,g 'comments=''some comment'' '
      ,@error_msg VARCHAR(2000)
      ,@nl        NCHAR(2) = NCHAR(13) + NCHAR(10)
   ;

   BEGIN TRY
      EXEC sp_log 1, @fn, '000: starting, setting defaults';

      IF @comments IS NOT NULL
         SET @extras = CONCAT('comments =''',@comments, '''');

      IF @execute is null
         SET @execute = 1;

      EXEC sp_update
       @table_nm        = 'staging2'
      ,@field_nm        = @field
      ,@search_clause   = @search_clause
      ,@filter_field_nm = @filter_field_nm
      ,@filter_op       = @filter_op
      ,@filter_clause   = @filter_clause
      ,@not_clause      = @not_clause
      ,@exact_match     = @exact_match
      ,@cs              = @cs
      ,@replace_clause  = @replace_clause
      ,@field2_nm       = 'notes'
      ,@field2_clause   = @note_clause
      ,@field2_op       = 'Add'
      ,@extras          = @extras
      ,@fixup_cnt       = @fixup_cnt  OUT
      ,@select_sql      = @select_sql OUT
      ,@update_sql      = @update_sql OUT
      ,@execute         = @execute
     ;

   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving, @fixup_cnt: ', @fixup_cnt;
END
/*
EXEC tSQLt.Run 'test.test_027_sp_update_s2';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =======================================================
-- Author:      Terry Watts
-- Create date: 06-NOV-2024
-- Description: Updates the S2 pathogens field
--
-- Exception handling: logs error and rethrows exception
--
-- Called by:
--    sp_S2_fixup_row <- sp_S2_fixup <-- sp__main_import
-- =======================================================
CREATE   PROCEDURE [dbo].[sp_update_S2_path]
    @search_clause   NVARCHAR(500)
   ,@filter_field_nm NVARCHAR(40)
   ,@filter_op       NVARCHAR(8)
   ,@filter_clause   NVARCHAR(400) --=  NULL -- comma separated list use ' ' - do not wrap items like 'Fred',Bill'
   ,@not_clause      NVARCHAR(400) -- = NULL
   ,@exact_match     BIT           -- = 0
   ,@cs              BIT
   ,@replace_clause  NVARCHAR(500) --
   ,@note_clause     NVARCHAR(500) -- = NULL -- appends to notes
   ,@comments        NVARCHAR(1000)
   ,@fixup_cnt       INT            = NULL OUT
   ,@select_sql      NVARCHAR(4000) = NULL OUT
   ,@update_sql      NVARCHAR(4000) = NULL OUT
   ,@execute         BIT             = 1     -- if clr then just return the sqls dont actually update
AS
BEGIN
   DECLARE
    @fn        VARCHAR(35)   = 'UPDATE_S2_PATH'

   EXEC sp_log 1, @fn, '000: starting, @exact_match: ', @exact_match;

   EXEC sp_update_s2
       @field          = 'pathogens'
      ,@search_clause  = @search_clause
      ,@filter_field_nm= @filter_field_nm
      ,@filter_op      = @filter_op
      ,@filter_clause  = @filter_clause
      ,@not_clause     = @not_clause
      ,@exact_match    = @exact_match
      ,@cs             = @cs
      ,@replace_clause = @replace_clause
      ,@note_clause    = @note_clause     -- appends to notes
      ,@comments       = @comments
      ,@fixup_cnt      = @fixup_cnt       OUT
      ,@select_sql     = @select_sql      OUT
      ,@update_sql     = @update_sql      OUT
      ,@execute        = @execute   -- if clr then just return the sqls dont actually update
   ;

   EXEC sp_log 1, @fn, '999: leaving';
END
/*
DECLARE @fixup_cnt INT = 0
EXEC sp_update_S2_path 'Selective And Systemic Post-','Selective,Systemic,Post-emergent', NULL, NULL, @fixup_cnt OUT;
EXEC sp__main_import  @start_stage=4, @start_row=255, @stop_row=255, @restore_s3_s2=1, @import_file='D:\Dev\Farming\Data\LRAP-221018.txt' ,@cor_file = 'D:\Dev\Farming\Data\ImportCorrections 221018.txt'; -- stage 4 pre S2 fixup  the old 221018 import
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===============================================================
-- Author:      Terry watts
-- Create date: 30-MAR-2020
-- Description: returns the comma sep list wrapped in quotes
-- like so: 
-- INPUT:  'a,b,c,d,e,f';
-- OUTPUT: 'a','b','c','d','e','f'
-- ===============================================================
CREATE FUNCTION [dbo].[fnQuoteItems](@s VARCHAR(MAX))
RETURNS VARCHAR(MAX)
AS
BEGIN
   DECLARE @t VARCHAR(MAX);
   SELECT @t = CONCAT('''', string_agg(value, ''','''),'''') FROM string_split(@s, ',');
   RETURN @t
END
/*
PRINT fnQuoteItems('a,b,c,d,e,f');
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =================================================================================
-- Author:      Terry Watts
-- Create date: 05-FEB-2025
-- Description: update rtn using regex
-- updates the given field in the given table
--
-- @fixup_cnt: returns the number of rows updated by this rtn it is not culmulative
--
-- Tests:
--
-- Called By:
--    sp_fixup_S2_row
--
-- xls order:
-- id, command, table, field, search_clause
--, filter_field, filter_clause, not_clause
--, replace_clause, field2_nm, field2_val
--, must_update, comments, exact_match
--
-- CHANGES:
-- 241205: updated @filter_op prm to one of {'LIKE', 'EQUALS', 'IN'}
-- =================================================================================
CREATE PROCEDURE [dbo].[sp_update_reg_ex]
    @table_nm        NVARCHAR(60)
   ,@field_nm        NVARCHAR(60)
   ,@search_clause   NVARCHAR(500)
   ,@replace_clause  NVARCHAR(500)
--   ,@filter_field_nm NVARCHAR(60)   = NULL
   ,@filter_op       NVARCHAR(6)    = NULL-- One of {'LIKE', 'EQUALS', 'IN'} default: LIKE
   ,@filter_clause   NVARCHAR(400)  = NULL
   ,@not_clause      NVARCHAR(400)  = NULL
   ,@field2_nm       NVARCHAR(60)   = NULL
   ,@field2_op       NVARCHAR(8)    = NULL -- 0 replace(default), 1 add
   ,@field2_clause   NVARCHAR(500)  = NULL
   ,@extras          NVARCHAR(2000) = NULL-- sql clause to add one or more extra field values e,g 'comments=''some comment'' '
   ,@fixup_cnt       INT            = NULL OUT
   ,@select_sql      NVARCHAR(4000) = NULL OUT -- can be stored on the corrections table, or for testing
   ,@update_sql      NVARCHAR(4000) = NULL OUT -- can be stored on the corrections table, or for testing
   ,@execute         BIT            = 1     -- if clr then just return the sqls dont actually update
AS
BEGIN
   SET NOCOUNT OFF;

   DECLARE
    @fn              VARCHAR(35)   = 'sp_update_reg_ex'
   ,@nl              NCHAR(2)       = NCHAR(13)+NCHAR(10)
   ,@error_msg       VARCHAR(2000)
   ,@log_level       INT = dbo.fnGetLogLevel()
   ,@line            VARCHAR(200) = REPLICATE('-', 200)

   IF @filter_op IS NULL SET @filter_op = 'LIKE'

   SET @fixup_cnt = 0;

   If @log_level < 1
      EXEC sp_log 0, @fn, '000: starting';
      /*
table_nm       :[',@table_nm       , '] 
field_nm       :[',@field_nm       , ']
search_clause  :[',@search_clause  , ']
filter_field_nm:[',@filter_field_nm, ']
filter_op      :[',@filter_op      , ']
filter_clause  :[',@filter_clause  , ']
not_clause     :[',@not_clause     , ']
replace_clause :[',@replace_clause , ']
field2_nm      :[',@field2_nm      , ']
field2_op      :[',@field2_op      , ']
field2_clause  :[',@field2_clause  , ']
extras         :[',@extras         , ']
execute        :[',@execute        , ']
';
*/

   BEGIN TRY
      EXEC sp_log 0, @fn,'010: executing update sql   '

      -- Wrap each item in single quotes if the @filter_op is IN
      IF( @filter_op = 'IN')
         SELECT @filter_clause = dbo.fnQuoteItems(@filter_clause);

      SET @select_sql = CONCAT
(
'SELECT
[',@field_nm,'], dbo.RegEx_Match([',@field_nm,'], ''', @search_clause,''') AS search_cls', @nl
,'FROM [', @table_nm, ']', @nl
,'WHERE', @nl
,'[',@field_nm,'] '
,iif(@filter_op = 'LIKE', 'LIKE ''%', iif(@filter_op = '=', 'IN', ' IN ('))
--,' '
, @filter_clause
,iif( @filter_op = 'LIKE', '%''', iif(@filter_op='IN', ')', '')),@nl
--,'AND dbo.RegEx_Match([',@field_nm,'], ''', @search_clause,''') IS NOT NULL AND dbo.RegEx_Match([',@field_nm,'], ''', @search_clause,''') <> ''''',@nl
--,'AND [',@field_nm,'] NOT LIKE ''%', @replace_clause,'%''', @nl
,';'
);

      PRINT CONCAT(@nl, @line);
      EXEC sp_log 1, @fn, '030: SELECT SQL:',@nl, @select_sql;
      PRINT CONCAT(@line, @nl);

      -- UPDATE Staging2 SET crops = dbo.RegEx_Replace(crops, 'Snap.*Bean[s]*', 'Green Beans') WHERE crops LIKE '%Green Bean%'
      SET @update_sql = CONCAT
(
'UPDATE [',@table_nm,']
SET [',@field_nm,']=dbo.RegEx_Replace([',@field_nm,'], ''', @search_clause, ''', ''', @replace_clause,''')', @nl
,'FROM [', @table_nm, ']', @nl
,'WHERE', @nl
,'[',@field_nm,'] '
,iif(@filter_op= 'LIKE', 'LIKE ''%', iif(@filter_op = '=', 'IN', ' IN ('))
, @filter_clause
,iif(@filter_op='IN', ')', iif(@filter_op='LIKE', '%''', '')),@nl
--,'AND dbo.RegEx_Match([',@field_nm,'], ''', @search_clause,''') IS NOT NULL AND dbo.RegEx_Match([',@field_nm,'], ''', @search_clause,''') <> ''''',@nl
--,'AND [', @field_nm, '] NOT LIKE ''%',@replace_clause,'%''',@nl
,';'
)
;
      EXEC sp_log 1, @fn, '030: UPDATE SQL:',@nl, @update_sql;

      IF @execute = 1
      BEGIN
         EXEC sp_log 2, @fn,'040: EXECUTING UPDATE sql';
         EXEC (@update_sql);
      END
      ELSE
         EXEC sp_log 2, @fn,'030: NOT EXECUTING UPDATE sql';

      SET @fixup_cnt = @@rowcount;
      EXEC sp_log 1, @fn, '040: executed sql, updated ', @fixup_cnt, ' rows',@row_count = @fixup_cnt;
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 0, @fn, '999: leaving, @fixup_cnt: ',@fixup_cnt;
END
/*
DECLARE
    @select_sql      NVARCHAR(4000) = NULL OUT -- can be stored on the corrections table, or for testing
   ,@update_sql      NVARCHAR(4000) = NULL OUT -- can be stored on the corrections table, or for testing

dbo.sp_update_reg_ex 'staging2', 'crops', '[ ]*Cruciferae[ ]*', 'Crucifers'

EXEC tSQLt.Run 'test.test_069_sp_update_reg_ex';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ====================================================
-- Procedure:   sp_SetFixupRowId
-- Description: sets the row id during staging2 fixup
-- Design:      
-- Tests:       
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- ====================================================
CREATE PROCEDURE [dbo].[SetCtxFixupFile] @file NVARCHAR(500)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE @key NVARCHAR(50) = dbo.fnGetCtxFixupFileKey()
   ;

   EXEC sp_set_session_context @key, @file;

END
/*
EXEC SetCtxFixupFile 'D:\dev\abc.txt';
PRINT dbo.fnGetCtxFixupFile();
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ====================================================
-- Procedure:   sp_SetFixupRowId
-- Description: sets the row id during staging2 fixup
-- Design:      
-- Tests:       
-- Author:      Terry Watts
-- ALTER date: 06-JAN-2025
-- ====================================================
CREATE PROCEDURE [dbo].[SetCtxFixupRepCls] @SrchCls NVARCHAR(500)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE @key NVARCHAR(50) = dbo.fnGetCtxFixupRepClsKey()
   ;

   EXEC sp_set_session_context @key, @SrchCls;

END
/*
EXEC SetCtxFixupRepCls 'Coffee Berries';
PRINT dbo.fnGetCtxFixupRepCls();
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ====================================================
-- Procedure:   sp_SetFixupRowId
-- Description: sets the row id during staging2 fixup
-- EXEC tSQLt.Run 'test.test_<nnn>_sp_SetFixupRowId';
-- Design:      
-- Tests:       Terry Watts
-- Author:      06-JAN-2025
-- Create date: 
-- ====================================================
CREATE PROCEDURE [dbo].[SetCtxFixupRowId] @row_id INT
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE @key NVARCHAR(50) = dbo.fnGetCtxFixupRowIdKey()
   ;

   EXEC sp_set_session_context @key, @row_id;

END
/*
EXEC SetCtxFixupRowId 1000;
PRINT dbo.fnGetCtxFixupRowId();
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ====================================================
-- Procedure:   sp_SetFixupRowId
-- Description: sets the row id during staging2 fixup
-- Design:      
-- Tests:       
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- ====================================================
CREATE PROCEDURE [dbo].[SetCtxFixupSrchCls] @SrchCls NVARCHAR(500)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE @key NVARCHAR(50) = dbo.fnGetCtxFixupSrchClsKey()
   ;

   EXEC sp_set_session_context @key, @SrchCls;

END
/*
EXEC SetCtxFixupSrchCls 'Coffee Berry';
PRINT dbo.fnGetCtxFixupSrchCls();
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ====================================================
-- Procedure:   sp_SetFixupRowId
-- Description: sets the row id during staging2 fixup
-- Design:      
-- Tests:       
-- Author:      Terry Watts
-- Create date: 06-JAN-2025
-- ====================================================
CREATE PROCEDURE [dbo].[SetCtxFixupStgId] @row_id INT
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE @key NVARCHAR(50) = dbo.fnGetCtxFixupStgIdKey()
   ;

   EXEC sp_set_session_context @key, @row_id;

END
/*
EXEC SetCtxFixupStgId 999;
PRINT dbo.fnGetCtxFixupStgId();
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==========================================================================================================
-- Author:      Terry Watts
-- Create date: 22-JUN-2023
-- Rtn:         dbo.sp_S2_fixup_row
--
-- Description: uses 1 row of the ImportCorrections table to fixup Staging2.
--
-- Process: reads the command and from that determines which
-- process rtn to call and calls it.
--
-- CALLED BY:sp_FixupImportRegister
--
-- RETURNS:
--              severity   result
--       if OK  0          rows updates
--       stop   1          do it was false - but continue
--       error -1          error so stop, @result_msg will have the error msg
--
-- PRECONDITIONS:
-- PRE 01: Stop already handled by client code
--
-- RESPONSIBILITIES:
-- R01. corrects Staging2 using the supplied parameters
-- R02. updates the ImportCorrections row id=@id with the results {row count, result msg}
-- R03. remove {} from the search_clause parameter
-- R04. remove {} from the replace_clause parameter
-- R05. remove "  from the search_clause parameter
-- R06. remove "  from the replace_clause parameter
-- R07. remove {} from the not_clause parameter
-- R08. remove "  from the not_clause parameter
--
-- POSTCONDITIONS:
-- Returns rc: 0 if ok
--             1 if ok but warning
--             2 if error  - so record and stop
-- POST 01: command must be valid 1 of {SQL, sp_update, stop}
-- POST 02: @result_msg must be set and not 'NOT SET' else exception 87000 '@result_msg not set'
-- POST 03: if @must_update set then if no rows returned then EXCEPTION 87001, 'expected rows to be returned but none were', 1;
--
-- xls order:
-- id, command, table, field, search_clause, filter_field, filter_clause, not_clause
--, replace_clause, field2_nm, field2_val, must_update, comments, exact_match
--
-- Tests:
-- test_038_sp_S2_fixup
--
-- CHANGES
-- 230819: removing the expected count get and check
-- 231106: RC 0,1 are considered success codes, 0 is update, 1 is skip or doit =0
-- 240129: added preprocessing to remove wrapping {} and "" from @search_clause, @replace_clause,@not_clause
-- 240324: improved validation
-- 241221: added comments, but only for the current list of tables that have a comments field
-- ==========================================================================================================
CREATE PROCEDURE [dbo].[sp_fixup_S2_row]
    @id              INT
   ,@command         VARCHAR(100)
   ,@table_nm        NVARCHAR(60)
   ,@field_nm        NVARCHAR(50)
   ,@search_clause   NVARCHAR(4000)
   ,@filter_field_nm NVARCHAR(1000)
   ,@filter_op       NVARCHAR(8)
   ,@filter_clause   NVARCHAR(500)
   ,@not_clause      NVARCHAR(1000)
   ,@exact_match     BIT
   ,@cs              BIT
   ,@replace_clause  NVARCHAR(1000)
   ,@field2_nm       NVARCHAR(60)
   ,@field2_op       NVARCHAR(8)  -- 0 replace(default), 1 add
   ,@field2_clause   NVARCHAR(400)
   ,@must_update     BIT
   ,@comments        NVARCHAR(1000)
   ,@row_id          INT
   ,@stg_file        NVARCHAR(100)
   ,@fixup_cnt       INT           OUTPUT
   ,@result_msg      VARCHAR(150)  OUTPUT
   ,@select_sql      NVARCHAR(MAX) OUTPUT
   ,@update_sql      NVARCHAR(MAX) OUTPUT
   ,@execute         BIT           = 1     -- if clr then just return the sqls dont actually update
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
    @fn              VARCHAR(30)  = N'sp_fixup_S2_row'
   ,@error_msg       VARCHAR(4000)
   ,@cnt_sql         NVARCHAR(MAX)
   ,@exists_sql      NVARCHAR(MAX)
   ,@fixup_id        INT
   ,@fixup_id_key    NVARCHAR(30) = N'FIXUP_ROW_ID'
   ,@fixup_cnt_delta INT
   ,@search_cls_key  NVARCHAR(30) = N'SEARCH_CLAUSE'
   ,@replace_cls_key NVARCHAR(30) = N'REPLACE_CLAUSE'
   ,@msg             VARCHAR(MAX)
   ,@ndx             INT          =  0
   ,@nl              VARCHAR(2)  = NCHAR(10)+NCHAR(13)
   ,@rc              INT          = -1
   ,@str             VARCHAR(30)
   ,@where_clause    VARCHAR(MAX) = NULL
   ,@comments_clause VARCHAR(1000)
   ;

   EXEC sp_log 0, @fn, '000: starting: id: ', @id, ' must_update: ', @must_update;

   SET @result_msg = 'NOT SET';
   EXEC SetCtxFixupRowId   @id;
   EXEC SetCtxFixupStgId   @row_id;
   EXEC SetCtxFixupFile    @stg_file;
   EXEC SetCtxFixupSrchCls @search_clause;
   EXEC SetCtxFixupRepCls  @replace_clause;

   -- 241221: added comments, but only for the current list of tables that have a comments field
   IF @table_nm IN ('staging3','s2_tst_bak','s1_tst_221018','s1_tst_221018_bak','ImportCorrections'
,'staging2','ImportCorrectionsStaging_vw','s2_tst','ImportCorrectionsStaging')
      SET @comments_clause = CONCAT('comments=''', @comments, '''');

   BEGIN TRY
      WHILE 1=1
      BEGIN
         --EXEC dbo.sp_set_session_context @id_key, @id;
         --EXEC sp_set_ctx_cor_id @id;
         --EXEC dbo.sp_set_session_context @search_cls_key,  @search_clause
         --EXEC dbo.sp_set_session_context @replace_cls_key, @replace_clause

         -- 240129: added preprocessing to remove wrapping {} and "" from @search_clause, @replace_clause,@not_clause
         -- Preprocess params
         -- RESP 01. remove {} from the search_clause parameter
         SET @search_clause  = REPLACE( REPLACE(@search_clause , '{',''), '}','');
         -- RESP 03. remove "  from the search_clause parameter
         SET @search_clause  = REPLACE(@search_clause, '"','');
         -- RESP 02. remove {} from the replace_clause parameter
         SET @replace_clause = REPLACE( REPLACE(@replace_clause, '{',''), '}','');
         -- RESP 04. remove "  from the replace_clause parameter
         SET @replace_clause = REPLACE(@replace_clause, '"','');
         -- RESP 05. remove {} from the not_clause parameter
         SET @not_clause     = REPLACE( REPLACE(@not_clause, '{',''), '}','');
         -- RESP 06. remove "  from the not_clause parameter
         SET @not_clause     = REPLACE(@not_clause, '"','');

         SET @command = dbo.fnTrim(@command);

         ---------------------------------------------------------------------------------------------------------------------
         -- Validate args
         ---------------------------------------------------------------------------------------------------------------------
         EXEC sp_log 0, @fn, '010: validating args';

         -- POST 01: command must be valid 
         IF (@command IS NULL OR dbo.fnTrim(@command) = '')
         BEGIN
            SET @result_msg = CONCAT( 'row [', @id,'] command must be specified');
            EXEC sp_log 4, @fn, '020: ',@result_msg;
            SET @rc = 2; -- Error
            BREAK;
         END

         -- ASSERTION: stop handled (PRE CONDITIONS)

         -------------------------------------------
         -- Process
         -------------------------------------------

         IF (@command = 'sp_update')
         BEGIN
            EXEC sp_log 0, @fn, '030 handling command: sp_update';

            EXEC @rc = dbo.sp_update
                         @table_nm       = @table_nm
                        ,@field_nm       = @field_nm
                        ,@search_clause  = @search_clause
                        ,@filter_field_nm= @filter_field_nm
                        ,@filter_op      = @filter_op
                        ,@filter_clause  = @filter_clause -- comma separated 'in' list, wrap the entire list in single quotes
                        ,@not_clause     = @not_clause
                        ,@exact_match    = @exact_match
                        ,@cs             = @cs
                        ,@replace_clause = @replace_clause
                        ,@field2_nm      = @field2_nm
                        ,@field2_op      = @field2_op
                        ,@field2_clause  = @field2_clause
                        ,@extras         = @comments_clause
                        ,@fixup_cnt      = @fixup_cnt_delta  OUT
                        ,@select_sql     = @select_sql OUT -- can be stored on the corrections table, or for testing
                        ,@update_sql     = @update_sql OUT -- can be stored on the corrections table, or for testing
                        ,@execute        = @execute
                        ;

            SET @result_msg = 
            CASE
               WHEN @rc=0 THEN 'OK'
               WHEN @rc=1 THEN 'STOP'
               ELSE 'ERROR'
            END;

            BREAK;
         END

         IF (@command = 'sp_update_path')
         BEGIN
            EXEC sp_log 0, @fn, '040 handling command: sp_update_path';

            EXEC @rc = sp_update_S2_path
                @search_clause   = @search_clause
               ,@filter_field_nm = @filter_field_nm
               ,@filter_clause   = @filter_clause
               ,@filter_op       = @filter_op
               ,@not_clause      = @not_clause
               ,@exact_match     = @exact_match
               ,@cs              = @cs
               ,@replace_clause  = @replace_clause
               ,@note_clause     = @field2_clause
               ,@comments       = @comments
               ,@fixup_cnt       = @fixup_cnt_delta  OUT
               ,@select_sql      = @select_sql OUT
               ,@update_sql      = @update_sql OUT
               ,@execute         = @execute
               ;

            SET @result_msg = 
            CASE
               WHEN @rc=0 THEN 'OK'
               WHEN @rc=1 THEN 'STOP'
               ELSE 'ERROR'
            END;

            BREAK;
         END

         IF (@command = 'sp_update_s2')
         BEGIN
            EXEC sp_log 0, @fn, '050 handling command: sp_update_s2';

            EXEC @rc = sp_update_s2
                @field           = @field_nm
               ,@search_clause   = @search_clause
               ,@filter_field_nm = @filter_field_nm -- typically crops
               ,@filter_op       = @filter_op
               ,@filter_clause   = @filter_clause
               ,@not_clause      = @not_clause
               ,@exact_match     = @exact_match
               ,@cs              = @cs
               ,@replace_clause  = @replace_clause
               ,@note_clause     = @field2_clause
               ,@comments        = @comments
               ,@fixup_cnt       = @fixup_cnt_delta  OUT
               ,@select_sql      = @select_sql OUT
               ,@update_sql      = @update_sql OUT
               ,@execute         = @execute
               ;

-- Rtn: dbo.sp_S2_fixup_row

            SET @result_msg = 
            CASE
               WHEN @rc=0 THEN 'OK'
               WHEN @rc=1 THEN 'STOP'
               ELSE 'ERROR'
            END;

            BREAK;
         END

         IF @command = 'SQL' -- sql contains the sql
         BEGIN
            SET @update_sql = @search_clause;
            EXEC sp_log 1, @fn, '060 sql:
',@update_sql;

            -- Record the update sql
            --UPDATE ImportCorrections SET update_sql = @update_sql WHERE id = @id;

            EXEC @rc = sp_executesql @update_sql;
            SET @fixup_cnt_delta = @@ROWCOUNT;

            EXEC sp_log 0, @fn, '070 SQL command ran, checking rc code';
            IF @rc = 0
            BEGIN
               SET @result_msg = 'OK';
            END
            ELSE
            BEGIN
               SET @result_msg = CONCAT('080: sp_executesql @sql returned error code ', @rc);
               BREAK;
            END

            -------------------------------------------
            -- ASSERTION EXEC @sql ran ok maybe no rows
            -------------------------------------------

            EXEC sp_log 0, @fn, '090 SQL command ran ok (@rc chk passed)';
            BREAK;
         END -- end IF @command = 'SQL'

        IF (@command = 'reg_ex')
         BEGIN
            EXEC sp_log 0, @fn, '030 handling command: reg_ex';

            EXEC @rc = dbo.sp_update_reg_ex
                         @table_nm       = @table_nm
                        ,@field_nm       = @field_nm
                        ,@search_clause  = @search_clause
                        ,@replace_clause = @replace_clause
--                        ,@filter_field_nm= @field_nm
                        ,@filter_op      = @filter_op
                        ,@filter_clause  = @filter_clause -- comma separated 'in' list, wrap the entire list in single quotes
                        ,@not_clause     = @not_clause
--                        ,@exact_match    = @exact_match
--                        ,@cs             = @cs
                        ,@field2_nm      = @field2_nm
                        ,@field2_op      = @field2_op
                        ,@field2_clause  = @field2_clause
                        ,@extras         = @comments_clause
                        ,@fixup_cnt      = @fixup_cnt_delta  OUT
                        ,@select_sql     = @select_sql OUT -- can be stored on the corrections table, or for testing
                        ,@update_sql     = @update_sql OUT -- can be stored on the corrections table, or for testing
                        ,@execute        = @execute
                        ;

            SET @result_msg = 
            CASE
               WHEN @rc=0 THEN 'OK'
               WHEN @rc=1 THEN 'STOP'
               ELSE 'ERROR'
            END;

            BREAK;
         END

         -------------------------------------------
         -- ASSERTION If here then unhandled cmd
         -------------------------------------------

         SET @result_msg = CONCAT( 'ERROR unrecognised command: [', @command, '] id: ', @id, ' ',@result_msg);
         EXEC sp_log 4, @fn, '100 ', @result_msg;
         SET @rc = 2;
         BREAK;
      END -- end while 1=1

      EXEC sp_log 1, @fn, '110: fixup_cnt: ',@fixup_cnt_delta, ' must_update: ', @must_update, ' result_msg: ', @result_msg;

      UPDATE ImportCorrections
      SET
          select_sql = @select_sql
         ,update_sql = @update_sql
         ,update_cnt = @fixup_cnt_delta
         ,result_msg = @result_msg
      WHERE id = @id;

         -------------------------------------------
      -- Record the results
          -------------------------------------------
      SET @fixup_cnt = @fixup_cnt + @fixup_cnt_delta;

     IF(@fixup_cnt_delta=0 AND @must_update=1 AND @execute=1)
      BEGIN
         SET @result_msg = CONCAT(' Error in row_id[',@id,'] file: [', @stg_file, '] row ', @row_id,': no rows were updated. but must update chk specified ');
         EXEC sp_log 4, @fn, '120 ', @result_msg;
         THROW 56656, @result_msg, 1;
         SET @rc = 2;
      END

      ---------------------------------------------------------------------------------------------------------------------
      -- Process complete
      ---------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 0, @fn, '130: Process complete';
   END TRY
   BEGIN CATCH
      DECLARE @ex_msg VARCHAR(500) = CONCAT('ERROR: row: ', @id, ', caught exception ',ERROR_MESSAGE());
      EXEC .sp_log_exception @fn, '510: import row id:', @id, ' ', @ex_msg;

      -- Log the results in the ImportCorrections table
      UPDATE ImportCorrections
      SET
          select_sql = @select_sql
         ,update_sql = @update_sql
         ,update_cnt = @fixup_cnt
         ,result_msg = @ex_msg
      WHERE id = @id;

      THROW;
   END CATCH

   EXEC sp_log 0, @fn, '999: leaving';
   RETURN @rc;
END
/*
EXEC test.sp__crt_tst_rtns '[dbo].[sp_S2_fixup_row]', 8
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: Raises exception if @a is NULL
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_not_null]
    @val       SQL_VARIANT
   ,@prm_nm    VARCHAR(200)   = NULL -- this should be the parameter name
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT             = NULL
   ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
DECLARE
    @fnThis     VARCHAR(60) = N'sp_assert_not_null'
   ,@valTxt VARCHAR(100)= CONVERT(VARCHAR(20), @val)
   ,@msg0   VARCHAR(200)

   EXEC sp_log @log_level, @fnThis, '000 starting @val:[',@valTxt,']';

   IF (@val IS NOT NULL)
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, ASSERTION: [',@prm_nm, '] IS NOT NULL';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   SET @msg0 = CONCAT('ERROR: [', @prm_nm, '] is NULL')
   EXEC sp_log 4, @fnThis, 'ASSERTION: val:[',@prm_nm, '] is NULL - raising exception ', @ex_num;
   IF @ex_num IS NULL SET @ex_num = 50004;

   EXEC sp_raise_exception
       @msg0   = @msg0
      ,@msg1   = @msg1
      ,@msg2   = @msg2
      ,@msg3   = @msg3
      ,@msg4   = @msg4
      ,@msg5   = @msg5
      ,@msg6   = @msg6
      ,@msg7   = @msg7
      ,@msg8   = @msg8
      ,@msg9   = @msg9
      ,@msg10  = @msg10
      ,@msg11  = @msg11
      ,@msg12  = @msg12
      ,@msg13  = @msg13
      ,@msg14  = @msg14
      ,@msg15  = @msg15
      ,@msg16  = @msg16
      ,@msg17  = @msg17
      ,@msg18  = @msg18
      ,@msg19  = @msg19
      ,@msg20  = @msg20
      ,@ex_num = @ex_num
      ,@fn     = @fn
      ;
END
/*
EXEC tSQLt.Run 'test.test_049_sp_assert_not_null_or_empty';
EXEC tSQLt.RunAll;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[CorrectionLog](
	[id] [int] NOT NULL,
	[stg_id] [int] NULL,
	[cor_id] [int] NULL,
	[old] [varchar](250) NULL,
	[new] [varchar](250) NULL,
	[search_clause] [varchar](250) NULL,
	[replace_clause] [varchar](150) NULL,
	[not_clause] [varchar](150) NULL,
	[row_cnt] [int] NULL,
 CONSTRAINT [PK_CorrectionLog] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =======================================================================================================================================================
-- Author:      Terry Watts
-- Create date: 22-JUN-2023
-- Rtn:         dbo.sp_S2_fixup
--
-- Description: Fixup the staging 2 table for LRAP import, using the
-- ImportCorrections table as the corrections src to get the values to change
--
-- CALLED BY    sp__main_import_pesticide_register
--
-- RESPONSIBILITIES:
-- R01: corrects Staging2 using the supplied parameters (delegated to sp_S2_fixup_row)
-- R02: updates the ImportCorrections row id=@id with the results {row count, result msg} (delegated to sp_S2_fixup_row)
-- R03: remove {} from the search_clause parameter (delegated to sp_S2_fixup_row)
-- R04: remove {} from the replace_clause parameter (delegated to sp_S2_fixup_row)
-- R05: remove "  from the search_clause parameter (delegated to sp_S2_fixup_row)
-- R06: remove "  from the replace_clause parameter (delegated to sp_S2_fixup_row)
-- R07: remove {} from the not_clause parameter (delegated to sp_S2_fixup_row)
-- R08: remove "  from the not_clause parameter (delegated to sp_S2_fixup_row)
-- R09: if the cor_file does not exist throw exception 53600, 'correction file must exist',1;
-- R10: if STOP signal detected return 1 and @result_msg = ''
-- R11: if ERROR durinig import return 2
-- R12: if search cls = replace then throw exception 53610, 'replace clause = search clause {row id}',1;
--
-- PRECONDITIONS:
--    ImportCorrections table populated
--
-- POSTCONDITIONS:
      -- POST 01: if STOP signal detected return 1
      -- POST 02: if ERROR                return 2
--
-- Parameters:  default
-- @start_row      1
-- @stop_row       100000
--
-- RETURNS:
--    0  :  OK
--    1  :  STOP signal detected
--   -2  :  Error
--
-- TESTS: test_038_sp_S2_fixup
--
-- xls order:
-- id, command, table, field, search_clause, filter_field, filter_clause, not_clause
--, replace_clause, field2_nm, field2_val, must_update, comments, exact_match
--
-- CHANGES
-- 230622: added Skip
-- 230625: added Do it to print the action SQL but not actually run the sql
-- 230629: added must_update to make sure something changed in the table
-- 230703: added user supllied skip to to overrride the spreadsheet skip
-- 230704: added comment lines
-- 230715: doit now supports STOP AFTER[ DOIT=[0,1]]
--         added user supplied skip to
-- 231014: renamed the fixupimport register sp for Staging to:  sp_fixup_s2_using_corrections_file
-- 231014: added postcondition chks for the non existence of 'Golden apple Snails' and 'Golden apple Snails (kuhol)'
-- 231014: added a @stop_after_row parameter to stop the import from the main commandline, changed the order of params
-- 231019: tidied up the logging not to be repetitive @skip_to_row, @stop_after_row, [import id], [@fixup_cnt] moved to header log
-- 231106: RC 0,1 are considered success codes, 0 is update, 1 is skip or doit =0
-- 240129: change of logic if doit undefined: sewt default = 1 (do it anyway)
-- 240211: moved must update failure logic to sp_update_if_exists
--         also added a chk to sp_update_if_exists when failed to update when @must_update set then chk rows would be selected using the srch_sql_clause
-- 240329: parameter @cor_file_path changed to @cor_file - now uses the root folder
-- 250103: added the action column to hold actions like SKIP,STOP so that when skipping we dont lose the command
-- 250106: at the end of the fixup run fixup commas (leading, trailing) and internal double commas
-- =======================================================================================================================================================
CREATE PROCEDURE [dbo].[sp_fixup_S2]
    @start_row          INT            = 1      -- only work on the first imp file
   ,@stop_row           INT            = 100000 -- only work on the first imp file
   ,@row_count          INT            OUTPUT
   ,@fixup_cnt          INT            OUTPUT
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
    @fn                 VARCHAR(35)   = 'sp_fixup_S2'
   ,@cnt                INT
   ,@action             VARCHAR(12)
   ,@command            VARCHAR(50)
   ,@comments           VARCHAR(1000)
   ,@cor_log_flg_key    VARCHAR(30)   = N'COR_LOG_FLG'
   ,@cs                 BIT
   ,@cursor             CURSOR
   ,@exact_match        BIT
   ,@field_nm           VARCHAR(60)
   ,@field2_nm          VARCHAR(60)
   ,@field2_op          VARCHAR(8)
   ,@field2_clause      VARCHAR(150)
   ,@file_fxp_cnt_new   INT            = 0
   ,@file_fxp_cnt_prev  INT            = 0
   ,@file_row_cnt       INT            = 0
   ,@filter_field_nm    VARCHAR(60)
   ,@filter_op          VARCHAR(8)
   ,@filter_clause      VARCHAR(150)
   ,@first_time         BIT            = 1
   ,@id                 INT            = 0
   ,@import_id          INT
   ,@len                INT
   ,@line               VARCHAR(150)   = REPLICATE('-', 40)
   ,@line2              VARCHAR(150)   = REPLICATE('*', 150)
   ,@msg                VARCHAR(2000)
   ,@must_update        BIT
   ,@ndx                INT            = 0
   ,@nl                 VARCHAR(2)     = NCHAR(13)+NCHAR(10)
   ,@not_clause         VARCHAR(MAX)
   ,@rc                 INT            = 0       -- Controls the cursor get loop
   ,@replace_clause     VARCHAR(MAX)
   ,@result_msg         VARCHAR(500)
   ,@row_id             INT
   ,@search_clause      VARCHAR(500)
   ,@select_sql         VARCHAR(MAX)
   ,@stg_file_new       VARCHAR(100)
   ,@stg_file_prev      VARCHAR(100)   = ''
   ,@stp_flg            BIT            = 0
   ,@table_nm           VARCHAR(60)
   ,@update_sql         VARCHAR(MAX)

   EXEC sp_log 2, @fn, '000: starting:
start_row:[', @start_row,']
stop_row: [', @stop_row ,']
';
-- stg_file: [',@stg_file  ,']

   BEGIN TRY
         -------------------------------------------------------
         -- Parameter Defaults
         -------------------------------------------------------
      IF @start_row IS NULL SET @start_row = 1;
      IF @stop_row  IS NULL SET @stop_row = 100000;

      -------------------------------------------------------
      -- Parameter Validation
      -------------------------------------------------------
      EXEC sp_log 1, @fn, '010: Parameter Validation';
      EXEC sp_assert_not_null @row_count, '@row_count param IS NULL', 1;
      EXEC sp_assert_not_null @fixup_cnt, '@fixup_cnt param';

      -------------------------------------------------------
      -- Setup
      -------------------------------------------------------
      EXEC sp_log 1, @fn, '020: deleting CorrectionLog, ';

      TRUNCATE TABLE CorrectionLog;--DELETE FROM CorrectionLog;
      IF @start_row = 1
      BEGIN
         EXEC sp_log 1, @fn, '030: clearing the update counts from the previous run';
         UPDATE ImportCorrections SET update_cnt = 0;
      END

      -- Remove the old import comments
      EXEC sp_log 1, @fn, '040: Remove old import comments';
      UPDATE staging2 SET comments='';

      -- Enable the S2 trigger
      ENABLE TRIGGER staging2.sp_Staging2_update_trigger ON Staging2;

      -- Turn on S2 update logging
      EXEC dbo.sp_set_session_context @cor_log_flg_key, 1;
      EXEC sp_log 0, @fn, '050: B4 main do loop';

      SET @cursor = CURSOR FOR
      SELECT id, [action],[command], table_nm, field_nm, search_clause, filter_field_nm, filter_op
      , filter_clause, not_clause, exact_match, cs, replace_clause, field2_nm, field2_op, field2_clause, must_update, comments, @row_id, stg_file
      FROM ImportCorrections order by id

      OPEN @cursor;
      EXEC sp_log 1, @fn, '060: before Row fetch loop, @@FETCH_STATUS: [', @@FETCH_STATUS, ']';
      FETCH NEXT FROM @cursor INTO @id, @action, @command, @table_nm, @field_nm, @search_clause, @filter_field_nm, @filter_op
         ,@filter_clause, @not_clause, @exact_match, @cs, @replace_clause, @field2_nm, @field2_op, @field2_clause, @must_update, @comments, @row_id, @stg_file_new;

      -------------------------------------------------------
      -- Main process loop
      -------------------------------------------------------
      WHILE (@@FETCH_STATUS = 0)-- Row fetch loop
      BEGIN
         WHILE (1=1) -- Do loop
         BEGIN
            EXEC sp_log 1, @fn, '070: top of Row fetch loop, cor id: ',@id;

            IF @stg_file_prev <> @stg_file_new
            BEGIN
               IF @file_row_cnt > 0
               BEGIN
                  -- Not first time
                  EXEC sp_log 1, @fn, '080: finished processing file recording summary results: ',@stg_file_prev, ' row_cnt: ', @file_row_cnt, ' file_fxp_cnt:', @file_fxp_cnt_prev;
                  UPDATE CorFiles
                  SET
                     row_cnt   = @file_row_cnt
                    ,fixup_cnt = @fixup_cnt
                  WHERE [file] = @stg_file_prev
               END

               -- Every time if @stg_file_prev <> @stg_file_new
               SET @stg_file_prev = @stg_file_new;
            END

            -- Ready for next time
            SET @file_fxp_cnt_prev = @file_fxp_cnt_new;

            IF @id < @start_row
            BEGIN
               EXEC sp_log 1, @fn, '090: skipping row: ', @id;
               BREAK; -- RC= 0  so CONTINUE i.e skip this row;
            END

            EXEC sp_log 1, @fn, @nl, @line, ' row ', @id, ' ', @line;
            SET @len = dbo.fnLen(@search_clause);
--            EXEC sp_log 1, @fn, '100: @must_update: ',@must_update;

            -- Standardise action and command
            SET @command= LOWER(dbo.fnTrim(@command));
            SET @action = LOWER(dbo.fnTrim(@action));

      -------------------------------------------------------
            -- Handle Skip and comment  rows
      -------------------------------------------------------
            IF @action LIKE '%skip%' OR  @action LIKE ';%' OR @action LIKE 'COMMENT%'
            BEGIN
               EXEC sp_log 1, @fn,'120: skipping comment row: ', @id;
               BREAK; -- RC= 0  so CONTINUE;
            END

            EXEC sp_log 1, @fn, '130: calling sp_S2_fixup_row
id:               [', @id              ,']
row_id            [', @row_id          ,']
stg_file          [', @stg_file_new    ,']
action:           [', @action          ,']
command:          [', @command         ,']
table_nm:         [', @table_nm        ,']
field_nm:         [', @field_nm        ,']
search_clause:    [', @search_clause   ,']
replace_clause    [', @replace_clause  ,']
filter_field_nm:  [', @filter_field_nm ,']
filter_op         [', @filter_op       ,']
filter_clause     [', @filter_clause   ,']
not_clause        [', @not_clause      ,']
exact_match       [', @exact_match     ,']
cs                [', @cs              ,']
field2_nm         [', @field2_nm       ,']
field2_op         [', @field2_op       ,']
field2_clause     [', @field2_clause   ,']
must_update       [', @must_update     ,']
comments          [', @comments        ,']
';

            -- R12: if search cls = replace then throw exception 53610, 'replace clause = search clause {row id}',1;
            -- 240110: Sql server ignores trailing spaces when comparing string values
            IF CONVERT(VARBINARY(500),@search_clause)=CONVERT(VARBINARY(500),@replace_clause)
            BEGIN
               EXEC sp_log 4, @fn, '075: replace clause = search clause @id: ', @id, ', @stg_file_new: ',@stg_file_new,'
search clause :[', @search_clause, ']
replace clause:[', @replace_clause, ']
';
               EXEC sp_raise_exception 53610, '075: replace clause = search clause @id: ', @id, ', @stg_file_new: ',@stg_file_new, @fn=@fn;
            END

            -- Handle stop
            IF @action = 'stop'
            BEGIN
               SET @result_msg =CONCAT( 'stop detected at row ', @id);
               EXEC sp_log 4, @fn, @line2
               EXEC sp_log 4, @fn, '140: ',@result_msg;
               EXEC sp_log 4, @fn, @line2

               UPDATE ImportCorrections
               SET
                   result_msg = @result_msg
                  ,update_cnt = @fixup_cnt
               WHERE id = @id
               ;

               SET @rc = 1 -- Signal stop
               BREAK
            END

            IF @action = 'skip'
            BEGIN
               SET @result_msg =CONCAT( 'skip detected at row ', @id);
               EXEC sp_log 4, @fn, @line2
               EXEC sp_log 4, @fn, '150: ',@result_msg;
               EXEC sp_log 4, @fn, @line2

               UPDATE ImportCorrections 
               SET
                   result_msg = @result_msg
                  ,update_cnt = @fixup_cnt
               WHERE id = @id
               ;

               --SET @file_fixup_cnt = 0; -- ready for next file
               SET @rc = 0;
               BREAK; -- RC= 0  so CONTINUE;
            END

            EXEC sp_log 0, @fn, '160: calling sp_S2_fixup_row';

            -- Get the return status from fixup row - return it if error
            EXEC @rc = sp_fixup_S2_row
                  @id             = @id
                  ,@command        = @command
                  ,@table_nm       = @table_nm
                  ,@field_nm       = @field_nm
                  ,@search_clause  = @search_clause
                  ,@filter_field_nm= @filter_field_nm
                  ,@filter_op      = @filter_op
                  ,@filter_clause  = @filter_clause
                  ,@not_clause     = @not_clause
                  ,@exact_match    = @exact_match
                  ,@cs             = @cs
                  ,@replace_clause = @replace_clause
                  ,@field2_nm      = @field2_nm
                  ,@field2_op      = @field2_op
                  ,@field2_clause  = @field2_clause
                  ,@must_update    = @must_update
                  ,@comments       = @comments
                  ,@row_id         = @row_id
                  ,@stg_file       = @stg_file_new
                  ,@fixup_cnt      = @file_fxp_cnt_new OUTPUT -- incremental
                  ,@result_msg     = @result_msg       OUTPUT
                  ,@select_sql     = @select_sql       OUTPUT
                  ,@update_sql     = @update_sql       OUTPUT

            IF  @row_count IS NULL THROW 56000, '@row_count is NULL', 1;
            SET @row_count = @row_count + 1;
            EXEC sp_log 0, @fn, '170: ret frm sp_S2_fixup_row, @rc: ',@rc, ', @row_count: ', @row_count, ', @fixup_cnt:', @fixup_cnt, @row_count = @row_count;

            IF @id >= @stop_row
            BEGIN
               EXEC sp_log 1, @fn, '180: reached stop row: ',@stop_row,' stopping'
               SET @rc = 1; -- signal stop
               BREAK; -- RC= 0  so CONTINUE;
            END

            IF @rc = 0 -- OK
            BEGIN
               SET @result_msg = 'OK';
               BREAK; -- RC= 0  so CONTINUE;
            END

            IF @rc = 1 -- STOP signal detected
            BEGIN
               EXEC sp_log 2, @fn, '190: STOP or last row encountered: ', @id, ' stopping after this row';
               BREAK; -- RC= 1 so STOP;
            END

            IF @rc = 2
            BEGIN
               SET @msg = CONCAT('ERROR: fixup LRAP import error ', @result_msg, ' row: ', @id, ' raising exception');
               EXEC sp_log 4, @fn, '200: ', @msg;
               THROW 50003, @msg, 1;
               --BREAK;
            END

            BREAK; -- ALWAYS
         END -- while 1=1

         IF @rc<> 0 -- STOP;
            BREAK;

         -- Get the next row if poss
         FETCH NEXT FROM @cursor INTO @id, @action, @command, @table_nm, @field_nm, @search_clause, @filter_field_nm, @filter_op
         ,@filter_clause, @not_clause, @exact_match, @cs, @replace_clause, @field2_nm, @field2_op, @field2_clause, @must_update, @comments, @row_id, @stg_file_new;
      END -- end outer while loop

      -- Need to do this for the last file imported (including the 1 file scenario)
      EXEC sp_log 1, @fn, '210: finished processing file recording summary results: ',@stg_file_prev, ' row_cnt: ', @file_row_cnt, ' file_fxp_cnt:', @file_fxp_cnt_prev;
      UPDATE CorFiles
      SET
          row_cnt   = @file_row_cnt
         ,fixup_cnt = @fixup_cnt
      WHERE [file]  = @stg_file_prev
      ;

      -- 250106: at the end of the fixup run fixup commas (leading, trailing) and internal double commas
      EXEC sp_log 1, @fn, '220: cleaning up redundant commas in pathogens after fixup';
      DECLARE @fixup_cnt2 INT;
      UPDATE Staging2 SET pathogens = TRIM(',' FROM pathogens) WHERE pathogens like ',%' OR  pathogens like '%,';
      SET @fixup_cnt2 = @@ROWCOUNT;
      UPDATE Staging2 SET pathogens = REPLACE(pathogens, ',,',',') WHERE pathogens like '%,,%';
      SET @fixup_cnt2 = @fixup_cnt2 + @@ROWCOUNT;

      -- Chk it worked
      IF EXISTs (SELECT 1 FROM Staging2 WHERE pathogens LIKE ',%') -- this can happen if removing first item in a list
         EXEC sp_raise_exception 53152, 'INVARIANT VIOLATION S2 pathogens has leading '',''', @fn=@fn

      IF EXISTs (SELECT 1 FROM Staging2 WHERE pathogens LIKE '%,,%') -- this can happen if removing a mid item in a list
         EXEC sp_raise_exception 53152, 'INVARIANT VIOLATION S2 pathogens contains '',,''', @fn=@fn

      EXEC sp_log 1, @fn, '230: cleaned up ',@fixup_cnt2,' redundant commas in pathogens after fixup';

      -------------------------------------------------------
      -- Process complete
      -------------------------------------------------------
      EXEC sp_log 1, @fn, '250: Process complete';
   END TRY
   BEGIN CATCH
      DECLARE 
          @ex_num  INT
         ,@ex_msg  VARCHAR(500)
         ,@ex_proc VARCHAR(80)
         ,@ex_line VARCHAR(20)
         ,@err_msg VARCHAR(500)

      SET @ex_msg  = ERROR_MESSAGE();
      SET @ex_num  = ERROR_NUMBER();
      SET @ex_proc = ERROR_PROCEDURE();
      SET @ex_line = CAST(ERROR_LINE() AS VARCHAR(20));
      SET @err_msg = CONCAT(' error in ', @ex_proc, '(',@ex_line, '): row: ', @id, ' exception: ', @ex_num, ' ',@ex_msg);
      EXEC dbo.sp_set_session_context @cor_log_flg_key, 0;
      EXEC sp_log_exception @fn, '500: @result_msg: ', @result_msg, @ex_num = @ex_num OUT, @ex_msg = @ex_msg OUT;

      -------------------------------------------------------
      -- Close abnormally
      -------------------------------------------------------
      -- Close the cursor
      IF CURSOR_STATUS('global','@cursor') = 1
      BEGIN
         EXEC sp_log 1, @fn, '510: Close abnormally: Close the cursor, disable trigger';
         CLOSE      @cursor;
         EXEC sp_log 1, @fn, '520: DEALLOCATING @cursor';
         DEALLOCATE @cursor;
         EXEC sp_log 1, @fn, '530: DEALLOCATed @cursor';
      END

      -- Update context
      EXEC sp_set_session_context N'fixup count', @fixup_cnt;
      EXEC dbo.sp_set_session_context @cor_log_flg_key, 0;

      -- Disable the trigger
      DISABLE TRIGGER staging2.sp_Staging2_update_trigger ON staging2;

      EXEC sp_log 1, @fn, '540: throw revised exception: ', @err_msg;
      IF @ex_num < 50000  SET @ex_num = @ex_num + 50000;

      THROW @ex_num, @err_msg, 1;
   END CATCH

   -------------------------------------------------------
   -- Close normally
   -------------------------------------------------------
   CLOSE      @cursor;
   DEALLOCATE @cursor;
   DISABLE TRIGGER staging2.sp_Staging2_update_trigger ON staging2;
   EXEC dbo.sp_set_session_context @cor_log_flg_key, 0;

   -------------------------------------------------------
   -- Report summary
   -------------------------------------------------------
   DECLARE 
       @file_cnt INT
   ;

   EXEC sp_log 2, @fn, '600: Report summary: ',@file_cnt,' files, #rows imported: ',@id,' #fixups: ',@fixup_cnt, ' @rc: ', @rc;
   SELECT @file_cnt = COUNT(*) FROM CorFiles;

   PRINT CONCAT(@NL, @NL, @Line2);
   EXEC sp_log 2, @fn, '610: Completed import of ',@file_cnt,' files, #rows imported: ',@id,' #fixups: ',@fixup_cnt, ' @rc: ', @rc;
   PRINT CONCAT(@Line2, @NL,@NL);

   EXEC sp_log 2, @fn, '999: leaving, @fixup_cnt: ',@fixup_cnt, ' @rc: ', @rc;
   RETURN @rc;
END
/*
------------------------------------------------
EXEC tSQLt.Run 'test.test_038_sp_S2_fixup';

EXEC tSQLt.RunAll;
------------------------------------------------
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =======================================================================
-- Author:      Terry Watts
-- Create date: 11-Nov-2024
-- Description: helper rtn
--
-- Algorithm
-- Import the following tables from the directory
-- gafgroup, gaflink, gafname, gaigroup, gailink, gainame, ntxlink, ntxname
-- ,pflgroup, pfllink, pflname, repco
--
-- PRECONDITIONS:
-- PRE01: all params valid
-- =======================================================================
CREATE   PROCEDURE [dbo].[sp_import_eppo_file_helper]
    @table              VARCHAR(70)
   ,@file               VARCHAR(70)  = NULL   -- defaults to <table>.txt
   ,@field_terminator   NCHAR(1)      = ','
   ,@folder             VARCHAR(500) = NULL   -- defaults to D:\Dev\Farming\Data\EPPO.bayer
   ,@non_null_flds      VARCHAR(500) = NULL
   ,@display_table      BIT           = 0
   ,@first_row          INT           = 2
   ,@last_row           INT           = NULL
   ,@exp_row_cnt        INT           = NULL
   ,@row_cnt            INT           = NULL      OUT
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
    @fn                 VARCHAR(35)   = 'import_eppo_helper'
   ,@path               VARCHAR(600)
   ,@bckslsh            VARCHAR(1)    = NCHAR(92)
   ,@tab                VARCHAR(1)    = NCHAR(9)
   ,@nl                 VARCHAR(2)    = NCHAR(13) + NCHAR(10)

   IF @file             IS NULL SET @file = CONCAT(REPLACE(@table, 'Staging',''), '.txt');
   IF @field_terminator IS NULL SET @field_terminator = ',';
   IF @folder           IS NULL SET @folder = 'D:\Dev\Farming\Data\EPPO.bayer';

   SET @path = CONCAT(@folder, @bckslsh, @file);
   EXEC sp_log 1, @fn, 'starting
table           :[',@table           ,']
file            :[',@file            ,']
field_terminator:[',@field_terminator,']
folder          :[',@folder          ,']
non_null_flds   :[',@non_null_flds   ,']
display_table   :[',@display_table   ,']
first_row       :[',@first_row       ,']
last_row        :[',@last_row        ,']
exp_row_cnt     :[',@exp_row_cnt     ,']
row_cnt         :[',@row_cnt         ,']
   ';

   EXEC sp_import_txt_file
       @table           = @table
      ,@view            = NULL
      ,@file            = @path
      ,@field_terminator= @field_terminator
      ,@display_table   = @display_table
      ,@first_row       = @first_row
      ,@last_row        = @last_row
      ,@exp_row_cnt     = @exp_row_cnt
      ,@non_null_flds   = @non_null_flds
      ,@row_cnt         = @row_cnt OUT
      ;

   IF @exp_row_cnt IS NOT NULL EXEC sp_assert_equal @exp_row_cnt, @row_cnt, 'exp/act row count'
   EXEC sp_log 1, @fn, 'leaving';
END
/*
EXEC tSQLt.Run 'test.test_022_sp_import_eppo_file_helper';
EXEC sp_import_eppo_file_helper 'EPPO_GafGroupStaging'
*/


GO
GO

CREATE TYPE [dbo].[EPPO] AS TABLE(
	[ordinal] [int] NULL,
	[table] [varchar](250) NOT NULL,
	[exp_row_cnt] [int] NULL,
	PRIMARY KEY CLUSTERED 
(
	[table] ASC
)WITH (IGNORE_DUP_KEY = OFF)
)

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===================================================================================
-- Author:      Terry Watts
-- Create date: 11-Nov-2024
-- Description: Imports the group of eppo files into their resoective straaging tables
-- PRECONDITIONS: none
-- POSTCONDITIONS:
-- POST 01: all epp tables populated
--
-- Algorithm
-- Import the following tables from the f@older folder:
--    gafgroup, gaflink, gafname,
--    gaigroup, gailink, gainame,
--    ntxlink,  ntxname,
--    pflgroup, pfllink, pflname,
--    repco
--
-- The associated file names are:
--    gafgroup.txt, gaflink.txt, gafname.txt,
--    gaigroup.txt, gailink.txt, gainame.txt,
--    ntxlink.txt, ntxname.txt,
--    pflgroup.txt. pfllink.txt. pflname.txt,
--    repco.txt
--
-- CALLED BY: sp_import_eppo
-- ===================================================================================
CREATE PROCEDURE [dbo].[sp_import_eppo_files]
    @folder           VARCHAR(500)
   ,@field_terminator NCHAR(1)     = ','
   ,@exp_cnts         VARCHAR(2000)= NULL
   ,@display_tables   BIT          = 0

AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
    @fn           VARCHAR(35) = 'import_eppo_files'
   ,@row_cnt      INT
   ,@exp_row_cnt  INT
   ,@table        VARCHAR(60)
   ,@eppo         Eppo
   ;

   EXEC sp_log 2, @fn,'000: starting:
@folder:   [', @folder,   ']'
;
   BEGIN TRY
         -------------------------------------------------------------------------------------------
         -- 01: Validate parameters
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'010: validating parameters';

         -------------------------------------------------------------------------------------------
         -- 02: Initialise
         -------------------------------------------------------------------------------------------

           -------------------------------------------------------------------------------------------
         -- 03: Process
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'020: starting process';

         IF @exp_cnts IS NOT NULL
         BEGIN
            EXEC sp_log 1, @fn, '030: checking the expected row cnts   ';

            INSERT INTO @eppo(ordinal, [table], exp_row_cnt)
            SELECT ordinal, [table], exp_row_cnt
            FROM
            (
               SELECT ordinal, SUBSTRING(value, 1,CHARINDEX(':', value)-1) AS [table], SUBSTRING(value, CHARINDEX(':', value)+1, 900) AS [exp_row_cnt]
               FROM string_split(@exp_cnts, ',',1) as A
            ) X;
         END

         EXEC sp_log 1, @fn,'040: importing Eppo_GafGroup';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'GafGroup'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_GafGroupStaging'
               ,@file            = 'Eppo_GafGroup.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,lang,langno,preferred,status,creation,modification,country,fullname,authority,shortname'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'050: importing Eppo_GafName';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'GafName'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_GafNameStaging'
               ,@file            = 'Eppo_GafName.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,lang,langno,preferred,status,creation,modification,country,fullname,authority,shortname'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'060: importing Eppo_GaiGroup';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'GaiGroup'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_GaiGroupStaging'
               ,@file            = 'Eppo_GaiGroup.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,lang,langno,preferred,status,creation,modification,country,fullname,authority,shortname'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'070: importing Eppo_GafLink';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'EPPO_GafLink'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_GafLinkStaging'
               ,@file            = 'Eppo_GafLink.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,creation,modification,grp_dtype,grp_code'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'080: importing Eppo_GaiLink';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'GaiLink'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_GaiLinkStaging'
               ,@file            = 'Eppo_GaiLink.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,creation,modification,grp_dtype,grp_code'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'090: importing Eppo_GaiName';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'GaiName'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_GaiNameStaging'
               ,@file            = 'Eppo_GaiName.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,lang,langno,preferred,status,creation,modification,fullname,shortname'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'100: importing Eppo_NtxLink';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'NtxLink'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_NtxLinkStaging'
               ,@file            = 'Eppo_NtxLink.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,creation,modification,grp_dtype,grp_code'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'110: importing Eppo_NtxName';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'NtxName'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_NtxNameStaging'
               ,@file            = 'Eppo_NtxName.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,lang,langno,preferred,status,creation,modification,country,fullname,authority,shortname'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'120: importing Eppo_PflGroup';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'PflGroup'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_PflGroupStaging'
               ,@file            = 'Eppo_PflGroup.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,lang,langno,preferred,status,creation,modification,country,fullname,authority,shortname'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'130: importing Eppo_PflLink';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'PflLink'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_PflLinkStaging'
               ,@file            = 'Eppo_PflLink.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,creation,modification,grp_dtype,grp_code'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'140: importing Eppo_PflName';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'PflName'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_PflNameStaging'
               ,@file            = 'Eppo_PflName.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,lang,langno,preferred,status,creation,modification,country,fullname,authority,shortname'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

         EXEC sp_log 1, @fn,'150: importing Eppo_Repco';
         SELECT @exp_row_cnt = exp_row_cnt FROM @eppo WHERE [table] = 'Repco'
         EXEC sp_import_eppo_file_helper
                @table           = 'Eppo_RepcoStaging'
               ,@file            = 'Eppo_Repco.txt'
               ,@field_terminator= @field_terminator
               ,@non_null_flds   = 'identifier,datatype,code,statuslink,creation,modification,grp_dtype,grp_code'
               ,@folder          = @folder
               ,@display_table   = @display_tables
               ,@exp_row_cnt     = @exp_row_cnt
               ,@row_cnt         = @row_cnt OUT
               ;

            -------------------------------------------------------------------------------------------
         -- 04: Check postconditions
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'160: validating postconditions';
         -- POST 01: all epp tables populated
         EXEC sp_assert_tbl_pop 'EPPO_gafgroupStaging';
         EXEC sp_assert_tbl_pop 'EPPO_gaflinkStaging';
         EXEC sp_assert_tbl_pop 'EPPO_gafnameStaging';
         EXEC sp_assert_tbl_pop 'EPPO_gaigroupStaging';
         EXEC sp_assert_tbl_pop 'EPPO_gailinkStaging';
         EXEC sp_assert_tbl_pop 'EPPO_gainameStaging';
         EXEC sp_assert_tbl_pop 'EPPO_ntxlinkStaging';
         EXEC sp_assert_tbl_pop 'EPPO_ntxnameStaging';
         EXEC sp_assert_tbl_pop 'EPPO_pflgroupStaging';
         EXEC sp_assert_tbl_pop 'EPPO_pfllinkStaging';
         EXEC sp_assert_tbl_pop 'EPPO_pflnameStaging';
         EXEC sp_assert_tbl_pop 'EPPO_repcoStaging';

            -------------------------------------------------------------------------------------------
         -- 05: Process complete
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'900: process complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, ' 550: ';
      THROW;
   END CATCH

   EXEC sp_log 2, @fn,'999: leaving:';
END
/*
exec sp_import_eppo_files 'D:\Dev\Farming\Data\EPPO.bayer';

EXEC tSQLt.Run 'test.test_021_sp_import_eppo';
SELECT * FROM gailinkStaging;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==========================================================================================
-- Author:      Terry watts=
-- Create date: 13-NOV-2024
-- Description: fixes up the creation and modification dates
--              in the Eppo staging tables
--
-- RESPONSIBILITIES:
-- R01: Puts dates in the right format to implicitly import into tables
-- R02: if a group or name type table then filter out rows with unwanted languages
--
-- POSTCONDITIONS: (self checked)
-- POST01: dates are in the right format or (error msg logged and return error code 1) OR
-- POST02: if group or name table then  unwanted languages filtered out or returm error code 1
--         and error msg logged  OR
-- POST03: if successful return 0
-- ===========================================================================================
CREATE   PROCEDURE [dbo].[sp_eppo_fixup_stgng_dates]
   @table VARCHAR(60)
AS
BEGIN
   SET NOCOUNT OFF;

   DECLARE
       @fn  VARCHAR(35)   = 'sp_eppo_fixup_stgng_dates'
      ,@sql NVARCHAR(4000)
      ,@nl  VARCHAR(2)    = NCHAR(13) + NCHAR(10)
      ,@cnt INT
      ,@rc  INT = 1 -- default: error state
   ;

   EXEC sp_log 1, @fn,'000: starting, @@trancount: ', @@trancount, '  @table: [',@table,']';

   BEGIN TRY
      BEGIN TRANSACTION;

      WHILE 1 = 1
      BEGIN
         --------------------------------------------------------------------------------
         -- R01: Puts dates in the right format to implicitly import into tables
         --------------------------------------------------------------------------------
         SET @sql =
         CONCAT
         (
            'UPDATE [', @table, N'] SET', @nl
            ,' creation     = CONCAT(SUBSTRING(creation,7,4), ''-'', SUBSTRING(creation, 4, 2), ''-'', SUBSTRING(creation, 1, 2)) ',@nl
            ,',modification = iif(modification = '''', modification, CONCAT(SUBSTRING(modification,7,4), ''-'', SUBSTRING(modification, 4, 2), ''-'', SUBSTRING(modification, 1, 2)))
            WHERE TRY_CONVERT(DATE, creation) IS NULL OR TRY_CONVERT(DATE, modification) IS NULL;'
         );

         EXEC sp_log 1, @fn,'010: SQL;', @nl, @sql;
         EXEC(@sql);
         SET @cnt = @@ROWCOUNT;
         EXEC sp_log 1, @fn,'020: updated ', @cnt,' rows';

         SET @cnt = 0;
         SET @sql =
         CONCAT
         (
            'SELECT @cnt = COUNT(*) FROM [', @table,']', @nl
            ,'WHERE TRY_CONVERT(DATE, creation) IS NULL OR TRY_CONVERT(DATE, modification) IS NULL;'
         );

         EXEC sp_log 1, @fn,'030: about to run date conversion check SQL'; --, @nl, @sql;
         EXEC sp_executesql @sql, N'@cnt INT OUT', @cnt OUT;

         IF @cnt > 0
         BEGIN
            EXEC sp_log 4, @fn, '040: ',@cnt,' dates still exist with the wrong format in ', @table, ' after fixup, so rolling back the fixup txn';
            SET @sql =
            CONCAT
            (
               'SELECT * FROM [', @table,']', @nl
               ,'WHERE TRY_CONVERT(DATE, creation) IS NULL OR TRY_CONVERT(DATE, modification) IS NULL;'
            );

            EXEC(@sql);

            ROLLBACK TRANSACTION;
            BREAK;
         END

         ------------------------------------------------------
         -- ASSERTION first job (responsibility R01) completed
         ------------------------------------------------------

         -----------------------------------------------------------------------------------
         -- R02: if a group or name type table then filter out rows with unwanted languages
         -----------------------------------------------------------------------------------
         IF @table LIKE '%Group' OR @table LIKE '%Name'
         BEGIN
            EXEC sp_log 1, @fn, '050: filtering out rows with unwanted languages';
            SET @sql = CONCAT('DELETE FROM [',@table,'] WHERE lang not in (''en'', ''la'')) ');
            EXEC(@sql);

            ---------------------------
            -- ASSERTION @cnt IS  NULL
            ---------------------------
            SET @sql = CONCAT('SELECT @cnt=1 FROM [',@table,'] WHERE lang not in (''en'', ''la''))');
            EXEC sp_log 1, @fn,'060: about to run lang check SQL'; 
            EXEC sp_executesql @sql, N'@cnt INT OUT', @cnt OUT;

            IF @cnt IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '070: language other (en or la) still exists in ', @table, ' after fixup, so rolling back the fixup txn';
               ROLLBACK TRANSACTION;
               BREAK;
            END
         END -- R02

         --------------------------------------------------------
         -- ASSERTION second job (responsibility R02) completed
         -- so good to commit updates
         --------------------------------------------------------
         EXEC sp_log 1, @fn, '080: ', @table,' fixup successful';
         COMMIT TRANSACTION;
         SET @rc = 0; -- flag success
         BREAK;
      END -- while 1=1

      EXEC sp_log 1, @fn,'050: completed process';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, ' 550: caught exception, @@trancount: ', @@trancount, ' @sql:', @nl, @sql;
      ROLLBACK TRANSACTION;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn,'999: leaving, ret: ',@rc;
END
/*
EXEC sp_eppo_fixup_stgng_dates 'EPPO_GafGroupStaging';

EXEC tSQLt.Run 'test.test_023_sp_eppo_fixup_stgng_dates';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GafGroupStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[lang] [varchar](max) NULL,
	[langno] [varchar](max) NULL,
	[preferred] [varchar](max) NULL,
	[status] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[country] [varchar](max) NULL,
	[fullname] [varchar](max) NULL,
	[authority] [varchar](max) NULL,
	[shortname] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GafNameStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[lang] [varchar](max) NULL,
	[langno] [varchar](max) NULL,
	[preferred] [varchar](max) NULL,
	[status] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[country] [varchar](max) NULL,
	[fullname] [varchar](max) NULL,
	[authority] [varchar](max) NULL,
	[shortname] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

EXEC sys.sp_addextendedproperty @name=N'DESC', @value=N'micro-organisms, viruses, abiotic growth factors' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'EPPO_GafNameStaging'

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GaigroupStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[lang] [varchar](max) NULL,
	[langno] [varchar](max) NULL,
	[preferred] [varchar](max) NULL,
	[status] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[country] [varchar](max) NULL,
	[fullname] [varchar](max) NULL,
	[authority] [varchar](max) NULL,
	[shortname] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GaiNameStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[lang] [varchar](max) NULL,
	[langno] [varchar](max) NULL,
	[preferred] [varchar](max) NULL,
	[status] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[country] [varchar](max) NULL,
	[fullname] [varchar](max) NULL,
	[authority] [varchar](max) NULL,
	[shortname] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_NtxNameStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[lang] [varchar](max) NULL,
	[langno] [varchar](max) NULL,
	[preferred] [varchar](max) NULL,
	[status] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[country] [varchar](max) NULL,
	[fullname] [varchar](max) NULL,
	[authority] [varchar](max) NULL,
	[shortname] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_PflGroupStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[lang] [varchar](max) NULL,
	[langno] [varchar](max) NULL,
	[preferred] [varchar](max) NULL,
	[status] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[country] [varchar](max) NULL,
	[fullname] [varchar](max) NULL,
	[authority] [varchar](max) NULL,
	[shortname] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_PflNameStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[lang] [varchar](max) NULL,
	[langno] [varchar](max) NULL,
	[preferred] [varchar](max) NULL,
	[status] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[country] [varchar](max) NULL,
	[fullname] [varchar](max) NULL,
	[authority] [varchar](max) NULL,
	[shortname] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================================================
-- Author:      Terry Watts
-- Create date: 11-Nov-2024
-- Description: does any required fixup to the Staging tables
--              before merging to the main EPPO tables
--
-- RESPONSIBILITIES:
-- RO1: standardising dates ready to import and be implicitly convertible to DATE
-- R02: remove unwanted languages, only want english and latin applies toNaes and Groups
--
-- POSTCONDITIONS:
-- POST 01: all creation and modification fields should be implicitlyconvertible to DATE
-- POST 02: only langages are {en, la}
-- CALLED BY: sp_import_eppo
-- ======================================================================================
CREATE   PROCEDURE [dbo].[sp_import_eppo_fixup]
AS
BEGIN
   SET NOCOUNT OFF;
   DECLARE
    @fn           VARCHAR(35) = 'sp_import_eppo_fixup'

   EXEC sp_log 2, @fn,'000: starting:';
   BEGIN TRY
      EXEC sp_log 1, @fn,'010: starting process';

      ----------------------------------------------------------
      -- EPPO_GafGroupStaging
      ----------------------------------------------------------
      EXEC sp_log 1, @fn,'020: fixup GafGroupStaging';
      DELETE FROM EPPO_GafGroupStaging WHERE lang NOT IN ('en', 'la');

      -- 1 row has wrapping single quotes
      UPDATE EPPO_GafGroupStaging SET fullname = REPLACE(fullname, '''', '') WHERE fullname like '%''%'; -- 241114: 1 row
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_GafGroupStaging';

      ----------------------------------------------------------
      -- EPPO_GafLinkStaging
      ----------------------------------------------------------
      EXEC sp_log 1, @fn,'020: fixup EPPO_GafLinkStaging';
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_GafLinkStaging';

      ----------------------------------------------------------
      -- GEPPO_afNameStaging
      ----------------------------------------------------------
      EXEC sp_log 1, @fn,'030: fixup EPPO_GafNameStaging';
      DELETE FROM EPPO_GafNameStaging WHERE lang NOT IN ('en', 'la');
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_GafNameStaging';

      ----------------------------------------------------------
      -- EPPO_GaiGroupStaging
      ----------------------------------------------------------
      EXEC sp_log 1, @fn,'040: fixup EPPO_GaiGroupStaging';
      DELETE FROM EPPO_GaiGroupStaging WHERE lang NOT IN ('en', 'la');
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_GaiGroupStaging';

      ----------------------------------------------------------
      -- EPPO_GaiLinkStaging
      ----------------------------------------------------------
      EXEC sp_log 1, @fn,'050: fixup EPPO_GaiLinkStaging';
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_GaiLinkStaging';

      ----------------------------------------------------------
      -- EPPO_GaiNameStaging
      ----------------------------------------------------------
      EXEC sp_log 1, @fn,'060: fixup EPPO_GaiNameStaging';
      DELETE FROM EPPO_GaiNameStaging WHERE lang NOT IN ('en', 'la');
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_GaiNameStaging';

      ----------------------------------------------------------
      -- EPPO_NtxLinkStaging
      ----------------------------------------------------------
      EXEC sp_log 1, @fn,'070: fixup EPPO_NtxLinkStaging';
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_NtxLinkStaging';

      ----------------------------------
      -- EPPO_NtxNameStaging  --> NtxName
      ----------------------------------
      EXEC sp_log 1, @fn,'080: fixup EPPO_NtxNameStaging';
      DELETE FROM EPPO_NtxNameStaging WHERE lang NOT IN ('en', 'la');
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_NtxNameStaging';

      ----------------------------------
      -- EPPO_PflGroupStaging --> PflGroup
      ----------------------------------
      EXEC sp_log 1, @fn,'090: fixup EPPO_PflGroupStaging';
      DELETE FROM EPPO_PflGroupStaging WHERE lang NOT IN ('en', 'la');
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_PflGroupStaging';

      ----------------------------------
      -- EPPO_PflLinkStaging --> PflLink
      ----------------------------------
      EXEC sp_log 1, @fn,'100: fixup EPPO_PflLinkStaging';
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_PflLinkStaging';

      ----------------------------------
      -- EPPO_PflNameStaging --> PflName
      ----------------------------------
      EXEC sp_log 1, @fn,'110: fixup PflNameStaging';
      DELETE FROM EPPO_PflNameStaging WHERE lang NOT IN ('en', 'la');
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_PflNameStaging';

      ----------------------------------
      -- RepcoStaging    --> EPPO_Repco
      ----------------------------------
      EXEC sp_log 1, @fn,'120: fixup EPPO_RepcoStaging';
      EXEC sp_eppo_fixup_stgng_dates 'EPPO_RepcoStaging';

      ---------------------------------------------------------------
      -- Postcondition checks: delgated to sp_eppo_fixup_stgng_dates
      ---------------------------------------------------------------
      EXEC sp_log 1, @fn,'130: completed process';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn,'999: leaving:';
END
/*
EXEC sp_import_eppo_fixup;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GafGroup](
	[identifier] [varchar](10) NULL,
	[datatype] [varchar](5) NULL,
	[code] [varchar](8) NULL,
	[lang] [varchar](6) NULL,
	[langno] [int] NULL,
	[preferred] [bit] NULL,
	[status] [nchar](1) NULL,
	[creation] [varchar](10) NULL,
	[modification] [varchar](10) NULL,
	[country] [varchar](20) NULL,
	[fullname] [varchar](80) NULL,
	[authority] [varchar](50) NULL,
	[shortname] [varchar](80) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GafLink](
	[identifier] [nchar](10) NULL,
	[datatype] [nchar](10) NULL,
	[code] [nchar](2) NULL,
	[creation] [date] NULL,
	[modification] [nchar](15) NULL,
	[grp_dtype] [varchar](3) NULL,
	[grp_code] [varchar](6) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GafLinkStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[grp_dtype] [varchar](max) NULL,
	[grp_code] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GafName](
	[identifier] [varchar](7) NULL,
	[datatype] [varchar](3) NULL,
	[code] [varchar](8) NULL,
	[lang] [varchar](2) NULL,
	[langno] [varchar](2) NULL,
	[preferred] [nchar](1) NULL,
	[status] [nchar](1) NULL,
	[creation] [date] NULL,
	[modification] [varchar](10) NULL,
	[country] [varchar](2) NULL,
	[fullname] [varchar](150) NULL,
	[authority] [varchar](70) NULL,
	[shortname] [varchar](150) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GaiGroup](
	[identifier] [varchar](7) NULL,
	[datatype] [varchar](3) NULL,
	[code] [varchar](8) NULL,
	[lang] [varchar](2) NULL,
	[langno] [int] NULL,
	[preferred] [bit] NULL,
	[status] [nchar](1) NULL,
	[creation] [date] NULL,
	[modification] [varchar](10) NULL,
	[country] [varchar](2) NULL,
	[fullname] [varchar](60) NULL,
	[authority] [varchar](32) NULL,
	[shortname] [varchar](60) NOT NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GaiLink](
	[identifier] [varchar](7) NULL,
	[datatype] [varchar](6) NULL,
	[code] [nchar](1) NULL,
	[creation] [date] NULL,
	[modification] [varchar](10) NULL,
	[grp_dtype] [varchar](3) NULL,
	[grp_code] [varchar](6) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GaiLinkStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[grp_dtype] [varchar](max) NULL,
	[grp_code] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_GaiName](
	[identifier] [varchar](8) NULL,
	[datatype] [varchar](4) NULL,
	[code] [varchar](8) NULL,
	[lang] [varchar](2) NULL,
	[langno] [int] NULL,
	[preferred] [bit] NULL,
	[status] [nchar](1) NULL,
	[creation] [date] NULL,
	[modification] [varchar](10) NULL,
	[country] [varchar](2) NULL,
	[fullname] [varchar](192) NULL,
	[authority] [varchar](64) NULL,
	[shortname] [varchar](128) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_NtxLink](
	[identifier] [varchar](8) NULL,
	[datatype] [varchar](8) NULL,
	[code] [nchar](1) NULL,
	[creation] [date] NULL,
	[modification] [varchar](10) NULL,
	[grp_dtype] [varchar](4) NULL,
	[grp_code] [varchar](8) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_NtxLinkStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[grp_dtype] [varchar](max) NULL,
	[grp_code] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_Ntxname](
	[identifier] [varchar](8) NULL,
	[datatype] [varchar](4) NULL,
	[code] [varchar](8) NULL,
	[lang] [varchar](2) NULL,
	[langno] [int] NULL,
	[preferred] [bit] NULL,
	[status] [nchar](1) NULL,
	[creation] [date] NULL,
	[modification] [varchar](10) NULL,
	[country] [varchar](2) NULL,
	[fullname] [varchar](128) NULL,
	[authority] [varchar](64) NULL,
	[shortname] [varchar](64) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_PflGroup](
	[identifier] [varchar](8) NULL,
	[datatype] [varchar](4) NULL,
	[code] [varchar](8) NULL,
	[lang] [varchar](2) NULL,
	[langno] [int] NULL,
	[preferred] [bit] NULL,
	[status] [nchar](1) NULL,
	[creation] [date] NULL,
	[modification] [varchar](10) NULL,
	[country] [varchar](2) NULL,
	[fullname] [varchar](64) NULL,
	[authority] [varchar](64) NULL,
	[shortname] [varchar](64) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_PflLink](
	[identifier] [varchar](8) NULL,
	[datatype] [varchar](8) NULL,
	[code] [nchar](1) NULL,
	[creation] [date] NULL,
	[modification] [varchar](10) NULL,
	[grp_dtype] [varchar](8) NULL,
	[grp_code] [varchar](8) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_PflLinkStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[grp_dtype] [varchar](max) NULL,
	[grp_code] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_PflName](
	[identifier] [varchar](7) NULL,
	[datatype] [varchar](3) NULL,
	[code] [varchar](8) NULL,
	[lang] [varchar](2) NULL,
	[langno] [varchar](2) NULL,
	[preferred] [varchar](1) NULL,
	[status] [varchar](1) NULL,
	[creation] [date] NULL,
	[modification] [date] NULL,
	[country] [varchar](2) NULL,
	[fullname] [varchar](250) NULL,
	[authority] [varchar](120) NULL,
	[shortname] [varchar](250) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_Repco](
	[identifier] [varchar](5) NULL,
	[datatype] [varchar](3) NULL,
	[code] [varchar](8) NULL,
	[statuslink] [varchar](1) NULL,
	[creation] [date] NOT NULL,
	[modification] [date] NULL,
	[grp_dtype] [varchar](3) NULL,
	[grp_code] [varchar](6) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[EPPO_RepcoStaging](
	[identifier] [varchar](max) NULL,
	[datatype] [varchar](max) NULL,
	[code] [varchar](max) NULL,
	[statuslink] [varchar](max) NULL,
	[creation] [varchar](max) NULL,
	[modification] [varchar](max) NULL,
	[grp_dtype] [varchar](max) NULL,
	[grp_code] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =====================================================================
-- Author:      Terry Watts
-- Create date: 13-Nov-2024
-- Description: merges the EPPO staging tables to the main EPPO tables
--
-- Algorithm:
-- The merge map for the EPPO tables is as follows:
--     EPPO_gafgroupStaging --> EPPO_gafgroup
--    ,EPPO_gaflinkStaging  --> EPPO_gaflink
--    ,EPPO_gafnameStaging  --> EPPO_gafname
--    ,EPPO_gaigroupStaging --> EPPO_gaigroup
--    ,EPPO_gailinkStaging  --> EPPO_gailink
--    ,EPPO_gainameStaging  --> EPPO_gainame
--    ,EPPO_ntxlinkStaging  --> EPPO_ntxlink
--    ,EPPO_ntxnameStaging  --> EPPO_ntxname
--    ,EPPO_pflgroupStaging --> EPPO_pflgroup
--    ,EPPO_pfllink Staging --> EPPO_pfllink
--    ,EPPO_pflname Staging --> EPPO_pflname
--    ,EPPO_repcoStaging    --> EPPO_repco
--
-- PRECONDITIONS:
-- PRE 01:the following tables are populated: or exception 71500, <table not populated>
--     EPPO_gafgroupStaging
--    ,EPPO_gaflinkStaging
--    ,EPPO_gafnameStaging
--    ,EPPO_gaigroupStaging
--    ,EPPO_gailinkStaging 
--    ,EPPO_gainameStaging 
--    ,EPPO_ntxlinkStaging 
--    ,EPPO_ntxnameStaging 
--    ,EPPO_pflgroupStaging
--    ,EPPO_pfllink Staging
--    ,EPPO_pflname Staging
--    ,EPPO_repcoStaging

-- POSTCONDITIONS
-- POST01: the following tables are or exception 71501, <table not populated>
--      EPPO_gafgroup
--      EPPO_gaflink
--      EPPO_gafname
--      EPPO_gaigroup
--      EPPO_gailink
--      EPPO_gainame
--      EPPO_ntxlink
--      EPPO_ntxname
--      EPPO_pflgroup
--      EPPO_pfllink
--      EPPO_pflname
--      EPPO_repco
-- CALLED BY: sp_import_eppo
-- =====================================================================
CREATE PROCEDURE [dbo].[sp_import_eppo_merge]
   @display_table    BIT = 0
AS
BEGIN
   SET NOCOUNT OFF;
   DECLARE
    @fn           VARCHAR(35) = 'sp_import_eppo_merge'

   EXEC sp_log 1, @fn,'000: starting:';
   BEGIN TRY
      ----------------------------------------------
      -- Validate precondition 
      ----------------------------------------------
      EXEC sp_log 1, @fn,'010: validating preconditions';

      -- PRE 01:the following tables are populated: or exception 71500, <table not populated>
      EXEC sp_assert_tbl_pop 'EPPO_gafgroupStaging',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_gaflinkStaging ',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_gafnameStaging ',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_gaigroupStaging',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_gailinkStaging ',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_gainameStaging ',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_ntxlinkStaging ',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_ntxnameStaging ',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_pflgroupStaging',@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_pfllinkStaging' ,@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_pflnameStaging' ,@ex_num=71500, @ex_msg = 'pre cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_repcoStaging'   ,@ex_num=71500, @ex_msg = 'pre cndtn';

      ----------------------------------------------
      -- ASSERTION preconditions Validatated
      ----------------------------------------------
      EXEC sp_log 1, @fn,'020: ASSERTION preconditions Validatated';

      ----------------------------------------------
      -- 03: Process
      ----------------------------------------------
      EXEC sp_log 1, @fn,'030: starting process ';

      ----------------------------------
      -- GafGroupStaging --> GafGroup
         ----------------------------------
      EXEC sp_log 1, @fn,'040: merging GafGroup';
      DELETE FROM EPPO_GafGroup;

      MERGE EPPO_GafGroup as target
      USING
      (
         SELECT identifier, datatype, code, lang, langno, preferred, [status], creation, modification, country, fullname, authority, shortname
         FROM EPPO_GafGroupStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT ( identifier, datatype, code, lang, langno, preferred, [status], creation, modification, country, fullname, authority, shortname)
         VALUES ( identifier, datatype, code, lang, langno, preferred, [status], creation, modification, country, fullname, authority, shortname)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_GafGroup;

      ----------------------------------
--    GafLinkStaging --> GafLink
      ----------------------------------
      EXEC sp_log 1, @fn,'050: merging gaflink';

      DELETE FROM EPPO_GafLink;
      MERGE EPPO_GafLink as target
      USING
      (
         SELECT identifier, datatype, code, creation, modification, grp_dtype, grp_code
         FROM EPPO_GafLinkStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, creation, modification, grp_dtype, grp_code)
         VALUES (identifier, datatype, code, creation, modification, grp_dtype, grp_code)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_Gaflink;

      ----------------------------------
--    GafNameStaging  --> GafName
      ----------------------------------
      EXEC sp_log 1, @fn,'060: merging GafName';
      DELETE FROM EPPO_GafName;
      MERGE EPPO_GafName as target
      USING
      (
         SELECT identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname
         FROM EPPO_GafNameStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
         VALUES (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_GafName;

      ----------------------------------
--    GaiGroupStaging --> GaiGroup
      ----------------------------------
      EXEC sp_log 1, @fn,'070: merging GaiGroup';
      DELETE FROM EPPO_GaiGroup;
      MERGE EPPO_GaiGroup as target
      USING
      (
         SELECT identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname
         FROM EPPO_GaiGroupStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
         VALUES (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_Gaigroup;

      ----------------------------------
--    GaiLinkStaging --> GaiLink
      ----------------------------------
      EXEC sp_log 1, @fn,'080: merging GaiLink';
      DELETE FROM EPPO_GaiLink;

      MERGE EPPO_GaiLink as target
      USING
      (
         SELECT identifier, datatype, code, creation, modification
         FROM EPPO_GaiLinkStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, creation, modification)
         VALUES (identifier, datatype, code, creation, modification)
      ;

      SELECT TOP 200 * FROM EPPO_Gailink;

      ----------------------------------
--    GaiNameStaging --> GaiName
      ----------------------------------
      EXEC sp_log 1, @fn,'090: merging GaiName';
      DELETE FROM EPPO_GaiName;

      MERGE EPPO_GaiName as target
      USING
      (
         SELECT identifier, datatype, code, creation, modification
         FROM EPPO_GaiNameStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, creation, modification)
         VALUES (identifier, datatype, code, creation, modification)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_GaiName;

      ----------------------------------
--    NtxLinkStaging --> NtxLink
      ----------------------------------
      EXEC sp_log 1, @fn,'100: merging NtxLink';
      DELETE FROM EPPO_NtxLink;

      MERGE EPPO_NtxLink as target
      USING
      (
         SELECT identifier, datatype, code, creation, modification,grp_dtype,grp_code
         FROM EPPO_NtxLinkStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, creation, modification,grp_dtype,grp_code)
         VALUES (identifier, datatype, code, creation, modification,grp_dtype,grp_code)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_NtxLink;

      ----------------------------------
--    NtxNameStaging  --> NtxName
      ----------------------------------
      EXEC sp_log 1, @fn,'110: merging NtxName';
      DELETE FROM EPPO_NtxName;

      MERGE EPPO_NtxName as target
      USING
      (
         SELECT identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname
         FROM EPPO_NtxNameStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
         VALUES (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_NtxName;

      ----------------------------------
--    PflGroupStaging --> PflGroup
      ----------------------------------
      EXEC sp_log 1, @fn,'120: merging PflGroup';
      DELETE FROM EPPO_PflGroup;

      MERGE EPPO_PflGroup as target
      USING
      (
         SELECT identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname
         FROM EPPO_PflGroupStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
         VALUES (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_PflGroup;

      ----------------------------------
--    PflLinkStaging --> PflLink
      ----------------------------------
      EXEC sp_log 1, @fn,'130: merging PflLink';
      DELETE FROM EPPO_PflLink;

      MERGE EPPO_PflLink as target
      USING
      (
         SELECT identifier, datatype, code, creation, modification,grp_dtype,grp_code
         FROM EPPO_PflLinkStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, creation, modification,grp_dtype,grp_code)
         VALUES (identifier, datatype, code, creation, modification,grp_dtype,grp_code)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_PflLink;

      ----------------------------------
--    PflNameStaging --> PflName
      ----------------------------------
      EXEC sp_log 1, @fn,'140: merging PflName';
      DELETE FROM EPPO_PflName;

      MERGE EPPO_PflName as target
      USING
      (
         SELECT identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname
         FROM EPPO_PflNameStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
         VALUES (identifier, datatype, code, lang, langno,preferred,status,creation, modification,country,fullname,authority,shortname)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_PflName;

      ----------------------------------
--    RepcoStaging    --> Repco
      ----------------------------------
      EXEC sp_log 1, @fn,'150: merging Repco';
      DELETE FROM EPPO_Repco;

      MERGE EPPO_Repco as target
      USING
      (
         SELECT identifier, datatype, code, statuslink,creation, modification,grp_dtype,grp_code
         FROM EPPO_RepcoStaging
      ) AS S
      ON target.identifier = S.identifier
      WHEN NOT MATCHED BY target THEN
         INSERT (identifier, datatype, code, statuslink,creation, modification,grp_dtype,grp_code)
         VALUES (identifier, datatype, code, statuslink,creation, modification,grp_dtype,grp_code)
      ;

      IF @display_table =1 SELECT TOP 200 * FROM EPPO_Repco;

      -------------------------------------------------------------------------------------------
      -- 04: Check postconditions
      -------------------------------------------------------------------------------------------
      -- POST01: All tables populated
      EXEC sp_log 1, @fn,'160: validating postconditions'
      EXEC sp_assert_tbl_pop 'EPPO_GafGroup'       , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_GafLinkStaging' , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_GafNameStaging' , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_GaiGroupStaging', @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_GaiLinkStaging' , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_GaiNameStaging' , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_NtxLinkStaging' , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_NtxNameStaging' , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_PflGroupStaging', @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_PflLinkStaging' , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_PflNameStaging' , @ex_num=71501, @ex_msg = 'post cndtn';
      EXEC sp_assert_tbl_pop 'EPPO_RepcoStaging'   , @ex_num=71501, @ex_msg = 'post cndtn';

      -------------------------------------------------------------------------------------------
      -- 05: Process complete
      -------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'300: process complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, ' 550: ';
      THROW;
   END CATCH

   EXEC sp_log 2, @fn,'999: leaving:';
END
/*
EXEC tSQLt.Run 'test.test_006_sp_import_eppo_merge';

EXEC tSQLt.RunAll;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =====================================================================
-- Author:      Terry Watts
-- Create date: 13-Nov-2024
-- Description: Imports the group of eppo files
--
-- Algorithm
-- Import the eppo tables from the @folder folder. The list of eppo files is:
--    Eppo_Gafgroup, Eppo_Gaflink, Eppo_Gafname,
--    Eppo_Gaigroup, Eppo_Gailink, Eppo_Gainame,
--    Eppo_Ntxlink,  Eppo_Ntxname, Eppo_Pfllink,
--    Eppo_pflname,  Eppo_Repco
--
-- The associated file names are:
--    Eppo_Gafgroup.txt, Eppo_Gaflink.txt, Eppo_Gafname.txt,
--    Eppo_Gaigroup.txt, Eppo_Gailink.txt, Eppo_Gainame.txt,
--    Eppo_Ntxlink .txt, Eppo_Ntxname.txt, Eppo_Pfllink.txt,
--    Eppo_pflname .txt, Eppo_Repco.txt
--
-- STAGE 1: sp_import_eppo_files: these files are imported into their associated stagig files
-- STAGE 2: any fixup can be performed
-- STAGE 3: merge into the main EPPO tables convertig types as necessary
--
-- POSTCONDITIONS:
-- POST01: all eppo tables populated
-- =====================================================================
CREATE   PROCEDURE [dbo].[sp_import_eppo]
    @folder           VARCHAR(500) = NULL
   ,@field_terminator NCHAR(1)      = NULL
   ,@exp_cnts         VARCHAR(2000)= NULL
   ,@display_tables   BIT           = NULL

AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
    @fn           VARCHAR(35) = 'sp_import_eppo'
   ,@row_cnt      INT
   ,@exp_row_cnt  INT
   ,@table        VARCHAR(60)
   ,@eppo         Eppo
   ;

   -- Set defaults as necessary
   IF @folder           IS NULL SET @folder           = 'D:\Dev\Farming\Data\EPPO.bayer';
   IF @field_terminator IS NULL SET @field_terminator = ',';
   IF @display_tables   IS NULL SET @display_tables   = 0;

   EXEC sp_log 2, @fn,'000: starting:
folder:          [', @folder,   ']
field_terminator:[', @field_terminator, ']
exp_cnts        :[', @exp_cnts        , ']
display_tables  :[', @display_tables  , ']'
;

   BEGIN TRY
         -------------------------------------------------------------------------------------------
         -- 01: Validate parameters
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'010: validating parameters';

         -------------------------------------------------------------------------------------------
         -- 02: Initialise
         -------------------------------------------------------------------------------------------
          EXEC sp_log 1, @fn,'020: validating parameters';

           -------------------------------------------------------------------------------------------
         -- 03: Process
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'030: starting process';

         IF @exp_cnts IS NOT NULL
         BEGIN
            EXEC sp_log 2, @fn, '040: checking the expected row cnts   ';

            INSERT INTO @eppo(ordinal, [table], exp_row_cnt)
            SELECT ordinal, [table], exp_row_cnt
            FROM
            (
               SELECT ordinal, SUBSTRING(value, 1,CHARINDEX(':', value)-1) AS [table], SUBSTRING(value, CHARINDEX(':', value)+1, 900) AS [exp_row_cnt]
               FROM string_split(@exp_cnts, ',',1) as A
            ) X;

            SELECT * FROM @eppo;
         END

         -------------------------------------------------------------------------------------------
      -- STAGE 1: sp_import_eppo_files: these files are imported into their associated stagig files
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'050: STAGE 1: calling sp_import_eppo_files';

         EXEC sp_import_eppo_files
             @folder
            ,@field_terminator
            ,@exp_cnts
            ,@display_tables
            ;

         -------------------------------------------------------------------------------------------
      -- STAGE 2: any fixup can be performed
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'060: STAGE 2: any fixup can be performed';
         EXEC sp_import_eppo_fixup;

         -------------------------------------------------------------------------------------------
      -- STAGE 3: merge staging tables into the main EPPO tables converting types as necessary
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'070: STAGE 3: calling sp_import_eppo_merge';
         EXEC sp_import_eppo_merge @display_table = @display_tables;

            -------------------------------------------------------------------------------------------
         -- 04: Check postconditions
         -------------------------------------------------------------------------------------------
            -- POST01: all eppo tables populated
--    Eppo_Gafgroup, Eppo_Gaflink, Eppo_Gafname,
--    Eppo_Gaigroup, Eppo_Gailink, Eppo_Gainame,
--    Eppo_Ntxlink,  Eppo_Ntxname, 
--    Eppo_Pfllink,  Eppo_pflname,  Eppo_Repco
         EXEC sp_log 1, @fn,'300 checking postconditions';
         EXEC sp_assert_tbl_populated 'EPPO_gafgroup';
         EXEC sp_assert_tbl_populated 'EPPO_gaflink';
         EXEC sp_assert_tbl_populated 'EPPO_gafname';
         EXEC sp_assert_tbl_populated 'EPPO_Gaigroup';
         EXEC sp_assert_tbl_populated 'Eppo_Gailink';
         EXEC sp_assert_tbl_populated 'Eppo_Gainame';
         EXEC sp_assert_tbl_populated 'EPPO_ntxlink';
         EXEC sp_assert_tbl_populated 'Eppo_Ntxname';
         EXEC sp_assert_tbl_populated 'EPPO_pflgroup';
         EXEC sp_assert_tbl_populated 'EPPO_pfllink';
         EXEC sp_assert_tbl_populated 'EPPO_pflname';
         EXEC sp_assert_tbl_populated 'EPPO_repco';

            -------------------------------------------------------------------------------------------
         -- 05: Process complete
         -------------------------------------------------------------------------------------------
         EXEC sp_log 1, @fn,'400: process complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, ' 550: ';
      THROW;
   END CATCH

   EXEC sp_log 2, @fn,'999: leaving:';
END
/*
EXEC tSQLt.Run 'test.test_021_sp_import_eppo';
SELECT * FROM gailinkStaging;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[FertHandler](
	[region] [varchar](5) NOT NULL,
	[company_nm] [varchar](80) NOT NULL,
	[address] [varchar](100) NOT NULL,
	[type] [varchar](15) NOT NULL,
	[license] [varchar](25) NOT NULL,
	[expiry_date] [date] NOT NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[FertHandlerStaging](
	[region] [varchar](max) NULL,
	[company_nm] [varchar](max) NULL,
	[address] [varchar](max) NULL,
	[type] [varchar](max) NULL,
	[license] [varchar](max) NULL,
	[expiry_date] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==============================================================================
-- Author:      Terry Watts
-- Create date: 05-NOV-2024
-- Description: Imports the Pg Gov Ag LRAP Fert handlers tsv file
--     into FertHandlerStaging then does fixup before copying to FertHandler.
-- PRECONDITIONS:
-- PRE01: none
--
-- POSTCONDITIONS:
-- POST01: FertHandler table must have rows
-- POST02: no double quotes exists in any column
-- POST03: no leaading/trailing wsp exists in any column
--
-- BCP create (DOS_:
-- bcp Farming_dev.dbo.cropstaging format nul -c -T -f FertHandler.fmt
--
-- TESTS:
--
-- CHANGES:
-- ==============================================================================
CREATE PROCEDURE [dbo].[sp_import_Fert_Handlers]
    @file           VARCHAR(500)
   ,@folder         VARCHAR(600) = NULL
   ,@display_tables BIT          = 0
AS
BEGIN
   DECLARE
       @fn                 VARCHAR(35)   = N'import_Fert_Handlers'
      ,@bkslsh             CHAR(1)       = CHAR(92)
      ,@sql                VARCHAR(MAX)
      ,@cmd                VARCHAR(MAX)
      ,@error_file         VARCHAR(400)  = NULL
      ,@error_msg          VARCHAR(MAX)  = NULL
      ,@table_nm           VARCHAR(35)   = 'Distributor'
      ,@rc                 INT            = -1
      ,@import_root        VARCHAR(MAX)  
      ,@pathogen_row_cnt   INT            = -1
      ,@update_row_cnt     INT            = -1
      ,@null_type_row_cnt  INT            = -1
      ;

   SET NOCOUNT OFF
   BEGIN TRY
      EXEC sp_log 1, @fn, '000: starting:
file  :[', @file  ,']
folder:[', @folder,']
';

      ---------------------------------------
      -- Validate inputs
      ---------------------------------------
      IF @folder IS NOT NULL
         SET @file = CONCAT(@folder, @bkslsh, @file);

      ---------------------------------------
      -- Setup
      ---------------------------------------

      ---------------------------------------
      -- Process
      ---------------------------------------
      EXEC sp_log 1, @fn, '010: calling sp_bulk_import_tsv2';
      EXEC sp_import_txt_file
         @table      = 'FertHandlerStaging'
        ,@file       = @file
        ,@clr_first  = 1
        ;

      ---------------------------------------
      -- Do any fixup
      ---------------------------------------
      EXEC sp_log 1, @fn, '020: performing fixup = currently none';

      ---------------------------------------
      -- Copy to main table
      ---------------------------------------
      EXEC sp_log 1, @fn, '030: Clean copy to FertHandler main table';
      DELETE FROM FertHandler;

      INSERT INTO FertHandler
      (
          [region]
         ,[company_nm]
         ,[address]
         ,[type]
         ,[license]
         ,[expiry_date]
      )
      SELECT 
          [region]
         ,[company_nm]
         ,[address]
         ,[type]
         ,[license]
         ,[expiry_date]
      FROM FertHandlerStaging
      ;

      ---------------------------------------
      -- Postcondition checks
      ---------------------------------------
      EXEC sp_log 1, @fn, '040: Performing postcondition checks';
      EXEC sp_assert_tbl_pop 'FertHandler';

      ---------------------------------------
      -- Completed processing OK
      ---------------------------------------

      SET @rc = 0; -- OK
      IF @display_tables = 1 SELECT * FROM FertHandler;
      EXEC sp_log 1, @fn, '300:completed import and fixup'
   END TRY
   BEGIN CATCH
      SET @error_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '500: Caught exception: ', @error_msg;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '996: leaving, RC: ', @rc
   RETURN @RC;
END
/*
EXEC sp_import_Fert_Handlers 'D:\Dev\Farming\Data\Fert-Handlers-20240930.txt', 1;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[MosaicVirus](
	[Species] [varchar](60) NULL,
	[Crops] [varchar](40) NULL,
	[Genus] [varchar](35) NULL,
	[Subfamily] [varchar](35) NULL,
	[Family] [varchar](35) NULL,
	[Order] [varchar](35) NULL,
	[Class] [varchar](35) NULL,
	[Subphylum] [varchar](35) NULL,
	[Phylum] [varchar](35) NULL,
	[Kingdom] [varchar](35) NULL,
	[Realm] [varchar](35) NULL,
	[Genome] [varchar](35) NULL,
	[Vector] [varchar](35) NULL,
	[OPPO_code] [varchar](16) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[MosaicVirusStaging](
	[Species] [varchar](max) NULL,
	[Crops] [varchar](max) NULL,
	[Genus] [varchar](max) NULL,
	[Subfamily] [varchar](max) NULL,
	[Family] [varchar](max) NULL,
	[Order] [varchar](max) NULL,
	[Class] [varchar](max) NULL,
	[Subphylum] [varchar](max) NULL,
	[Phylum] [varchar](max) NULL,
	[Kingdom] [varchar](max) NULL,
	[Realm] [varchar](max) NULL,
	[Genome] [varchar](max) NULL,
	[Vector] [varchar](max) NULL,
	[OPPO_code] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==========================================================================================================
-- Author:      Terry Watts
-- Create date: 20-OCT-2024
-- Description:
--
-- PRECONDITIONS:
-- PRE01: none
--
-- POSTCONDITIONS:
-- POST01: MosaicVirus table must have rows
-- POST02: no double quotes exists in any column
-- POST03: no leaading/trailing wsp exists in any column
--
-- BCP create (DOS_:
-- bcp Farming_dev.dbo.cropstaging format nul -c -T -f CropStaging.fmt
--
-- TESTS:
--
-- CHANGES:
-- ==========================================================================================================
CREATE PROCEDURE [dbo].[sp_import_MosaicVirus]
    @file     VARCHAR(500)
   ,@folder         VARCHAR(600) = NULL
   ,@display_tables BIT          = 0
AS
BEGIN
   DECLARE
       @fn                 VARCHAR(35)   = N'IMPRT_MosaicVirus'
      ,@bkslsh             CHAR(1)       = CHAR(92)
      ,@sql                VARCHAR(MAX)
      ,@cmd                VARCHAR(MAX)
      ,@error_file         VARCHAR(400)  = NULL
      ,@error_msg          VARCHAR(MAX)  = NULL
      ,@table_nm           VARCHAR(35)   = 'Distributor'
      ,@rc                 INT            = -1
      ,@import_root        VARCHAR(MAX)
      ,@pathogen_row_cnt   INT            = -1
      ,@update_row_cnt     INT            = -1
      ,@null_type_row_cnt  INT            = -1
      ;

   SET NOCOUNT OFF
   BEGIN TRY
      EXEC sp_log 1, @fn, '000: starting:
file          :[', @file  ,']
folder        :[', @folder,']
display_tables:[', @display_tables,']
';

      ---------------------------------------
      -- Validate inputs
      ---------------------------------------
      IF @folder IS NOT NULL
         SET @file = CONCAT(@folder, @bkslsh, @file);

      ---------------------------------------                          
      -- Process
      ---------------------------------------                          
      EXEC sp_log 1, @fn, '010: clearing Distributor table';

      EXEC sp_log 1, @fn, '020: calling sp_bulk_import_tsv2';
      EXEC sp_import_txt_file
          @table         = 'MosaicVirusStaging'
         ,@view          = NULL
         ,@file          = @file
         ,@format_file   = NULL
         ,@expect_rows   = NULL
         ,@non_null_flds = 'species,crops,Genus,Family,Order,Class,Kingdom,Realm,Genome'
        ;

      ---------------------------------------                          
      -- Do any extra fixup not performed by sp_import_txt_file
      ---------------------------------------                          
      EXEC sp_log 1, @fn, '030: Do any extra fixup not performed by sp_import_txt_file';

      ----------------------------------------------------------------------------------
      -- Clean copy staging -> Main
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '040: clean copy to MosaicVirus';
      DELETE FROM MosaicVirus;

      INSERT INTO MosaicVirus
      (
          [Species]
         ,[Crops]
         ,[Genus]
         ,[Subfamily]
         ,[Family]
         ,[Order]
         ,[Class]
         ,[Subphylum]
         ,[Phylum]
         ,[Kingdom]
         ,[Realm]
         ,[Genome]
         ,[Vector]
         ,[OPPO_code]
      )
      SELECT Species, Crops, Genus, Subfamily, Family, [Order], Class, Subphylum, Phylum, Kingdom, Realm, Genome, Vector, OPPO_code
      FROM MosaicVirusStaging
      ;

      ----------------------------------------------------------------------------------
      -- Postcondition checks
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '050:performing postcondition checks'
      EXEC sp_assert_tbl_pop MosaicVirus;

      ----------------------------------------------------------------------------------
      -- Completed processing OK
      ----------------------------------------------------------------------------------

      IF @display_tables = 1 SELECT * FROM MosaicVirus;
      SET @rc = 0; -- OK
      EXEC sp_log 1, @fn, '95:completed import and fixup OK'
   END TRY
   BEGIN CATCH
      SET @error_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '50: Caught exception: ', @error_msg;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '99: leaving, RC: ', @rc
   RETURN @RC;
END
/*
EXEC sp_import_MosaicVirus 'D:\Dev\Farming\Data\MosaicViruses.txt', 1;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[PestHandler](
	[id] [int] NOT NULL,
	[region] [varchar](50) NOT NULL,
	[province] [varchar](50) NOT NULL,
	[city] [varchar](50) NOT NULL,
	[address] [varchar](250) NOT NULL,
	[company_nm] [varchar](50) NOT NULL,
	[owner] [varchar](50) NULL,
	[activity] [varchar](50) NOT NULL,
	[type] [varchar](50) NOT NULL,
	[license_app_ty] [varchar](50) NOT NULL,
	[expiry] [date] NOT NULL,
	[license_num] [varchar](50) NOT NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[PestHandlerStaging](
	[id] [int] NULL,
	[region] [varchar](50) NULL,
	[province] [varchar](50) NULL,
	[city] [varchar](50) NULL,
	[address] [varchar](250) NULL,
	[company_nm] [varchar](50) NULL,
	[owner] [varchar](50) NULL,
	[activity] [varchar](50) NULL,
	[type] [varchar](50) NULL,
	[license_app_ty] [varchar](50) NULL,
	[expiry] [varchar](50) NULL,
	[license_num] [varchar](50) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==========================================================================================================
-- Author:      Terry Watts
-- Create date: 05-NOV-2024
-- Description: Imports the Pg Gov Ag LRAP Pest handlers tsv file
--
-- PRECONDITIONS:
-- PRE01: none
--
-- POSTCONDITIONS:
-- POST01: PestHandler table must have rows
-- POST02: no double quotes exists in any column
-- POST03: no leading/trailing wsp exists in any column
--
-- BCP create (DOS_:
-- bcp Farming_dev.dbo.cropstaging format nul -c -T -f FertHandler.fmt
--
-- TESTS:
--
-- CHANGES:
-- ==========================================================================================================
CREATE PROCEDURE [dbo].[sp_import_PestHandlers]
    @file            VARCHAR(500)
   ,@folder          VARCHAR(600) = NULL
   ,@display_tables  BIT          = 0
AS
BEGIN
   DECLARE
    @fn                 VARCHAR(35)    = N'import_Pest_Handlers'
   ,@sql                VARCHAR(MAX)
   ,@bkslsh             CHAR(1)       = CHAR(92)
   ,@cmd                VARCHAR(MAX)
   ,@error_file         VARCHAR(400)   = NULL
   ,@error_msg          VARCHAR(MAX)   = NULL
   ,@table_nm           VARCHAR(35)    = 'Distributor'
   ,@rc                 INT            = -1
   ,@import_root        VARCHAR(MAX)
   ,@pathogen_row_cnt   INT            = -1
   ,@update_row_cnt     INT            = -1
   ,@null_type_row_cnt  INT            = -1
   ;

   SET NOCOUNT OFF
   BEGIN TRY
      EXEC sp_log 1, @fn, '000: starting:
file          :[', @file  ,']
folder        :[', @folder,']
display_tables:[', @display_tables,']
';

      ---------------------------------------
      -- Validate inputs
      ---------------------------------------
      IF @folder IS NOT NULL
         SET @file = CONCAT(@folder, @bkslsh, @file);

      ----------------------------------------------------------------------------------
      -- Process
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '010: calling sp_bulk_import_tsv2';

      EXEC sp_import_txt_file -- sp_import_tsv
          @table         = PestHandlerStaging
         ,@view          = NULL
         ,@file          = @file
         ,@format_file   = NULL
         ,@non_null_flds = 'id,region,province,city,address,company_nm,activity,type,license_app_ty,expiry,license_num'
        ;

      ----------------------------------------------------------------------------------
      -- Do any fixup
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020:Fixup: none currently';

      ----------------------------------------------------------------------------------
      -- Copy to main
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030:copy to main';
      DELETE FROM PestHandler;
      INSERT INTO PestHandler
      (
         [id]
         ,[region]
         ,[province]
         ,[city]
         ,[address]
         ,[company_nm]
         ,[owner]
         ,[activity]
         ,[type]
         ,[license_app_ty]
         ,[expiry]
         ,[license_num]
      )
      SELECT 
         [id]
         ,[region]
         ,[province]
         ,[city]
         ,[address]
         ,[company_nm]
         ,[owner]
         ,[activity]
         ,[type]
         ,[license_app_ty]
         ,CONVERT(DATE,[expiry])
         ,[license_num]
      FROM PestHandlerStaging;

      IF @display_tables = 1
         SELECT * FROM PestHandler;

      ----------------------------------------------------------------------------------
      -- Chk postconditions
      ----------------------------------------------------------------------------------
      EXEC sp_assert_tbl_pop 'PestHandler';
      ----------------------------------------------------------------------------------
      -- Completed processing OK
      ----------------------------------------------------------------------------------
      SET @rc = 0; -- OK
      EXEC sp_log 1, @fn, '499:completed import and fixup OK'
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, @ex_msg = @error_msg OUT;
      EXEC sp_log 4, @fn, '500: Caught exception: ', @error_msg;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving, RC: ', @rc
   RETURN @RC;
END
/*
EXEC sp_import_Pest_Handlers 'Pest-Handlers-May-10-2023.txt', 'D:\dev\farming\data';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Warehouse](
	[region] [varchar](50) NOT NULL,
	[company_nm] [varchar](50) NOT NULL,
	[warehouse_nm] [varchar](50) NOT NULL,
	[address] [varchar](250) NOT NULL,
	[type] [varchar](50) NOT NULL,
	[expiry] [date] NOT NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[WarehouseStaging](
	[region] [varchar](50) NULL,
	[company_nm] [varchar](50) NULL,
	[warehouse_nm] [varchar](50) NULL,
	[address] [varchar](250) NULL,
	[type] [varchar](50) NULL,
	[expiry] [varchar](50) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==========================================================================================================
-- Author:      Terry Watts
-- Create date: 05-NOV-2024
-- Description: Imports the Pg Gov Ag LRAP Fert-Warehouse handlers tsv file
--
-- Fixup:
------------------------------------------------------------------------------
-- column   fixup
------------------------------------------------------------------------------
-- expiry   converts text date to date 
-- type     converts Both Fertilizer & Pesticide to Fertilizer,Pesticide
------------------------------------------------------------------------------
--
-- PRECONDITIONS:
-- PRE01: none
--
-- POSTCONDITIONS:
-- POST01: WareHouse table must have rows
-- POST02: no double quotes exists in any column
-- POST03: no leaading/trailing wsp exists in any column
--
-- TESTS:
--
-- CHANGES:
-- ==========================================================================================================
CREATE   PROCEDURE [dbo].[sp_import_WareHouse]
    @file           VARCHAR(500)
   ,@folder         VARCHAR(600) = NULL
   ,@display_tables BIT = 0
AS
BEGIN
   DECLARE
       @fn                 VARCHAR(35)   = N'import_WareHouse'
      ,@bkslsh             CHAR(1)       = CHAR(92)
      ,@sql                VARCHAR(MAX)
      ,@cmd                VARCHAR(MAX)
      ,@error_file         VARCHAR(400)  = NULL
      ,@error_msg          VARCHAR(MAX)  = NULL
      ,@table_nm           VARCHAR(35)   = 'Distributor'
      ,@rc                 INT            = -1
      ,@import_root        VARCHAR(MAX)  
      ,@pathogen_row_cnt   INT            = -1
      ,@update_row_cnt     INT            = -1
      ,@null_type_row_cnt  INT            = -1
      ;

   SET NOCOUNT OFF
   BEGIN TRY
      EXEC sp_log 1, @fn, '000: starting:
file  :[', @file  ,']
folder:[', @folder,']
';

      ---------------------------------------
      -- Validate inputs
      ---------------------------------------
      IF @folder IS NOT NULL
         SET @file = CONCAT(@folder, @bkslsh, @file);

      ----------------------------------------------------------------------------------
      -- Process
      ----------------------------------------------------------------------------------

      EXEC sp_log 1, @fn, '020: calling sp_bulk_import_tsv2';
      EXEC sp_import_txt_file
          @table        ='WarehouseStaging'
         ,@file         = @file
         ,@non_null_flds='region,company_nm,warehouse_nm,address,type,expiry'
         ;

      ----------------------------------------------------------------------------------
      -- Do any fixup
      ----------------------------------------------------------------------------------

      ----------------------------------------------------------------------------------
      -- Copy WarehouseStaging to main Warehouse table with fixup
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: Copy WarehouseStaging to main Warehouse table with fixup';
      DELETE FROM Warehouse;
      INSERT INTO Warehouse 
      (
          [region]
         ,[company_nm]
         ,[warehouse_nm]
         ,[address]
         ,[type]
         ,[expiry]
      )
      SELECT 
          tpc.dbo.NormaliseRegionShortName([region])
         ,[company_nm]
         ,[warehouse_nm]
         ,[address]
         ,iif([type]='Both Fertilizer & Pesticide', 'Fertilizer,Pesticide', [type])
         ,CONVERT(DATE,[expiry])
      FROM WarehouseStaging;

      IF @display_tables = 1 SELECT * FROM Warehouse;

      ----------------------------------------------------------------------------------
      -- Completed processing OK
      ----------------------------------------------------------------------------------
      SET @rc = 0; -- OK
      EXEC sp_log 1, @fn, '800: completed import and fixup OK'
   END TRY
   BEGIN CATCH
      SET @error_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '500: Caught exception: ', @error_msg;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving, RC: ', @rc
   RETURN @RC;
END
/*
EXEC sp_import_WareHouse 'D:\Dev\Farming\Data\Fert-Warehouse-20231231.txt';
SELECT * from Warehouse;
SELECT distinct [type] from Warehouse;
SELECT distinct [region] from Warehouse order by region;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================================================================================================
-- Author:      Terry watts
-- Create date: 02-NOV-2024
-- Description: imports the system data staging tables
--
-- Responsibilities:
-- ActionStaging           -- 1
-- ChemicalStaging         -- 2
-- CompanyStaging          -- 3
-- CropStaging             -- 4
-- CropPathogenStaging     -- 5
-- DistributorStaging      -- 6
-- FertHandler             -- 7
-- MosaicVirusStaging      -- 8
-- PathogenTypeStaging     -- 9
-- PathogenStaging         -- 10
-- PestHandlerStaging      -- 11
-- UseStaging              -- 12
-- WareHouse               -- 13
-- 
-- Preconditions:
-- PRE 01: import_root must be specified
-- =========================================================================================
CREATE PROCEDURE [dbo].[sp_import_static_data_staging]
    @import_root     VARCHAR(500)
   ,@display_tables  BIT         = 0
AS
BEGIN
   DECLARE
       @fn           VARCHAR(35) = N'import_static_data_staging'
      ,@file_path    VARCHAR(600)

   SET NOCOUNT ON;  -- default: 'D:\Dev\Farming\Data'

   BEGIN TRY
      EXEC sp_log 1, @fn,'000: starting
@import_root   :[',@import_root, ']
@display_tables:[',@display_tables,']
';

   -- PRE 01: import_root specified
      EXEC sp_assert_not_null_or_empty @import_root, 'PRE 01: @import_root must be specified';

      --------------------------------------------------------------------------------------------
      -- 1. Import the ActionStaging table
      --------------------------------------------------------------------------------------------
      EXEC dbo.sp_import_txt_file
          @table        = 'ActionStaging'
         ,@file         = 'Actions.txt'
         ,@folder       = @import_root
         ,@non_null_flds= ' action_id,action_nm '
         ,@display_table= @display_tables
         ;

      --------------------------------------------------------------------------------------------
      -- 2. Import the ChemicalStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_import_txt_file
          @table        = 'ChemicalStaging'
         ,@file         = 'Chemical.txt'
         ,@folder       = @import_root
         ,@non_null_flds= 'chemical_nm'
         ,@display_table= @display_tables
         ;

      --------------------------------------------------------------------------------------------
      -- 3. Import the CompanyStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_import_txt_file
          @table        = 'CompanyStaging'
         ,@file         = 'Company.txt'
         ,@folder       = @import_root
         ,@non_null_flds= 'company_nm'
         ,@display_table= @display_tables
         ;

      --------------------------------------------------------------------------------------------
      -- 4. Import the CropStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_import_txt_file
          @table        = 'CropStaging'
         ,@file         = 'Crops.txt'
         ,@folder       = @import_root
         ,@non_null_flds= 'crop_nm'
         ,@display_table= @display_tables
         ;

      --------------------------------------------------------------------------------------------
      -- 5. Import the CropPathogenStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_import_txt_file
          @table        = 'CropPathogenStaging'
         ,@file         = 'CropPathogens.txt'
         ,@folder       = @import_root
         ,@non_null_flds= 'crop_nm,pathogen_nm'
         ,@display_table= @display_tables
         ;

  --------------------------------------------------------------------------------------------
      -- 6. Import the DistributorStaging table
      --------------------------------------------------------------------------------------------
      EXEC dbo.sp_import_txt_file
          @table        = 'DistributorStaging'
         ,@file         = 'Distributors.txt'
         ,@folder       = @import_root
         ,@non_null_flds= 'distributor_id,distributor_nm,region,province,address'
         ,@display_table= @display_tables
         ;

      --------------------------------------------------------------------------------------------
      -- 7. Import the FertHandlerStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_import_Fert_Handlers 'Fert-Handlers-20240930.txt' , @import_root, @display_tables = @display_tables;

      --------------------------------------------------------------------------------------------
      -- 8. Import the MosaicVirusStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_import_MosaicVirus
          @file          = 'MosaicViruses.txt'
         ,@folder        = @import_root
         ,@display_tables= @display_tables
         ;

      --------------------------------------------------------------------------------------------
      -- 9. Import the PathogenTypeStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'060: importing the PathogenTypeStaging table';
      EXEC dbo.sp_import_txt_file
          @table        = 'PathogenTypeStaging'
         ,@file         = 'PathogenType.txt'
         ,@folder       = @import_root
         ,@non_null_flds= 'pathogenType_id,pathogenType_nm'
         ,@display_table= @display_tables
        ;

      --------------------------------------------------------------------------------------------
      -- 10. Import the PathogenStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'070: Import the PathogenStaging table';
      EXEC dbo.sp_import_txt_file
          @table        = 'PathogenStaging'
         ,@file         = 'Pathogen.txt'
         ,@folder       = @import_root
         ,@first_row    = 3
         ,@non_null_flds= 'pathogen_nm,pathogenType_nm'
         ,@display_table= @display_tables
         ;

      --------------------------------------------------------------------------------------------
      -- 11. Import the PestHandler table satging and mn
      --------------------------------------------------------------------------------------------
      EXEC sp_import_PestHandlers
           @file          ='Pest-Handlers-May-10-2023.txt'
          ,@folder        = @import_root
          ,@display_tables= @display_tables
          ;

      --------------------------------------------------------------------------------------------
      -- 12. Import the UseStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'080: importing the UseStaging table';
      EXEC dbo.sp_import_txt_file
          @table        = 'UseStaging'
         ,@file         = 'use.txt'
         ,@folder       = @import_root
         ,@non_null_flds= 'use_id,use_nm'
         ,@display_table= @display_tables
         ;

      --------------------------------------------------------------------------------------------
      -- 13. Import the WareHouseStaging table
      --------------------------------------------------------------------------------------------
      EXEC sp_import_WareHouse     'Fert-Warehouse-20231231.txt', @import_root, @display_tables = @display_tables;

      --------------------------------------------------------------------------------------------
      -- Postcondition checks - chk only primary tables
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'600: Postcondition checks'; 
      EXEC sp_assert_tbl_pop 'ActionStaging';         -- 1
      EXEC sp_assert_tbl_pop 'ChemicalStaging';       -- 2
      EXEC sp_assert_tbl_pop 'CompanyStaging';        -- 3
      EXEC sp_assert_tbl_pop 'CropStaging';           -- 4
      EXEC sp_assert_tbl_pop 'CropPathogenStaging';   -- 5
      EXEC sp_assert_tbl_pop 'DistributorStaging';    -- 6
      EXEC sp_assert_tbl_pop 'FertHandlerStaging';    -- 7
      EXEC sp_assert_tbl_pop 'FertHandler';           -- 7
      EXEC sp_assert_tbl_pop 'MosaicVirusStaging';    -- 8
      EXEC sp_assert_tbl_pop 'PathogenTypeStaging';   -- 9
      EXEC sp_assert_tbl_pop 'PathogenStaging';       -- 10
      EXEC sp_assert_tbl_pop 'PestHandlerstaging';    -- 11
      EXEC sp_assert_tbl_pop 'PestHandler';           -- 11
      EXEC sp_assert_tbl_pop 'UseStaging';            -- 12
      EXEC sp_assert_tbl_pop 'Use';                   -- 12
      EXEC sp_assert_tbl_pop 'WareHouseStaging';      -- 13
      EXEC sp_assert_tbl_pop 'WareHouse';             -- 13

      --------------------------------------------------------------------------------------------
      -- Completed processing OK
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'800: Completed processing OK';

   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving OK';
END
/*
EXEC sp_import_static_data_staging 'D:\Dev\Farming\Data';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry watts
-- Create date: 02-NOV-2024
-- Description: imports the system data

-- RESPONSIBILITIES:
-- R02: clean import the following tables:
--    Import
--    TableDef
--    TableType
--    TypeStaging
-- =============================================
CREATE PROCEDURE [dbo].[sp_import_system_static_data]
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)  = N'import_system_static_data'

   SET NOCOUNT ON;

   BEGIN TRY
      EXEC sp_log 1, @fn,'000: starting';

      --------------------------------------------------------------------------------------------
      -- 1. Import the Import table SYSTEM data
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'010: importing the Import table';
      EXEC sp_import_txt_file
          @file            = 'D:\Dev\Farming\Data\Import.txt'
         ,@table           = 'Import'
         ,@clr_first       = 1
         ,@non_null_flds   = 'import_id,import_nm,description,new_fields,dropped_fields,error_count'
         ;

      /*--------------------------------------------------------------------------------------------
      -- 2. Import the ForeignKey table SYSTEM data
      --------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'020: importing the ForeignKes table';
      EXEC sp_import_ForeignKey_tsv 'D:\Dev\Farming\Data\ForeignKey.txt'--, 'Sheet1$'
      */

      --------------------------------------------------------------------------------------------
      -- 3. Import the TypeStaging table SYSTEM data
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'030: importing the TypeStaging table';
      EXEC dbo.sp_import_txt_file
          @file         = 'D:\Dev\Farming\Data\Type.txt'
         ,@table        = 'TypeStaging'
         ,@clr_first    = 1
         ,@expect_rows  = 1
         ,@non_null_flds= 'type_id,type_nm'
         ;

      --------------------------------------------------------------------------------------------
      -- 4. Import the TableType table SYSTEM data
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'040: importing the TableType table';
      EXEC sp_import_txt_file
          @file         = 'D:\Dev\Farming\Data\TableType.txt'
         ,@table        = 'TableType'
         ,@clr_first    = 1
         ,@expect_rows  = 1
         ,@non_null_flds= 'id,name'
         ;

      --------------------------------------------------------------------------------------------
      -- 5. Import the TableDef table SYSTEM data
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'050: import the TableDef table';
      EXEC sp_import_txt_file
          @file         = 'D:\Dev\Farming\Data\TableDef.txt'
         ,@table        = 'TableDef'
         ,@clr_first    = 1
         ,@expect_rows  = 1
         ,@non_null_flds= 'table_id,table_nm,table_type,sub_type'
         ;

      --------------------------------------------------------------------------------------------
      -- 14. Postcondition checks - chk only primary tables
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'170: Postcondition checks';
      EXEC sp_assert_tbl_pop 'Import';
      EXEC sp_assert_tbl_pop 'TypeStaging';
      EXEC sp_assert_tbl_pop 'TableDef';

      --------------------------------------------------------------------------------------------
      -- Completed processing OK
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'800: Completed processing OK';

   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving OK';
END
/*
EXEC sp_import_system_static_data;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Company](
	[company_id] [int] IDENTITY(1,1) NOT NULL,
	[company_nm] [varchar](100) NOT NULL,
	[company_type] [varchar](50) NULL,
 CONSTRAINT [PK_Company] PRIMARY KEY CLUSTERED 
(
	[company_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE UNIQUE NONCLUSTERED INDEX [IX_Company_name] ON [dbo].[Company]
(
	[company_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[CompanyStaging](
	[company_nm] [varchar](100) NOT NULL,
 CONSTRAINT [PK_CompanyStaging] PRIMARY KEY CLUSTERED 
(
	[company_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Chemical](
	[chemical_id] [int] IDENTITY(1,1) NOT NULL,
	[chemical_nm] [varchar](100) NOT NULL,
 CONSTRAINT [PK_Chemical] PRIMARY KEY CLUSTERED 
(
	[chemical_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Chemical_nm] UNIQUE NONCLUSTERED 
(
	[chemical_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Action](
	[action_id] [int] IDENTITY(1,1) NOT NULL,
	[action_nm] [varchar](50) NOT NULL,
 CONSTRAINT [PK_Action] PRIMARY KEY CLUSTERED 
(
	[action_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE UNIQUE NONCLUSTERED INDEX [UQ_Action_nm] ON [dbo].[Action]
(
	[action_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ActionStaging](
	[action_id] [int] NULL,
	[action_nm] [varchar](30) NULL,
 CONSTRAINT [UQ_ActionStaging_nm] UNIQUE NONCLUSTERED 
(
	[action_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[DistributorStaging](
	[distributor_id] [int] NOT NULL,
	[distributor_nm] [varchar](100) NULL,
	[city] [varchar](50) NULL,
	[province] [varchar](50) NULL,
	[region] [varchar](50) NULL,
	[address] [varchar](100) NULL,
	[phone 1] [varchar](20) NULL,
	[phone 2] [varchar](20) NULL,
	[manufacturers] [varchar](max) NULL,
 CONSTRAINT [PK_Distributorstaging] PRIMARY KEY CLUSTERED 
(
	[distributor_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[CropStaging](
	[crop_id] [int] NULL,
	[crop_nm] [varchar](100) NULL,
	[latin_nm] [varchar](50) NULL,
	[alt_latin_nms] [varchar](50) NULL,
	[alt_common_nms] [varchar](50) NULL,
	[taxonomy] [varchar](500) NULL,
	[notes] [varchar](150) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Distributor](
	[distributor_id] [int] IDENTITY(1,1) NOT NULL,
	[distributor_nm] [varchar](100) NULL,
	[city] [varchar](50) NULL,
	[province] [varchar](50) NULL,
	[region] [varchar](50) NULL,
	[address] [varchar](100) NULL,
	[phone 1] [varchar](50) NULL,
	[phone 2] [varchar](50) NULL,
	[maufacturers] [varchar](max) NULL,
 CONSTRAINT [PK_Distributor] PRIMARY KEY CLUSTERED 
(
	[distributor_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ChemicalStaging](
	[chemical_nm] [varchar](100) NOT NULL,
 CONSTRAINT [PK_ChemicalStaging] PRIMARY KEY CLUSTERED 
(
	[chemical_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_ChemicalStaging_nm] UNIQUE NONCLUSTERED 
(
	[chemical_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[PathogenStaging](
	[pathogen_nm] [varchar](50) NOT NULL,
	[pathogenType_nm] [varchar](50) NULL,
	[subtype] [varchar](25) NULL,
	[latin_nm] [varchar](120) NULL,
	[alt_latin_nms] [varchar](500) NULL,
	[alt_common_nms] [varchar](650) NULL,
	[ph_common_nms] [varchar](50) NULL,
	[crops] [varchar](2000) NULL,
	[taxonomy] [varchar](650) NULL,
	[biological_cure] [varchar](max) NULL,
	[notes] [varchar](3500) NULL,
	[urls] [varchar](250) NULL,
 CONSTRAINT [PK_PathogenStaging] PRIMARY KEY CLUSTERED 
(
	[pathogen_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[PathogenTypeStaging](
	[pathogenType_id] [int] NULL,
	[pathogenType_nm] [varchar](50) NULL,
 CONSTRAINT [UQ_PathogenTypeStaging] UNIQUE NONCLUSTERED 
(
	[pathogenType_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Type](
	[type_id] [int] IDENTITY(1,1) NOT NULL,
	[type_nm] [varchar](50) NOT NULL,
 CONSTRAINT [PK_Type] PRIMARY KEY CLUSTERED 
(
	[type_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Type] UNIQUE NONCLUSTERED 
(
	[type_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[TypeStaging](
	[type_id] [int] NULL,
	[type_nm] [varchar](50) NULL,
 CONSTRAINT [UQ_TypeStaging] UNIQUE NONCLUSTERED 
(
	[type_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Use](
	[use_id] [int] NOT NULL,
	[use_nm] [varchar](50) NOT NULL,
 CONSTRAINT [PK_Use] PRIMARY KEY CLUSTERED 
(
	[use_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Use_nm] UNIQUE NONCLUSTERED 
(
	[use_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[UseStaging](
	[use_id] [int] NULL,
	[use_nm] [varchar](50) NULL,
 CONSTRAINT [UQ_UseStaging_nm] UNIQUE NONCLUSTERED 
(
	[use_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==================================================================================================================================================
-- Author:      Terry Watts
-- Create date: 03-JAN-2025
-- Description: Merges the static data staging tables to theirassociated main static tables
--       and do any fixup
--
-- REQUIREMENTS:
-- R01: populate the DEL01 set using the PRE01 set of tables
--
-- PRECONDITIONS:
-- PRE01: the following set of staging tables are populated and fixed up
--    PRE01: ActionStaging
--    PRE02: ChemicalStaging
--    PRE06: CompanyStaging
--    PRE07: CropStaging
----  PRE09: PathogenStaging
--    PRE11: PathogenTypeStaging
--    PRE12: PathogenPathogenStaging
--    PRE15: TypeStaging
--    PRE16: UseStaging
--    PRE17: DistributorStaging
--
-- PRE02: import id session setting set or is a parameter
--
-- POSTCONDITIONS
-- POST 01: the following static data tables are populated and fixed up:
--    Action
--    Chemical
--    Company
--    Crop
--    Distributor
--    Pathogen
--    PathogenType
--    Type
--    Use
--
-- TESTS:
--
-- CHANGES:
-- ==================================================================================================================================================
CREATE PROCEDURE [dbo].[sp_merge_static_tbls]
AS
BEGIN
   SET NOCOUNT OFF;

   DECLARE
       @fn        VARCHAR(30)  = N'sp_merge_static_tbls'
      ,@error_msg VARCHAR(MAX)  = NULL
      ,@file_path VARCHAR(MAX)
      ,@id        INT = 1

   BEGIN TRY
      EXEC sp_log 2, @fn,'000: starting';

      -----------------------------------------------------------------------------------
      -- Precondition checks
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '010: checking preconditions';
      EXEC sp_assert_tbl_pop 'ActionStaging';
      EXEC sp_assert_tbl_pop 'ChemicalStaging';
      EXEC sp_assert_tbl_pop 'CompanyStaging';
      EXEC sp_assert_tbl_pop 'CropStaging';
      EXEC sp_assert_tbl_pop 'DistributorStaging';
      EXEC sp_assert_tbl_pop 'PathogenStaging';
      EXEC sp_assert_tbl_pop 'PathogenTypeStaging';
      EXEC sp_assert_tbl_pop 'TypeStaging';
      EXEC sp_assert_tbl_pop 'UseStaging';

      -----------------------------------------------------------------------------------
      --  03: merging static data tables
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'020: merging static data tables   ';

      DELETE FROM [Action];
      DELETE FROM Chemical;
      DELETE FROM Company;
      DELETE FROM Crop;
      DELETE FROM Distributor;
      DELETE FROM Pathogen;
      DELETE FROM PathogenType;
      DELETE FROM [Type];
      DELETE FROM [Use];

      -----------------------------------------------------------------------------------
      --  04: Merge Action table
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '030: merging Action table';
      MERGE [Action]        AS target
      USING ActionStaging   AS s
      ON target.action_nm = s.action_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  action_nm) -- use new id
         VALUES (s.action_nm)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
      ;

      EXEC sp_assert_tbl_pop 'Action';

      -----------------------------------------------------------------------------------
      --  05: Merge Type table
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      -- In which case we need to assign a new id and use that in the associated link tables.
      -- Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '040: merging Type table';
      MERGE [Type]        AS target
      USING TypeStaging   AS s
      ON target.type_nm = s.type_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  type_nm)
         VALUES (s.type_nm)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
      ;

      EXEC sp_assert_tbl_pop 'Type';

      -----------------------------------------------------------------------------------
      --  Merge Use table
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '040: merging Use table';
      MERGE [Use]        AS target
      USING UseStaging   AS s
      ON target.use_nm = s.use_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  use_id,  use_nm)
         VALUES (s.use_id,s.use_nm)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
      ;

      EXEC sp_assert_tbl_pop 'Use';

      -----------------------------------------------------------------------------------
      --  06: Merge PathogenType table
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      -- In which case we need to assign a new id and use that in the associated link tables.
      -- Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '050: merging PathogenType table';
      MERGE PathogenType          AS target
      USING PathogenTypeStaging   AS s
      ON target.pathogenType_nm = s.pathogenType_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  pathogenType_nm)
         VALUES (s.pathogenType_nm)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
      ;

      EXEC sp_assert_tbl_pop 'PathogenType';

      -----------------------------------------------------------------------------------
      --  07: Merge Pathogen table
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      -- In which case we need to assign a new id and use that in the associated link tables.
      -- Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '060: merging Pathogen table';
      MERGE Pathogen AS target
      USING 
      (
         SELECT pt.pathogenType_id, ps.pathogen_nm, pt.pathogenType_nm, subtype, latin_nm, alt_common_nms, alt_latin_nms, ph_common_nms, crops, taxonomy, notes, urls, biological_cure
         FROM PathogenStaging ps
         LEFT JOIN PathogenType pt ON pt.pathogenType_nm = ps.pathogenType_nm
      )  AS s
      ON target.pathogen_nm = s.pathogen_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  pathogen_nm,  pathogenType_id,  pathogenType_nm,  subtype,  latin_nm,  alt_common_nms,  alt_latin_nms,  ph_common_nms,  crops,  taxonomy,  notes,  urls,  biological_cure)
         VALUES (s.pathogen_nm,s.pathogenType_id,s.pathogenType_nm,s.subtype,s.latin_nm,s.alt_common_nms,s.alt_latin_nms,s.ph_common_nms,s.crops,s.taxonomy,s.notes,s.urls,s.biological_cure)
      -- WHEN MATCHED THEN UPDATE SET target.pathogenType_id = S.pathogenType_id  -- should be a 1 off
      WHEN NOT MATCHED BY SOURCE THEN DELETE
      ;

      EXEC sp_assert_tbl_pop 'Pathogen';

      -----------------------------------------------------------------------------------
      --  08: Merge Chemical table
      -----------------------------------------------------------------------------------
      -- It may be that that staging ids are different for a given name and may conflict other ids in the table.
      -- In which case we need to assign a new id and use that in the associated link tables.
      -- Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '070: merging Chemical table';
      MERGE Chemical          AS target
      USING ChemicalStaging   AS s
      ON target.chemical_nm=s.chemical_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  chemical_nm)
         VALUES (s.chemical_nm)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
         ;

      EXEC sp_assert_tbl_pop 'Chemical';

      -----------------------------------------------------------------------------------
      -- 09: Merge Company table
      -----------------------------------------------------------------------------------
      -- It may be that that staging ids are different for a given name and may conflict other ids in the table.
      -- In which case we need to assign a new id and use that in the associated link tables.
      -- Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '080: merging Company table';
      MERGE Company          AS target
      USING CompanyStaging   AS s
      ON target.company_nm = s.company_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  company_nm)
         VALUES (s.company_nm)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
         ;

      EXEC sp_assert_tbl_pop 'Company';

      -----------------------------------------------------------------------------------
      -- 10: Merge Crop table
      -----------------------------------------------------------------------------------
      -- It may be that that staging ids are different for a given name and may conflict other ids in the table.
      -- In which case we need to assign a new id and use that in the associated link tables.
      -- Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '090: merging Crop table';
      DELETE FROM Crop;

      MERGE Crop          AS target
      USING 
      (
         SELECT * FROM CropStaging
      )   AS s
      ON target.crop_nm=s.crop_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  crop_nm, latin_nm, alt_latin_nms, alt_common_nms,taxonomy,notes)
         VALUES (s.crop_nm, latin_nm, alt_latin_nms, alt_common_nms,taxonomy,notes)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
         ;

      EXEC sp_assert_tbl_pop 'Crop';

      -----------------------------------------------------------------------------------
      -- 11: Merge Distributor table
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      EXEC sp_log 2, '100: merging Distributor table';
      MERGE Distributor          AS target
      USING 
      (
        SELECT * FROM DistributorStaging
      ) AS s
      ON target.distributor_nm=s.distributor_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  distributor_nm)
         VALUES (s.distributor_nm)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
         ;

      EXEC sp_assert_tbl_pop 'Distributor';

      -----------------------------------------------------------------------------------
      -- ASSERTION: all the main static data tables merged
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'120: ASSERTION: all the static data tables merged.';

      -----------------------------------------------------------------------------------
      -- POSTCONDITION checks
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '250: POSTCONDITION checks   ';
   -- POST 01: Action table populated
   -- POST 02: Chemical table populated
   -- POST 03: Company table populated
   -- POST 04: Crop table populated
   -- POST 05: Distributor table populated
   -- POST 06: Pathogen table populated
   -- POST 07: PathogenType table populated
   -- POST 08: Type table populated
   -- POST 09: Use table populated

      -----------------------------------------------------------------------------------
      -- 23: Completed processing OK
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '400: Completed processing OK';
   END TRY
   BEGIN CATCH
      SET @error_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '500: Caught exception: ', @error_msg;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving: OK';
END
/*
SELECT COUNT(*) FROM Pathogenstaging;
EXEC sp_mrg_static_tbls;
SELECT COUNT(*) FROM Action;
SELECT COUNT(*) FROM Chemical;
SELECT COUNT(*) FROM Company;
SELECT COUNT(*) FROM Crop;
SELECT COUNT(*) FROM Distributor;
SELECT COUNT(*) FROM PathogenType;
SELECT COUNT(*) FROM Pathogen;
SELECT COUNT(*) FROM [Type];
SELECT COUNT(*) FROM [Use];
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================================================================================================
-- Author:      Terry Watts
-- Create date: 28-JAN-2024
--
-- DESCRIPTION:
-- Imports the static data, comprising of PRIMARY and SYSTEM static data
-- Imports the statging tables
-- Merges to the Main static tables
-- EXEC tSQLt.Run 'test.test_009_sp_import_static_data';
--
-- Static SYSTEM data are:
-- CallRegister : imported by sp_main_import_init
-- Import       : imported here
-- ForeignKey   : imported here
-- TypeStaging  : imported here
-- TableType    : imported here
-- TableDef     : imported here
-- 
-- Static data are:
-- ActionStaging
-- CropPathogenStaging
-- CropStaging
-- DistributorStaging: non LRAP data like address
-- MosaicVirusStaging
-- PathogenStaging
-- PathogenTypeStaging
-- UseStaging
--
-- The dynamic data are created from LRAP Staging2
-- *** These tables are NOT IMPORTED as static data before the LRAP load
-- *** But after the LRAP load and fixup
-- It is comprised of the following:
-- ChemicalActionStaging
-- ChemicalStaging
-- ChemicalProductStaging
-- ChemicalUseStaging
-- CompanyStaging
-- ImportCorrectionsStaging
-- PathogenChemicalStaging
-- ProductStaging
-- ProductCompanyStaging
-- ProductUseStaging: non LRAP data

-- RESPONSIBILITIES:
-- R01: clear dependent tables
-- R02: import the following tables:
-- ActionStaging
-- CropStaging
-- CropPathogenStaging
-- DistributorStaging
-- 12 Eppo Staging tables(, als fixup and merge to the main Eppo tables) - delegated to sp_import_eppo
-- FertHandler
-- ForeignKey
-- Import
-- PathogenStaging
-- PathogenTypeStaging
-- TableDef
-- TableType
-- TypeStaging
-- UseStaging
--
-- R03: populates the following Main static tables
-- Action
-- Crop
-- CropPathogen
-- Distributor
-- Eppo tables - see import eppo as the eppo data are a conditional import
-- PathogenType
-- Pathogen
-- TableDef
-- TableType
-- Type
-- Use
--
-- PRECONDITIONS: dependent tables cleared
-- 
-- POSTCONDITIONS:
--   POST01: all the imported tables have at least one row
--
-- CALLED BY: sp__main_import
--
-- TESTS:
--
-- CHANGES:
-- 240223: import PathogenTypeStaging table from either a tsv or xlsx file
-- 240225: removed precondition and made part of the processing so routine is easy to test 
-- 240321: treating Pathogen as a primary data table to check the lRAP import pathogens
-- 241130: optionally import the eppo files
-- =========================================================================================
CREATE PROCEDURE [dbo].[sp_import_static_data]
    @import_root     VARCHAR(500)   = NULL  -- default: 'D:\Dev\Farming\Data'
   ,@display_tables  BIT            = 0
   ,@import_eppo     BIT            = 0
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)    = N'sp_import_static_data'
   ,@sql             VARCHAR(MAX)   
   ,@error_msg       VARCHAR(MAX)   = NULL
   ;

   BEGIN TRY
      IF dbo.fnLen(@import_root) = 0 SET @import_root = 'D:\Dev\Farming\Data';

      EXEC sp_log 1, @fn,'000: starting
@import_root   :[',@import_root   ,']
@display_tables:[',@display_tables,']
@import_eppo   :[',@import_eppo   ,']
';

      --------------------------------------------------------------------------------------------
      -- R01: import system static data tables
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'010: calling sp_import_system_static_data';
      EXEC sp_import_system_static_data;

      --------------------------------------------------------------------------------------------
      -- R02: import primary static data staging tables
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'020: R02: importing the primary static data tables';
      EXEC sp_import_static_data_staging @import_root, @display_tables = @display_tables;

      --------------------------------------------------------------------------------------------
      -- R02.2 import Eppo Staging tables
      --------------------------------------------------------------------------------------------
      IF @import_eppo = 1
      BEGIN
         EXEC sp_log 1, @fn,'030: import Eppo Staging tables';
         EXEC sp_import_eppo @display_tables = @display_tables;
      END

      --------------------------------------------------------------------------------------------
      -- R03 Fixup and Merge to main static data tables
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'040: Merge to main tables';
      EXEC sp_merge_static_tbls;

      --------------------------------------------------------------------------------------------
      -- Postcondition checks
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'050: Postcondition checks: staging tables';

      --------------------------------------------------------------------------------------------
      -- Postcondition checks - staging tables
      --------------------------------------------------------------------------------------------
      EXEC sp_assert_tbl_pop 'ActionStaging';
      EXEC sp_assert_tbl_pop 'CropStaging';
      EXEC sp_assert_tbl_pop 'MosaicVirusStaging';
      EXEC sp_assert_tbl_pop 'PathogenStaging';
      EXEC sp_assert_tbl_pop 'PathogenTypeStaging';
      EXEC sp_assert_tbl_pop 'TypeStaging';
      EXEC sp_assert_tbl_pop 'UseStaging';


         --------------------------------------------------------------------------------------------
   -- R03:  Postcondition checks - main static tables
         --------------------------------------------------------------------------------------------
   -- Action
   -- Crop
   -- CropPathogen
   -- Distributor
   -- Eppo tables - see import eppo as the eppo data are a conditional import
   -- PathogenType
   -- Pathogen
   -- TableDef
   -- TableType
   -- Use
      EXEC sp_log 1, @fn,'60: Postcondition checks: main static tables';
      EXEC sp_assert_tbl_pop 'Action';
      EXEC sp_assert_tbl_pop 'Crop';
      EXEC sp_assert_tbl_pop 'FertHandler';
      EXEC sp_assert_tbl_pop 'Import';
      EXEC sp_assert_tbl_pop 'MosaicVirus';
      EXEC sp_assert_tbl_pop 'Pathogen';
      EXEC sp_assert_tbl_pop 'PathogenType';
      EXEC sp_assert_tbl_pop 'TableDef';
      EXEC sp_assert_tbl_pop 'TableType';
      EXEC sp_assert_tbl_pop 'Type';
      EXEC sp_assert_tbl_pop 'Use';
      EXEC sp_assert_tbl_pop 'WareHouse';


      --------------------------------------------------------------------------------------------
      -- Completed processing OK
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'400: Completed processing OK';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 1, @fn, '999: leaving OK';
END
/*
EXEC sp_import_static_data 1,0; -- disp tbls, no eppo
EXEC tSQLt.RunAll;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ========================================================================================
-- Author:      Terry Watts
-- Create date: 21-JUN-20223
-- Description: List the Pathogens in order - use to
--    look for duplicates and misspellings and errors
--
--    *** NB: use list_unregistered_pathogens_vw in preference to fnListPathogens()
--    as fnListPathogens yields a false leading space on some items
-- ========================================================================================
CREATE FUNCTION [dbo].[fnListDistinctPathogensInS2]()
RETURNS 
@t TABLE (pathogen VARCHAR(400))
AS
BEGIN
   INSERT INTO @t
   SELECT DISTINCT TOP 100000
   cs.value AS pathogen 
   FROM Staging2 
   CROSS APPLY string_split(pathogens, ',') cs
   WHERE cs.value <> ''
   ORDER BY pathogen;

   RETURN;
END
/*
SELECT pathogen from dbo.fnListPathogensInS2();
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ====================================================================
-- Author       Terry Watts
-- Create date: 21-MAR-2024
-- Description: List the pathogen erros in the LRAP Import S2 table
--              NB: use this in preference to fnListPathogens() 
-- ====================================================================
CREATE VIEW [dbo].[list_unregistered_pathogens_vw]
AS
   SELECT TOP 10000 Pathogen as [Unregisterd Pathogen], concat('[',Pathogen,']') as x
   FROM dbo.fnListDistinctPathogensInS2()
   WHERE pathogen NOT in (SELECT pathogen_nm FROM Pathogen)
   ;
/*
SELECT * FROM list_unregistered_pathogens_vw ORDER BY [Unregisterd Pathogen];
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =========================================================================
-- Procedure:   dbo.spExecuteCmds
-- Description: 
-- EXEC tSQLt.Run 'test.test_067_spExecuteCmds';
-- Design:      
-- Tests:       
-- Author:      Terry Watts
-- Create date: 30-DEC-2024
--
-- Notes:
-- use like:  spExecuteCmds 'EXEC sp_assert_tbl_pop ''', [value], ''''
-- parameters:
-- @cmd the command to be run, it must include [value]
-- =========================================================================
CREATE PROCEDURE [dbo].[spExecuteCmds]
    @cmd   NVARCHAR(MAX) -- like 'EXEC sp_assert_tbl_pop ''', [value], ''''
   ,@items NVARCHAR(MAX) -- comma separated list of items to run teh sql against
   ,@end   INT OUT
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
      @fn   VARCHAR(35)    = 'spExecuteCmds'
     ,@ndx INT = 0
     ,@sql NVARCHAR(MAX)
     ,@msg NVARCHAR(MAX)

      EXEC sp_log 1, @fn ,'000: starting
@cmd  :[',@cmd  ,']
@items:[',@items,']
';

      IF OBJECT_ID('dbo.#CmdsTbl', 'U') IS NULL
      CREATE table #CmdsTbl
      (
        id INT identity(1,1)
       ,sql NVARCHAR(MAX)
      )
      ELSE TRUNCATE TABLE #CmdsTbl;

   SET @sql = 
   CONCAT
   (
'INSERT INTO #CmdsTbl(sql)
SELECT CONCAT(''',@cmd,' '', value,'';'')
FROM string_split(''', @items, ''','','');'
   );

   EXEC sp_log 1, @fn ,'010: @sql:
', @sql;

   EXEC (@sql);

   SELECT @end = COUNT(*) FROM #CmdsTbl;
   EXEC sp_log 1, @fn ,'020: start ndx: ', @ndx, ' count of rows (end): ', @end;
   SELECT * FROM #CmdsTbl;

   WHILE @ndx < = @end
   BEGIN
      SELECT
            @sql = [sql]
      FROM #CmdsTbl
      WHERE id = @ndx;

      EXEC sp_log 1, @fn, '090:[',@ndx,']: ', @sql;
      EXEC (@sql);
      SET @ndx = @ndx + 1
   END

   EXEC sp_log 1, @fn ,'999 leaving';
END
/*
EXEC sp_assert_all_data_tbls_pop 0;
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_067_spExecuteCmds';
EXEC spExecuteCmds
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===========================================================================
-- Procedure:   sp_assert_all_data_tbls_pop
-- Description: checks all the non staging tables except the excluded ones
-- EXEC tSQLt.Run 'test.test_000_sp_assert_all_data_tbls_pop';
-- Design:      
-- Tests:       
-- Author:      
-- Create date: 
-- ===========================================================================
CREATE PROCEDURE [dbo].[sp_assert_all_data_tbls_pop]
    @mn_tbls   BIT = 1
   ,@inc_eppo  BIT = 0
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
    @fn              VARCHAR(35)  = N'import_static_data_staging'
   ,@items           NVARCHAR(MAX) -- comma separated list of tables to run the sp_assert_tbl_pop against
   ,@excluded        NVARCHAR(MAX)
   ,@excluded_items  NVARCHAR(MAX)
   ,@sql             NVARCHAR(MAX)
   ,@row_cnt         INT

   EXEC sp_log 1, @fn ,'000: starting:
mn_tbls :[',@mn_tbls ,']
inc_eppo:[',@inc_eppo,']
';

   IF @mn_tbls = 1
      SET @excluded = ''--ActionFixup,ChemicalAction,ChemicalProduct,ChemicalUse,CorrectionLog';
   ELSE
      SET @excluded = 'ImportCorrectionsStaging';

   SELECT @excluded_items = string_agg(CONCAT('''',value, ''''),',') FROM string_split(@excluded, ',');
   EXEC sp_log 1, @fn ,'010: @excluded_items: ',@excluded_items;
   SET @sql = CONCAT('SELECT @items = string_agg(table_nm,'','')
FROM dbo.fnListTables(''dbo'')
WHERE table_nm ',iif( @mn_tbls = 1, 'NOT ', ''), 'LIKE ', '''%Staging%'' AND table_nm NOT IN (',@excluded_items,')');

   IF @inc_eppo = 0
      SET @sql = CONCAT( @sql, ' AND table_nm NOT LIKE ''%EPPO%'' ');

   SET @sql = CONCAT( @sql, ';');
   PRINT CONCAT('100: @sql: ',@sql);
   EXEC sp_executesql @sql, N'@items NVARCHAR(MAX) OUT, @excluded_items NVARCHAR(MAX)', @items OUT, @excluded_items;
   EXEC sp_log 1, @fn ,'020: @items:[',@items,']';
   EXEC sp_log 1, @fn ,'030: calling spExecuteCmds @items';
   EXEC spExecuteCmds 'EXEC sp_assert_tbl_pop', @items, @row_cnt OUT;
   EXEC sp_log 1, @fn ,'999: leaving';
END
/*
   EXEC sp_assert_all_data_tbls_pop 0,0
   EXEC sp_assert_all_data_tbls_pop 1,1
   SELECT * FROM ChemicalActionStaging
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =================================================================
-- Author:      Terry Watts
-- Create date: 05-FEB-2024
-- Description: runs detailed post condition checks of any db state
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
-- POST 01: no line feed only line separator
-- POST 02: crop name contains none of the following: (' Beans','  Popcorn)','Banana (Cavendish) (Post- harvest treatment)', 'Banana (Cavendish) as insecticidal soap','Cowpea and other beans','Soybeans & other beans'))
-- POST 03: no apostophe in pathogens
-- POST 04: Pathogen.pathogen_type_id IS NOT NULL
-- POST 05: Pathogen.pathogen_nm does not contain ('Bacterial wilt and','As foot ','Foot ','Golden apple Snails','Ripening')
-- POST 06:
-- POST 07:
-- POST 08:
--
-- STRATEGY:
-- 01: check no Character 10 without Character 13 - i.e. no line feed only line separator- XL data has several of these
-- 02: check no spc or spc in the critical columns: crops, pathogens
-- 03: test no blank spc only or NULL essential data
-- 04: check no Character 10 without Character 13 - line feed only - XL data has several of these
-- 02: check no  spc or spc in the critical columns: crops, pathogens
-- 03: test no blank spc only or NULL essential data

-- 05: Chemicals Table:
-- 05.1: Chlorpyrifos/plastech 20% M/b
-- 05.2: Chlorpyrifos/pyritiline 20 Pe M/b
-- 05.3: Mesotrione,Glyphosate,S-Metachlor

-- 06: ChemPathCrp vw
-- 07: ChemicalProduct_vw
-- 08: ChemicalUse
-- 09: Company Table
-- 10: Crop table
-- 11: Pathogen: 1: pathogen_type_id field is populated, 2: crop_pathogen_vw has the pathogen type info id, nm, 3: nm: 'Bacterial wilt and'
-- 12: Import table
-- 13: ProductChemical_vw
-- 14: Pathogen table
-- 15: Product table
-- 16: ProductUse_vw
-- 17: Type table
-- 18: Use table
--
-- CALLED BY: sp__main_impor
--
-- CHANGES:
-- =================================================================
CREATE PROCEDURE [dbo].[sp_mn_imprt_stg_12_post_cks] @import_eppo bit = 0
AS
BEGIN
   DECLARE
    @fn        VARCHAR(35)   = 'sp_mn_imprt_stg_11_post_cks'
   ,@cnt                INT            = 0
   ,@err_cnt            INT            = 1
   ,@err_msg            VARCHAR(250)  = NULL
   ,@msg                VARCHAR(250)  = NULL
   ,@table              VARCHAR(100)  = NULL
   ,@field_nm           VARCHAR(100)  = NULL
   ,@value              VARCHAR(100)  = NULL

   EXEC sp_log 1, @fn, '000: starting';
   --EXEC sp_register_call @fn;

   -----------------------------------------------------------------------------------
   -- Perform the post condition checks for all data
   -----------------------------------------------------------------------------------
   -- 1: test are performed in a do while looop - break on first error
   WHILE 1=1
   BEGIN
      -- 01: staging 1 tests
      -- 02: check no Character 10 without Character 13 - line feed only - XL data has several of these
      -- 03: check no extra spaces in the critical columns: crops, pathogens
      -- 04: test no blank spc only or NULL essential data
      -- 05: Chemicals Table:
      -- 05.1: Chlorpyrifos/plastech 20% M/b
      -- 05.2: Chlorpyrifos/pyritiline 20 Pe M/b
      -- 05.3: Mesotrione,Glyphosate,S-Metachlor
      
      -- 06: ChemPathCrp vw:
      -- 07: ChemicalProduct_vw:
      -- 08: ChemicalUse:
      -- 09: Company Table:

      -- 10: Crop table:
      --  Beans   NULL
      --  Popcorn)
      -- Banana (Cavendish) (Post- harvest treatment)
      -- Banana (Cavendish) as insecticidal soap
      -- Corn (Sweet and Popcorn)
      -- Corn (Sweet corn
      -- Field
      -- foot
      EXEC sp_log 2, @fn,'02: POST 02: Crop name contains none of the following';
      If EXISTS (Select 1 from Crop where crop_nm IN (' Beans','  Popcorn)','Banana (Cavendish) (Post- harvest treatment)', 'Banana (Cavendish) as insecticidal soap','Cowpea and other beans','Soybeans & other beans'))
      BEGIN
         SET @msg      = ''
         SET @table    = 'Crop'
         SET @field_nm = 'crop_nm'
         SET @value    = 'has at least one of these values: [ Beans] or [ Popcorn)] or [Banana (Cavendish) (Post- harvest treatment)] or [Banana (Cavendish) as insecticidal soap], [Cowpea and other beans], [Soybeans & other beans]';
         BREAK;
      END

      -- 231019
     EXEC sp_log 2, @fn,'03: POST 03: no apostophe in pathogens';
     IF EXISTS (SELECT 1 FROM Staging2 where pathogens LIKE '''%')
      BEGIN
            SET @msg = '*** Staging2.pathogens: leading apostophe still exists';
            SET @table    = 'Staging2'
            SET @field_nm = 'pathogens'
            SET @value    = '''';
            BREAK;
      END

      -- Test 1: pathogen_type_id field is populated
      EXEC sp_log 2, @fn,'04: POST 04: Pathogen.pathogen_type_id IS NOT NULL';
      SET @cnt= (SELECT COUNT(*) FROM Pathogen where pathogenType_id IS NULL);

      If @cnt > 0
      BEGIN
         SET @msg      = 'Test 11'
         SET @table    = 'Pathogen'
         SET @field_nm = 'pathogen_type_id'
         SET @value    = CONCAT('has ',@cnt, ' NULLs');

         -- Display all Pathogen rows where pathogenType_id is null
         SELECT pathogen_nm FROM Pathogen where pathogenType_id IS NULL;
         BREAK;
      END

      -- Test 2: crop_pathogen_vw has the pathogen type info id, nm
      -- Test 3: nm: 'Bacterial wilt and','As foot ','Foot ','Golden apple Snails','Ripening'  exists  
      EXEC sp_log 2, @fn,'05: Pathogen.pathogen_nm in ''Bacterial wilt and'',''As foot '',''Foot '',''Golden apple Snails'',''Ripening''';

      If EXISTS (Select 1 FROM Pathogen WHERE pathogen_nm IN ('Bacterial wilt and','As foot ','Foot ','Golden apple Snails','Ripening'))
      BEGIN
         SET @msg      = ''
         SET @table    = 'Pathogen'
         SET @field_nm = 'pathogen_nm'
         SET @value    = 'has at least one of these values: ''Bacterial wilt and'',''As foot '',''Foot '',''Golden apple Snails'',''Ripening''';
         SELECT * FROM Pathogen WHERE pathogen_nm IN ('Bacterial wilt and','As foot ','Foot ','Golden apple Snails','Ripening');
         BREAK;
      END

      SET @err_cnt = 0;
      EXEC sp_log 2, @fn, '95: completed tests ok, ret: ', @err_cnt;
      BREAK;
   END
   -- IF error
   IF @err_cnt > 0
   BEGIN
      SET @err_msg = CONCAT('*** Error *** :  table: ', @table, ' field: ', @field_nm, ' value: [', @value, ']');
      EXEC sp_log 2, @fn, @err_msg;
      THROW 56821, @err_msg,1;
   END

   SET @cnt = (SELECT COUNT(*) FROM list_unregistered_pathogens_vw);

   IF @cnt <> 0
   BEGIN
      SELECT * FROM list_unregistered_pathogens_vw;
      SET @msg = CONCAT(@cnt, ' unregistered pathogens exist in S2 see last results table');
      EXEC sp_log 4, @fn, @msg;
   END

   -- Display the update counts
   SELECT * FROM ImportCorrections ORDER BY id;

   EXEC sp_assert_all_data_tbls_pop @import_eppo;

   ---------------------------------------------------------------------------------------------
   -- ASSERTION: all S2 pathogens exist in the primary pathogens table
   ---------------------------------------------------------------------------------------------
   EXEC sp_log 2, @fn, '10: ASSERTION: all S2 pathogens exist in the primary pathogens table';

   EXEC sp_log 2, @fn, '90: processing complete';
   EXEC sp_log 1, @fn, '99: leaving, errors? ', @cnt;
END
/*
   EXEC sp_mn_imprt_stg_11_post_cks;
   EXEC sp_clear_call_register 'sp_mn_imprt_stg_11_post_cks';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================================
-- Author:      Terry Watts
-- Create date: 29-JUL-2023
-- Description: this is the S2 main view relating all fields, it splits out the multiple value fields
--              into a field that holds only 1 value. 
--              Examples are [Pathogens, Pathogen], [Uses Use], [Ingredient, Chemical]
--
-- PRECONDITIONS: Dependencies:
--                Tables: Staging2, [Use], ChemicalStaging, CropStaging, PathogenStaging, ProductStaging
--
-- CHANGES:
-- 20-JAN-2024 now uses only the staging2 table
-- 22-JAN-2024 added actions
-- ======================================================================================================
CREATE VIEW [dbo].[all_vw]
AS
SELECT
       s.id
      ,company
      ,product        AS product_nm
      ,ingredient     AS chemicals
      ,Chem.    value AS chemical_nm
      ,entry_mode     AS actions
      ,E.       value AS action_nm
      ,crops
      ,Crp.     value AS crop_nm
      ,pathogens
      ,P.       value AS pathogen_nm
      ,s.uses
      ,u.       value AS use_nm
FROM 
   Staging2 s 
   CROSS APPLY string_split(ingredient, '+') as Chem
   CROSS APPLY string_split(crops     , ',') as Crp
   CROSS APPLY string_split(pathogens , ',') as P
   CROSS APPLY string_split(uses      , ',') as U
   CROSS APPLY string_split(entry_mode, ',') as E
/*
SELECT * FROM all_vw
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ChemicalActionStaging](
	[chemical_nm] [varchar](100) NULL,
	[action_nm] [varchar](100) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================================
-- Author:       Terry Watts
-- Create date:  22-JAN-2024
-- Description:  Populates the ChemicalActionStaging table from all_vw:
--               Takes the minimum set of uses from the products containing the chemical
--               2:[OPTIONAL] add the extra chemical action data from a spreadsheet tsv
--
-- PRECONDITIONS:
--       PRE01: S2 table         populated
--       PRE02: ActionStaging    populated
--       PRE03: ChemicalStaging  populated
--       PRE04: S2 table fixup done
--
-- POSTCONDITIONS:
-- POST 01: ChemicalActionStaging table populated
-- POST 02: Mancozeb exists in ChemicalActionStaging and is only contact
--
-- ALGORITHM:
--    0: PRECONDITION VALIDATION CHECKS
--    1: TRUNCATE the ChemicalActionStaging table
--    2: using All_vw get each chemical and its set of actions for products with ingredients containing only 1 chemical
--
-- CHANGES:
-- 241107: Re visited requirements, resonsibiities, pre and post conditions
--    PRE: All fixup to be done before this stage
--    POST: only 1 postcondition: ChemicalActionStaging table populated
--
-- Tests:
-- ======================================================================================================
CREATE PROCEDURE [dbo].[sp_pop_ChemicalActionStaging]
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)   = N'sp_pop_ChemicalActionStaging'
      ,@sql       VARCHAR(MAX)
      ,@error_msg VARCHAR(MAX)  = NULL
      ,@rc        INT            =-1
      ,@cnt       INT            = 0
      ,@stage     INT            = 1;
      ;

   BEGIN TRY
      EXEC sp_log 2, @fn,'000: starting, validating preconditions';
      --EXEC sp_register_call @fn;

      ----------------------------------------
      -- Validate preconditions
      ----------------------------------------
      EXEC sp_assert_tbl_pop 'Staging2';
      EXEC sp_assert_tbl_pop 'ActionStaging';
      EXEC sp_assert_tbl_pop 'ChemicalStaging';

      ----------------------------------------
      -- Process
      ----------------------------------------
      -- ASSERTION: S2 table populated

      EXEC sp_log 1, @fn,'020: truncating ChemicalActionStaging table';
      TRUNCATE TABLE dbo.ChemicalActionStaging;

      -- 2: using All_vw get each chemical and its set of actions for products with ingredients containing only 1 chemical
      SET @stage = 2;
      EXEC sp_log 1, @fn,'030: populating the ChemicalActionStaging table from ALL_vw ';

      INSERT INTO ChemicalActionStaging(chemical_nm, action_nm)
      SELECT DISTINCT chemical_nm, action_nm
      FROM ALL_vw 
      WHERE
             chemical_nm IS NOT NULL 
         AND action_nm   IS NOT NULL
         AND action_nm   NOT IN (' ','-')
         AND chemicals   NOT LIKE '%+%'
      ORDER BY chemical_nm, action_nm;

      SET @stage = 3;
      EXEC sp_log 1, @fn, '040: populated the ChemicalActionStaging table OK';

      ----------------------------------------
      -- Validate postconditions
      ----------------------------------------
      EXEC sp_log 1, @fn, '050: postcondition checks   ';

      -- Chk POST01: ChemicalActionStaging table populated
      EXEC sp_log 1, @fn, '060: chk ChemicalActionStaging pop';
      EXEC sp_assert_tbl_pop 'ChemicalActionStaging';

      -- POST 02: Mancozeb exists in ChemicalActionStaging and is only contact
      SELECT @cnt = COUNT(*) FROM ChemicalActionStaging WHERE chemical_nm='Mancozeb' AND action_nm='CONTACT';
      EXEC sp_log 1, @fn, '070: chk ChemicalActionStaging has only 1 Mancozeb/CONTACT row, actual row cnt: ', @cnt;

      IF(@cnt> 1)
      BEGIN
         SELECT * FROM ChemicalActionStaging WHERE chemical_nm='Mancozeb';
         EXEC sp_assert_equal 2, 1, 'Mancozeb should only have 1 entry in ChemicalActionStaging and it should be contact, count: ', @cnt, @ex_num=53224, @fn=@fn;
      END

      EXEC sp_log 2, @fn, '800: completed processing OK';
      SET @stage = 99;
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: caught exception, stage: ',@stage;
      EXEC sp_log_exception @fn;

      IF @stage = 2
      BEGIN
         SELECT  DISTINCT action_nm as [un registered actions]
         FROM ALL_vw
         WHERE
             action_nm IS NOT NULL
         AND action_nm NOT IN (' ','-')
         AND chemicals NOT LIKE '%+%'
         AND action_nm NOT IN ( SELECT action_nm FROM ActionStaging)
         ;

         SELECT action_nm AS [registered actions]
         FROM ActionStaging;
      END

      ;THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving OK';
   RETURN @RC;

END
/*
EXEC sp_pop_ChemicalActionStaging;
SELECT * FROM ChemicalActionStaging ORDER BY chemical_nm, action_nm
sp_pop_ChemicalActionStaging
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ChemicalUseStaging](
	[chemical_nm] [varchar](100) NULL,
	[use_nm] [varchar](50) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================================================================
-- Author:      Terry Watts
-- Create date: 06-OCT-2023
-- Description: Populates the chemical use table from 2 sources:
--              1: once the S2 table use ALL_vw
--              2: add the extra product use data to the chemical use table from the spreadsheet tsv
--
-- PRECONDITIONS:
--       PRE01: UseStaging table       must be populated
--       PRE02: ChemicalStaging table  must be populated
--
-- POSTCONDITIONS:
--       POST01: ProductUse table populated
--
-- ALGORITHM:
--    0: PRECONDITION VALIDATION CHECKS
--    1: TRUNCATE the staging table
--    2: we can pop the Chemical Use staging table using All_vw
--
-- CALLED BY: -- CALLED BY: sp_main_import_stage_07_pop_stging
--
-- CHANGES:
-- 240124: removed import id parameter
--
-- Tests:
-- ======================================================================================================
CREATE   PROCEDURE [dbo].[sp_pop_ChemicalUseStaging]
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)   = N'POP CHEM USE STAGING'
      ,@sql       VARCHAR(MAX)
      ,@error_msg VARCHAR(MAX)  = NULL
      ,@rc        INT            =-1
      ,@cnt       INT            = 0
      ;

   BEGIN TRY
      EXEC sp_log 2, @fn,'01: starting, running precondition checks';
      --EXEC sp_register_call @fn;

      --------------------------------------------------------------------------------
      -- PRECONDITION checks
      --------------------------------------------------------------------------------

      -- PRE02: UseStaging must be populated
      EXEC sp_log 1, @fn,'03: PRE02: UseStaging must be populated';
      EXEC sp_assert_tbl_pop 'UseStaging';

      -- PRE03: ChemicalStaging table must be populated
      EXEC sp_assert_tbl_pop 'ChemicalStaging';

      --------------------------------------------------------------------------------
      -- ASSERTION: @import_id known and not NULL or ''
      -- ASSERTION chemicalStaging and [Use] tables are populated
      --------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'04: truncating ChemicalUseStaging table';
      TRUNCATE TABLE dbo.ChemicalUseStaging;

      -- 2: pop the ChemicalUse staging table using the distinct all_vw
      EXEC sp_log 1, @fn,'05: populating the ChemicalUseStaging table from ALL_vw ';

      INSERT INTO ChemicalUseStaging (chemical_nm, use_nm)
      SELECT DISTINCT chemical_nm, use_nm
      FROM ALL_vw
      WHERE chemical_nm IS NOT NULL AND use_nm IS NOT NULL
      ORDER BY chemical_nm, use_nm;

      --------------------------------------------------------------------------------
      -- POSTECONDITION checks
      --------------------------------------------------------------------------------
      -- Chk POST01: ProductUse table populated
      EXEC sp_assert_tbl_pop 'ChemicalUseStaging';
   END TRY
   BEGIN CATCH
      SET @error_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '50: Caught exception: ', @error_msg;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '99: leaving OK';
   RETURN @RC;
END
/*
EXEC sp_pop_ChemicalUseStaging
SELECT * FROM ChemicalUseStaging
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===================================================
-- Author:      Terry Watts
-- Create date: 17-JUL-2023
-- Description: List the Companies in Staging2
--    look for duplicates and misspellings and errors
-- ===================================================
CREATE   FUNCTION [dbo].[fnListS2Companies]()
RETURNS
@t TABLE (company VARCHAR(250))
AS
BEGIN
   INSERT INTO @t
   SELECT DISTINCT TOP 10000 company
   FROM Staging2
   ORDER BY company;

   RETURN;
END
/*
SELECT company from dbo.fnListS2Companies();
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===================================================================
-- Author:      Terry Watts
-- Create Date: 05-FEB-2024
-- Description: Asserts that the given table does not have any rows
-- ===================================================================
CREATE PROCEDURE [dbo].[sp_assert_tbl_not_pop]
    @table           VARCHAR(60)
   ,@msg0            VARCHAR(MAX)   = NULL
   ,@msg1            VARCHAR(MAX)   = NULL
   ,@msg2            VARCHAR(MAX)   = NULL
   ,@msg3            VARCHAR(MAX)   = NULL
   ,@msg4            VARCHAR(MAX)   = NULL
   ,@msg5            VARCHAR(MAX)   = NULL
   ,@msg6            VARCHAR(MAX)   = NULL
   ,@msg7            VARCHAR(MAX)   = NULL
   ,@msg8            VARCHAR(MAX)   = NULL
   ,@msg9            VARCHAR(MAX)   = NULL
   ,@msg10           VARCHAR(MAX)   = NULL
   ,@msg11           VARCHAR(MAX)   = NULL
   ,@msg12           VARCHAR(MAX)   = NULL
   ,@msg13           VARCHAR(MAX)   = NULL
   ,@msg14           VARCHAR(MAX)   = NULL
   ,@msg15           VARCHAR(MAX)   = NULL
   ,@msg16           VARCHAR(MAX)   = NULL
   ,@msg17           VARCHAR(MAX)   = NULL
   ,@msg18           VARCHAR(MAX)   = NULL
   ,@display_msgs    BIT            = 0
   ,@exp_cnt         INT            = NULL
   ,@ex_num          INT            = 56687
   ,@ex_msg          VARCHAR(500)   = NULL
   ,@fn_             VARCHAR(35)    = N'*'
   ,@log_level       INT            = 0
   ,@display_row_cnt BIT            = 1
AS
BEGIN
   DECLARE
    @fn        VARCHAR(35)    = N'sp_assert_tbl_not_pop'

   EXEC sp_assert_tbl_pop
       @table
      ,@msg0  = 'sp_assert_tbl_not_po'
      ,@msg1  = @msg0 
      ,@msg2  = @msg1 
      ,@msg3  = @msg2 
      ,@msg4  = @msg3 
      ,@msg5  = @msg4 
      ,@msg6  = @msg5 
      ,@msg7  = @msg6 
      ,@msg8  = @msg7 
      ,@msg9  = @msg8 
      ,@msg10 = @msg9 
      ,@msg11 = @msg10
      ,@msg12 = @msg11
      ,@msg13 = @msg12
      ,@msg14 = @msg13
      ,@msg15 = @msg14
      ,@msg16 = @msg15
      ,@msg17 = @msg16
      ,@msg18 = @msg17
--      ,@msg19 = @msg18
      ,@exp_cnt =0
      ,@log_level=@log_level
      ,@display_row_cnt=@display_row_cnt;
END
/*
EXEC tSQLt.Run 'test.test_004_sp_chk_tbl_not_pop';
TRUNCATE TABLE AppLog;
EXEC test_sp_chk_tbl_not_pop 'AppLog'; -- ok no rows
INSERT iNTO AppLog ()
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ChemicalProductStaging](
	[chemical_nm] [varchar](100) NULL,
	[product_nm] [varchar](50) NULL,
 CONSTRAINT [IX_ChemicalProductStaging] UNIQUE NONCLUSTERED 
(
	[chemical_nm] ASC,
	[product_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ProductUseStaging](
	[product_nm] [varchar](50) NULL,
	[use_nm] [varchar](50) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ProductCompanyStaging](
	[product_nm] [varchar](50) NULL,
	[company_nm] [varchar](100) NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ProductStaging](
	[product_nm] [varchar](50) NOT NULL,
 CONSTRAINT [PK_ProductStaging] PRIMARY KEY CLUSTERED 
(
	[product_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[PathogenChemicalStaging](
	[pathogen_nm] [varchar](200) NULL,
	[chemical_nm] [varchar](100) NULL
) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_PathogenChemicalStaging_chemical_nm] ON [dbo].[PathogenChemicalStaging]
(
	[chemical_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED COLUMNSTORE INDEX [UQ_PathogenChemicalStaging] ON [dbo].[PathogenChemicalStaging]
(
	[pathogen_nm],
	[chemical_nm]
)WITH (DROP_EXISTING = OFF, COMPRESSION_DELAY = 0, DATA_COMPRESSION = COLUMNSTORE) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =========================================================================
-- Author:      Terry watts
-- Create date: 28-OCT-2024
-- Description: checks the field @field in table @table has no null entries
-- =========================================================================
CREATE   PROCEDURE [dbo].[sp_check_field_not_null]
    @table VARCHAR(60)
   ,@field VARCHAR(60)
AS
BEGIN
   DECLARE @sql VARCHAR(MAX)
   SET NOCOUNT ON;

   SET @sql = CONCAT('IF EXISTS (SELECT 1 FROM [', @table, '] WHERE [',@field,'] IS NULL OR [',@field,'] IS NULL) EXEC sp_raise_exception 53621,  ''', @table, '.', @field,' has a null entry;'';');
   --PRINT @sql
   EXEC( @sql);
END
/*
EXEC tSQLt.RunAll;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==================================================================================================================================================
-- Author:      Terry Watts
-- Create date: 28-OCT-2024
-- Description: validates sp_pop_staging_tables postconditions
--
-- POSTCONDITIONS
-- POST 01: ActionStaging populated
-- POST 02: ChemicalActionStaging populated
-- POST 03: ChemicalProductStaging populated
-- POST 04: ChemicalStaging populated
-- POST 05: ChemicalUseStaging populated
-- POST 06: CompanyStaging populated
-- POST 07: CropPathogenStaging populated
-- POST 08: CropStaging populated
-- POST 09: DistributorStaging populated
-- POST 10: MosaicVirusStaging
-- POST 11: PathogenChemicalStaging populated
-- POST 12: PathogenStaging populated
-- POST 13: PathogenTypeStaging populated
-- POST 14: ProductCompanyStaging populated
-- POST 15: ProductStaging populated
-- POST 16: ProductUseStaging populated
-- POST 17: TypeStaging populated
-- POST 18: UseStaging populated
--
-- TESTS:
--
-- CHANGES:
-- ==================================================================================================================================================
CREATE   PROCEDURE [dbo].[sp_pop_dyn_dta_post_chks]
AS
BEGIN
   SET NOCOUNT OFF;

   DECLARE 
       @fn        VARCHAR(30)  = N'pop_dyn_dta_post_chks'
      ,@error_msg VARCHAR(MAX)  = NULL
      ,@file_path VARCHAR(MAX)
      ,@id        INT = 1

   BEGIN TRY
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'000: starting, running postcondition validation checks';
      -----------------------------------------------------------------------------------
      -----------------------------------------------------------------------------------
      -- 1 Tables are populated
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '210: POSTCONDITION checks   ';
      EXEC dbo.sp_assert_tbl_pop 'ActionStaging';
      EXEC dbo.sp_assert_tbl_pop 'ChemicalStaging';
      EXEC dbo.sp_assert_tbl_pop 'ChemicalActionStaging';
      EXEC dbo.sp_assert_tbl_pop 'ChemicalProductStaging';
      EXEC dbo.sp_assert_tbl_pop 'ChemicalUseStaging';
      EXEC dbo.sp_assert_tbl_pop 'CompanyStaging';
      EXEC dbo.sp_assert_tbl_pop 'CropPathogenStaging';
      EXEC dbo.sp_assert_tbl_pop 'CropStaging';
      EXEC dbo.sp_assert_tbl_pop 'DistributorStaging';
      EXEC dbo.sp_assert_tbl_pop 'MosaicVirusStaging';
      EXEC dbo.sp_assert_tbl_pop 'PathogenChemicalStaging';
      EXEC dbo.sp_assert_tbl_pop 'PathogenStaging';
      EXEC dbo.sp_assert_tbl_pop 'PathogenTypeStaging';
      EXEC dbo.sp_assert_tbl_pop 'ProductCompanyStaging';
      EXEC dbo.sp_assert_tbl_pop 'ProductStaging';
      EXEC dbo.sp_assert_tbl_pop 'ProductUseStaging';
      EXEC dbo.sp_assert_tbl_pop 'TypeStaging';
      EXEC dbo.sp_assert_tbl_pop 'UseStaging';

      -----------------------------------------------------------------------------------
      -- Detailed checks
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'200: detailed checks';
      EXEC sp_log 2, @fn,'205: ActionStaging';
      EXEC sp_check_field_not_null 'ActionStaging','action_id';
      EXEC sp_check_field_not_null 'ActionStaging','action_nm';
      EXEC sp_log 2, @fn,'210: ChemicalStaging';
      EXEC sp_check_field_not_null 'ChemicalStaging','chemical_nm';
      EXEC sp_log 2, @fn,'215: ProductStaging';
      EXEC sp_check_field_not_null 'ProductStaging','product_nm';
      EXEC sp_log 2, @fn,'220: TypeStaging';
      EXEC sp_check_field_not_null 'TypeStaging','type_id';
      EXEC sp_check_field_not_null 'TypeStaging','type_nm';
      EXEC sp_log 2, @fn,'225: UseStaging';
      EXEC sp_check_field_not_null 'UseStaging','use_id';
      EXEC sp_check_field_not_null 'UseStaging','use_nm';
      EXEC sp_log 2, @fn,'230: ChemicalActionStaging';
      EXEC sp_check_field_not_null 'ChemicalActionStaging','chemical_nm';
      EXEC sp_check_field_not_null 'ChemicalActionStaging','action_nm';
      EXEC sp_log 2, @fn,'235: CompanyStaging';
      EXEC sp_check_field_not_null 'CompanyStaging','company_nm';
      EXEC sp_log 2, @fn,'240: CropStaging';
      EXEC sp_check_field_not_null 'CropStaging','crop_nm';

      EXEC sp_log 2, @fn,'245: DistributorStaging';
      EXEC sp_check_field_not_null 'DistributorStaging','distributor_id';
      EXEC sp_check_field_not_null 'DistributorStaging','distributor_nm';
      EXEC sp_check_field_not_null 'DistributorStaging','region';
      EXEC sp_check_field_not_null 'DistributorStaging','province';
      EXEC sp_check_field_not_null 'DistributorStaging','address';
      --EXEC sp_check_field_not_null 'DistributorStaging','manufacturers';

      EXEC sp_log 2, @fn,'250: PathogenStaging';
      EXEC sp_check_field_not_null 'PathogenStaging','pathogen_nm';
      EXEC sp_check_field_not_null 'PathogenStaging','pathogenType_nm';
      EXEC sp_log 2, @fn,'255: PathogenTypeStaging';
      EXEC sp_check_field_not_null 'PathogenTypeStaging','pathogenType_id';
      EXEC sp_check_field_not_null 'PathogenTypeStaging','pathogenType_nm';

      EXEC sp_log 2, @fn,'260: ChemicalProductStaging';
      EXEC sp_check_field_not_null 'ChemicalProductStaging','chemical_nm';
      EXEC sp_check_field_not_null 'ChemicalProductStaging','product_nm';

      EXEC sp_log 2, @fn,'265: ChemicalUseStaging';
      EXEC sp_check_field_not_null 'ChemicalUseStaging','chemical_nm';
      EXEC sp_check_field_not_null 'ChemicalUseStaging','use_nm';

      EXEC sp_log 2, @fn,'270: CropPathogenStaging';
      EXEC sp_check_field_not_null 'CropPathogenStaging','crop_nm';
      EXEC sp_check_field_not_null 'CropPathogenStaging','pathogen_nm';

      EXEC sp_log 2, @fn,'280: PathogenChemicalStaging';
      EXEC sp_check_field_not_null 'PathogenChemicalStaging','pathogen_nm';
      EXEC sp_check_field_not_null 'PathogenChemicalStaging','chemical_nm';

      EXEC sp_log 2, @fn,'285: ProductCompanyStaging';
      EXEC sp_check_field_not_null 'ProductCompanyStaging','product_nm';
      EXEC sp_check_field_not_null 'ProductCompanyStaging','company_nm';

      EXEC sp_log 2, @fn,'290: ProductUseStaging';
      EXEC sp_check_field_not_null 'ProductUseStaging','product_nm';
      EXEC sp_check_field_not_null 'ProductUseStaging','use_nm';

      IF EXISTS (SELECT 1 FROM ChemicalStaging         WHERE chemical_nm IS NULL)                        SELECT * FROM ChemicalStaging          WHERE chemical_nm IS NULL;
      IF EXISTS (SELECT 1 FROM ChemicalActionStaging   WHERE chemical_nm IS NULL OR action_nm IS NULL)   SELECT * FROM ChemicalActionStaging    WHERE chemical_nm IS NULL OR action_nm IS NULL
      IF EXISTS (SELECT 1 FROM ChemicalProductStaging  WHERE chemical_nm IS NULL OR product_nm IS NULL)  SELECT * FROM ChemicalProductStaging   WHERE chemical_nm IS NULL OR product_nm IS NULL
      IF EXISTS (SELECT 1 FROM ChemicalUseStaging      WHERE chemical_nm IS NULL OR use_nm IS NULL)      SELECT * FROM ChemicalUseStaging       WHERE chemical_nm IS NULL OR use_nm IS NULL
      IF EXISTS (SELECT 1 FROM CompanyStaging          WHERE company_nm IS NULL)                         SELECT * FROM CompanyStaging           WHERE company_nm IS NULL
      IF EXISTS (SELECT 1 FROM MosaicVirusStaging      WHERE species IS NULL OR crops IS NULL)           SELECT * FROM MosaicVirusStaging       WHERE species IS NULL OR crops IS NULL
      IF EXISTS (SELECT 1 FROM PathogenChemicalStaging WHERE pathogen_nm IS NULL OR chemical_nm IS NULL) SELECT * FROM PathogenChemicalStaging  WHERE pathogen_nm IS NULL OR chemical_nm IS NULL
      IF EXISTS (SELECT 1 FROM ProductStaging          WHERE product_nm IS NULL)                         SELECT * FROM ProductStaging           WHERE product_nm IS NULL
      IF EXISTS (SELECT 1 FROM ProductCompanyStaging   WHERE product_nm IS NULL OR company_nm IS NULL)   SELECT * FROM ProductCompanyStaging    WHERE product_nm IS NULL OR company_nm IS NULL
      IF EXISTS (SELECT 1 FROM ProductUseStaging       WHERE product_nm IS NULL OR use_nm IS NULL)       SELECT * FROM ProductUseStaging        WHERE product_nm IS NULL OR use_nm IS NULL

      -----------------------------------------------------------------------------------
      -- 23: Completed processing OK
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '400: Completed processing OK';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving: OK';
END
/*
EXEC sp_pop_dyn_dta_post_chks;
EXEC sp_check_field_not_null 'ActionStaging','action_id';
SELECT CONCAT('EXEC sp_check_field_not_null ''',c.TABLE_NAME,''',''',COLUMN_NAME,''';')  
FROM INFORMATION_SCHEMA.COLUMNS c
JOIN list_tables_vw  tv ON c.TABLE_NAME = tv.TABLE_NAME
WHERE c.TABLE_NAME LIKE '%staging' AND c.TABLE_NAME NOT IN ('ImportCorrectionsStaging','MosaicVirusStaging') order by c.TABLE_NAME,ordinal_position;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================================
-- Author:      Terry Watts
-- Create date: 09-FEB-2024
-- Description:  deletes the table and logs the deletion
--
-- PRECONDITIONS:
--
-- POSTCONDITIONS:
-- =================================================================
CREATE   PROCEDURE [dbo].[sp_delete_table]
   @table VARCHAR(60)
AS
BEGIN
   DECLARE
       @fn     VARCHAR(35)   = 'DELETE_TABLE'
      ,@sql    VARCHAR(max)

   SET NOCOUNT ON;

   BEGIN TRY
      SET @sql = CONCAT('DELETE FROM ', @table, ';');
      EXEC (@sql);
      EXEC sp_log 1, @fn, '10: deleted ', @@ROWCOUNT, ' rows from the ', @table, ' table';
   END TRY
   BEGIN CATCH
      DECLARE @msg VARCHAR(35);
      SET @msg = Ut.dbo.fnGetErrorMsg();
      SET @msg = CONCAT('Error deleting rows from the ', @table,' ', @msg);
      EXEC sp_log 4, @fn, @msg;
      THROW 69403, @msg, 1;
   END CATCH
END
/*
   EXEC sp_delete_table 'ChemicalUseStaging';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[CropPathogenStaging](
	[crop_nm] [varchar](100) NULL,
	[pathogen_nm] [varchar](100) NULL
) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE UNIQUE NONCLUSTERED INDEX [IX_CropPathogenStaging] ON [dbo].[CropPathogenStaging]
(
	[crop_nm] ASC,
	[pathogen_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==================================================================================================================================================================
-- Routine:     dbo.sp_pop_staging_tables
-- Author:      Terry Watts
-- Create date: 25-AUG-2023
-- Description: clears out the staging tables in order
--
-- Called by: sp_main_import_stage_6, sp_main_import
--
-- RESPONSIBILITIES:
--    ChemicalStaging'          -- 01
--    ChemicalActionStaging'    -- 02
--    ChemicalProductStaging'   -- 03
--    ChemicalUseStaging'       -- 04
--    CompanyStaging'           -- 05
--    ImportCorrectionsStaging' -- 06
--    PathogenChemicalStaging'  -- 07
--    ProductStaging'           -- 08
--    ProductCompanyStaging'    -- 09
--    ProductUseStaging'        -- 10
--
-- PRECONDITIONS:
-- ActionStaging        populated
-- CropStaging          populated
-- CropPathogenStaging  populated
-- DistributorStaging   populated
-- Import               populated
-- PathogenStaging      populated
-- PathogenTypeStaging  populated
-- Staging2             populated
-- TableDef             populated
-- TableType            populated
-- TypeStaging          populated
-- UseStaging           populated
--
-- POSTCONDITIONS: ALL staging tables are populated:
-- (checks are delegated to sp_pop_dynamic_data_postcondition_checks)
-- POST 01: ChemicalStaging'            populated-- 01
-- POST 02: ChemicalActionStaging'      populated-- 02
-- POST 03: ChemicalProductStaging'     populated-- 03
-- POST 04: ChemicalUseStaging'         populated-- 04
-- POST 05: CompanyStaging'             populated-- 05
-- POST 06: ImportCorrectionsStaging'   populated-- 06
-- POST 07: PathogenChemicalStaging'    populated-- 07
-- POST 08: ProductStaging'             populated-- 08
-- POST 09: ProductCompanyStaging'      populated-- 09
-- POST 10: ProductUseStaging'          populated-- 10
--
-- TESTS:
--
-- CALLED BY: sp_main_import_stage_07_pop_stging
--
-- CHANGES:
-- 231007: fix: Violation of PRIMARY KEY constraint 'PK_ChemicalProductStaging'. Cannot insert duplicate key in object 'dbo.ChemicalProductStaging'.
-- 231008: added company nm info to the product staging table
-- 231013: added PRE 01: import_id must be passed as a parameter or be part of the session context
--         made @import_id a parameter for ease of testing
-- 231014: changed name from sp_pop_normalised_tables to sp_pop_normalised_staging_tables
--         added order by clause to INSERT INTO PathogenStaging(pathogen_nm, import_id) SELECT pathogen, @import_id from dbo.fnListPathogens()
-- 231104: added PathogenChemicalStaging
-- 240124: removed import id parameter - this is common accross all import staging tables
-- 240209: tidy up and refactor to valid postconditions at end.
-- ==================================================================================================================================================================
CREATE PROCEDURE [dbo].[sp_pop_dynamic_data]
AS
BEGIN
   SET NOCOUNT OFF;
   DECLARE
       @fn        VARCHAR(30)   = 'sp_pop_dynamic_data'
      ,@error_msg VARCHAR(MAX)  = NULL
      ,@file_path VARCHAR(MAX)

   BEGIN TRY
      EXEC sp_log 2, @fn, '000: starting, chking preconditions';
      EXEC sp_assert_tbl_pop 'ActionStaging';
      EXEC sp_assert_tbl_pop 'CropStaging';
      EXEC sp_assert_tbl_pop 'DistributorStaging';
      EXEC sp_assert_tbl_pop 'Import';
      EXEC sp_assert_tbl_pop 'PathogenStaging';
      EXEC sp_assert_tbl_pop 'PathogenTypeStaging';
      EXEC sp_assert_tbl_pop 'Staging2';
      EXEC sp_assert_tbl_pop 'TableDef';
      EXEC sp_assert_tbl_pop 'TypeStaging';
      EXEC sp_assert_tbl_pop 'UseStaging';

      ---------------------------------------------------------------------------------
      -- ASSERTION: ActionStaging, UseStaging, PathogenTypeStaging tables imported
      ---------------------------------------------------------------------------------

      ---------------------------------------------------------------------------------
      --Clear out old data now, dependencies first
      ---------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '010: deleting all rows from all the staging tables';

      -- Dependencies first
      EXEC sp_delete_table ChemicalStaging;           -- 01
      EXEC sp_delete_table ChemicalActionStaging;     -- 02
      EXEC sp_delete_table ChemicalProductStaging;    -- 03
      EXEC sp_delete_table ChemicalUseStaging;        -- 04
      EXEC sp_delete_table CompanyStaging    ;        -- 05
      EXEC sp_delete_table CropPathogenStaging;       -- 05
      EXEC sp_delete_table ImportCorrectionsStaging;  -- 06
      EXEC sp_delete_table PathogenChemicalStaging;   -- 08
      EXEC sp_delete_table ProductStaging       ;     -- 09
      EXEC sp_delete_table ProductCompanyStaging;     -- 10
      EXEC sp_delete_table ProductUseStaging;         -- 11

      ---------------------------------------------------------------------------------
      -- Assertion: all staging tables cleared
      ---------------------------------------------------------------------------------
      EXEC sp_assert_tbl_not_pop 'ChemicalStaging';         -- 01
      EXEC sp_assert_tbl_not_pop 'ChemicalActionStaging';   -- 02
      EXEC sp_assert_tbl_not_pop 'ChemicalProductStaging';  -- 03
      EXEC sp_assert_tbl_not_pop 'ChemicalUseStaging';      -- 04
      EXEC sp_assert_tbl_not_pop 'CompanyStaging';          -- 05
      EXEC sp_assert_tbl_not_pop 'CropPathogenStaging';     -- 05
      EXEC sp_assert_tbl_not_pop 'ImportCorrectionsStaging';-- 06
      EXEC sp_assert_tbl_not_pop 'PathogenChemicalStaging'; -- 08
      EXEC sp_assert_tbl_not_pop 'ProductStaging';          -- 09
      EXEC sp_assert_tbl_not_pop 'ProductCompanyStaging';   -- 10
      EXEC sp_assert_tbl_not_pop 'ProductUseStaging';       -- 11

      ---------------------------------------------------------------------------------
      -- Populate the normalised primary staging tables
      ---------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '020: Populate the normalised primary staging tables';

      ---------------------------------------------------------------------------------
      -- Pop ChemicalStaging table
      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: Pop ChemicalStaging table';
      INSERT INTO ChemicalStaging(chemical_nm)
      SELECT DISTINCT cs.value as chemical
      FROM Staging2 s CROSS APPLY string_split(ingredient,'+') cs
      ORDER BY cs.value;

      EXEC sp_assert_tbl_pop 'dbo.ChemicalStaging'
      ---------------------------------------------------------------------------------
      -- Pop CompanyStaging table
      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '040: Pop CompanyStaging table';
      INSERT INTO CompanyStaging(company_nm) 
      SELECT company FROM dbo.fnListS2Companies();

      ---------------------------------------------------------------------------------
      -- Pop ProductStaging table
      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '050: Pop ProductStaging table from the S2 info';
      INSERT INTO ProductStaging(product_nm) SELECT distinct product From staging2 WHERE product IS NOT NULL ORDER by product;

       --------------------------------------------------------------------------------
       -- Populate the staging link tables
      ---------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '060: Populate the staging link tables';

      ---------------------------------------------------------------------------------
      -- Pop PathogenChemicalStaging table from LRAP data
      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '070: Pop PathogenChemicalStaging staging table';
      INSERT INTO PathogenChemicalStaging (pathogen_nm, chemical_nm)
      SELECT distinct top 10000 pathogen_nm, chemical_nm
      FROM all_vw
      WHERE pathogen_nm <> ''
      ORDER BY pathogen_nm, chemical_nm;

     --  CropPathogenStaging
      EXEC sp_log 1, @fn, '80: Pop CropPathogenStaging staging table';
      INSERT INTO CropPathogenStaging(crop_nm,pathogen_nm)
      SELECT DISTINCT
crop_nm, pathogen_nm
FROM all_vw
WHERE crop_nm IS NOT NULL AND crop_nm not in ('','-')
AND dbo.fnLen(crop_nm) < 35
AND dbo.fnLen(pathogen_nm) < 50
AND crop_nm NOT LIKE '(%'
AND crop_nm NOT LIKE 'As %'
AND pathogen_nm IS NOT NULL AND pathogen_nm not in ('','-','and wheat')
AND pathogen_nm NOT LIKE 'As %'
ORDER BY crop_nm, pathogen_nm
;

--SELECT MAX( dbo.fnLen(pathogen_nm)) FROM Pathogen

      ---------------------------------------------------------------------------------
      -- 08: POP the ChemicalActionStaging table
      -- dependencies: ActionStaging, ChemicalStaging

      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '090: chking sp_pop_ChemicalActionStaging dependencies';
      EXEC sp_assert_tbl_pop 'ActionStaging';
      EXEC sp_assert_tbl_pop 'ChemicalStaging';
      EXEC sp_log 1, @fn, '100: calling sp_pop_ChemicalActionStaging';

      EXEC sp_pop_ChemicalActionStaging;

      ---------------------------------------------------------------------------------
      -- 09: Pop the ChemicalProductStaging table - 231005: added nm fields for ease of merging
      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '110: Pop ChemicalProductStaging table';
     -- 231007 fix: Violation of PRIMARY KEY constraint 'PK_ChemicalProductStaging'. Cannot insert duplicate key in object 'dbo.ChemicalProductStaging'.
      INSERT INTO ChemicalProductStaging(chemical_nm, product_nm)
      SELECT distinct chemical_nm, product_nm
      FROM all_vw;
      EXEC sp_assert_tbl_pop 'ChemicalProductStaging';

      ---------------------------------------------------------------------------------
      -- 10: Pop the ChemicalUseStaging table
      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '120: Pop ChemicalUseStaging table, calling sp_pop_chemical_use_staging';
      EXEC sp_pop_ChemicalUseStaging;

      -- 231008:
      ---------------------------------------------------------------------------------
      -- 11: Pop ProductCompanyStaging table
      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '130: Pop ProductCompanyStaging table';
      INSERT INTO ProductCompanyStaging (product_nm, company_nm)
      SELECT distinct product_nm, company
      FROM all_vw;

      ---------------------------------------------------------------------------------
      -- 12: Pop ProductUseStaging table ids
      ---------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '140: pop ProductUseStaging table';
      INSERT INTO ProductUseStaging (product_nm, use_nm)
      SELECT distinct product_nm, use_nm
      FROM all_vw
      ORDER BY product_nm, use_nm ASC;

     ---------------------------------------------------------------------------------
      -- 16: Validate postconditions - ALL staging tables populated
      ---------------------------------------------------------------------------------
      -- POST 01: ActionStaging populated
      -- POST 02: ChemicalActionStaging populated
      -- POST 03: ChemicalProductStaging populated
      -- POST 04: ChemicalStaging populated
      -- POST 05: ChemicalUseStaging populated
      -- POST 06: CompanyStaging populated
      -- POST 07: CropPathogenStaging populated
      -- POST 08: CropStaging populated
      -- POST 09: DistributorStaging populated
      -- POST 10: PathogenChemicalStaging populated
      -- POST 11: PathogenStaging populated
      -- POST 12: PathogenTypeStaging populated
      -- POST 13: ProductCompanyStaging populated
      -- POST 14: ProductStaging populated
      -- POST 15: ProductUseStaging populated
      -- POST 16: TypeStaging populated
      -- POST 17: UseStaging populated--

      -----------------------------------------------------------------------------------
      -- Populate the staging tables post condition check
      -----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '300: table population completed checking postconditions';
      EXEC sp_pop_dyn_dta_post_chks;     -- Post condition chk
      EXEC sp_log 2, @fn, '310: postcondition checks complete';

      ---------------------------------------------------------------------------------
      -- COMPLETED PROCESSING
      ---------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,  '800: completed processing OK';
   END TRY
   BEGIN CATCH
      SET @error_msg = Ut.dbo.fnGetErrorMsg();
      EXEC sp_log 4, @fn, '500: Caught exception: ', @error_msg;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving OK';
END
/*
EXEC tsqlt.Run 'test.test_098_sp_pop_dynamic_data';
EXEC sp_pop_dynamic_data;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===================================================================================
-- Author:      Terry Watts
-- Create date: 05-Oct-20243
-- Description: gets the import type id for a given LRAP import - xls or tsv
-- ===================================================================================
CREATE PROCEDURE [dbo].[sp_get_LRAP_import_type]
    @import_file  VARCHAR(500)
   ,@import_id    INT            OUT
AS
BEGIN
   DECLARE
       @fields    VARCHAR(4000) = NULL
      ,@fn        VARCHAR(50)   = 'sp_get_LRAP_import_type'
      ,@file_type BIT

   SET NOCOUNT OFF;

   EXEC sp_log 2, @fn,'000: starting
   import_file:[',@import_file,']';

   EXEC sp_get_flds_frm_hdr_txt
       @file      = @import_file
      ,@fields    = @fields    OUT
      ,@file_type = @file_type OUT
   ;

   SET @fields = LOWER(RTRIM(@fields, ','));
   PRINT @fields;

   SET @import_id =
   CASE 
   WHEN @fields = 'id,company,ingredient,product,concentration,formulation_type,uses,toxicity_category,registration,expiry,entry_mode,crops,pathogens'
      THEN 1
   WHEN @fields = 'id,name of company,active ingredient,product name,concentration,formulation type,use/s,toxicity category,registration no.,expiry date,mode of entry,crops,pests / weeds / diseases'
      THEN 1
   WHEN @fields = 'id,company,active ingredient,product name,concentration,formltn ty,uses,tox cat,registration no.,expiry date,mode of entry,crops,pathogens,recommended rate,mrl,phi,re-entry period'
      THEN 2
   WHEN @fields = 'id,name of company,active ingredient,product name,concentration,formulation type,use/s,toxicity category,registration no.,expiry date,mode of entry,crops,pests / weeds / diseases,recommended rate,mrl (proposed),phi,re-entry period'
      THEN 3
   WHEN @fields = 'id,name of company,active ingredient,product name,concentration,formltn ty,use/s,toxicity category,registration no.,expiry date,mode of entry,crops,pests / weeds / diseases,recommended rate,mrl,phi,re-entry period'
      THEN 3
   WHEN @fields = 'id,name of company,active ingredient,product name,concentration,formulation type,use/s,toxicity category,registration no.,expiry date,mode of entry,crops,pests / weeds / diseases,recommended rate,mrl (proposed),phi,re-entry period'
      THEN 3
   ELSE -1
   END

   EXEC sp_log 1, @fn, '999: leaving, import_id = ', @import_id;
END
/*
ID,NAME OF COMPANY,ACTIVE INGREDIENT,PRODUCT NAME,CONCENTRATION,FORMLTN TY,USE/S,TOXICITY CATEGORY,REGISTRATION NO.,EXPIRY DATE,MODE OF ENTRY,CROPS,PESTS / WEEDS / DISEASES,RECOMMENDED RATE,MRL,PHI,RE-ENTRY PERIOD

   EXEC tSQLt.Run 'test.test_087_sp_get_LRAP_import_type';
   EXEC tSQLt.RunAll;

id,COMPANY,INGREDIENT,PRODUCT,CONCENTRATION,FORMULATION_TYPE,USES,TOXICITY_CATEGORY,REGISTRATION,EXPIRY,ENTRY_MODE,CROPS,Pathogens'
id,NAME OF COMPANY,ACTIVE INGREDIENT,PRODUCT NAME,CONCENTRATION,FORMULATION TYPE,USE/S,TOXICITY CATEGORY,REGISTRATION NO.,EXPIRY DATE,MODE OF ENTRY,CROPS,PESTS / WEEDS / DISEASES'
ID,COMPANY,ACTIVE INGREDIENT,PRODUCT NAME,CONCENTRATION,FORMLTN TY,USES,TOX CAT,REGISTRATION NO.,EXPIRY DATE,MODE OF ENTRY,CROPS,Pathogens,RECOMMENDED RATE,MRL,PHI,RE-ENTRY PERIOD'

 'id,NAME OF COMPANY,ACTIVE INGREDIENT,PRODUCT NAME,CONCENTRATION,FORMULATION TYPE,USE/S,TOXICITY CATEGORY,REGISTRATION NO.,EXPIRY DATE,MODE OF ENTRY,CROPS,PESTS / WEEDS / DISEASES,RECOMMENDED RATE,MRL (Proposed),PHI,RE-ENTRY PERIOD'

*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Procedure:   sp_init_state
-- Author:      Terry Watts
-- Create date: 14-FEB-2025
-- Description: initialises the Corfiles table
-- Returns      the count of cor files
-- Design:
-- Tests:
-- PRECONDITIONS:
-- PRE 01: ImportState table pop
-- =============================================
CREATE PROCEDURE [dbo].[sp_init_cor_files]
    @cor_files   VARCHAR(500)   = NULL -- must be specified if stage < 5
   ,@import_root VARCHAR(500)
AS
BEGIN
DECLARE
    @fn VARCHAR(35) = 'sp_init_state'
   ,@cor_file_cnt INT
   ;

   SET NOCOUNT ON;
   EXEC sp_log 1, @fn,'000: starting
cor_files   :[', @cor_files       ,']
import_root :[', @import_root ,']
';

   TRUNCATE TABLE CorFiles;

   -- Chkd preconditions
   EXEC sp_assert_tbl_pop 'ImportState','010', @fn=@fn;
   UPDATE ImportState SET import_root = @import_root;

   INSERT into Corfiles([file])
   SELECT value FROM string_split(@cor_files, ',');
   SET @cor_file_cnt = (SELECT COUNT(*) FROM Corfiles);
   EXEC sp_log 1, @fn,'999: leaving, @cor_file_cnt: ',@cor_file_cnt;

   -- Returns the count of cor files
   RETURN @cor_file_cnt;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_<proc_nm>';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: Raises exception if exp = act
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_not_equal]
    @a         SQL_VARIANT
   ,@b         SQL_VARIANT
   ,@msg       VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT             = NULL
   ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
DECLARE
    @fnThis    VARCHAR(35) = 'sp_assert_not_equal'
   ,@aTxt      VARCHAR(100)= CONVERT(VARCHAR(20), @a)
   ,@bTxt      VARCHAR(100)= CONVERT(VARCHAR(20), @b)
   ,@std_msg   VARCHAR(200)

    EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';

   -- a<>b MEANS a<b OR b<a -> !(!a<b AND !(b<a))
   IF ((dbo.fnIsLessThan(@a ,@b) = 1) OR (dbo.fnIsLessThan(@b ,@a) = 1))
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, [',@aTxt, '] <> [', @bTxt, ']';
      RETURN 0;
   END

   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   --EXEC sp_log 3, @fnThis, '020: [', @aTxt , '] equals [',@bTxt,'], raising exception';
   IF @ex_num IS NULL SET @ex_num = 50003;

   SET @std_msg = CONCAT(@fnThis, ' [', @aTxt , '] equals [',@bTxt,'] ');

   EXEC sp_raise_exception
       @msg1   = @std_msg
      ,@msg2   = @msg
      ,@msg3   = @msg2
      ,@msg4   = @msg3
      ,@msg5   = @msg4
      ,@msg6   = @msg5
      ,@msg7   = @msg6
      ,@msg8   = @msg7
      ,@msg9   = @msg8
      ,@msg10  = @msg9
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@msg20  = @msg19
      ,@ex_num = @ex_num
      ,@fn     = @fn
   ;
END
/*
-- Smoke test 
EXEC sp_assert_not_equal 0, 1, 'Failed: tested routine not qualified'
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_047_sp_assert_not_equal';
EXEC test.sp__crt_tst_rtns '[dbo].[sp_assert_not_equal]'
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================================
-- Author:      Terry Watts
-- Create date: 25-NOV-2023
-- Description: sets the log level
--
-- CHANGES:
-- 241118: return old loglevel in the sp rtn status or 1 if not set
-- =================================================================
CREATE   PROCEDURE [dbo].[sp_set_log_level]
   @level INT
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
       @fn            VARCHAR(50) = 'sp_set_log_level'
      ,@old_log_level INT          = dbo.fnGetLogLevel()
      ,@log_level_key NVARCHAR(50) = dbo.fnGetLogLevelKey()
      ,@msg           VARCHAR(200)
   ;

   EXEC sys.sp_set_session_context @key = @log_level_key, @value = @level;
   SET @msg = CONCAT('sp_set_log_level: 000: Setting logging level from [', @old_log_level,'] TO [',@level,']');
   EXEC sp_log 2, @fn, @msg;
   RETURN COALESCE (@old_log_level, 1);
END
/*
EXEC sp_set_log_level 1;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =================================================================================
-- Author:      Terry Watts
-- Create date: 02-AUG-2023
-- Description: returns the standard session kjey for import root: [Import Root]
-- =================================================================================
CREATE FUNCTION [dbo].[fnGetKeyImportRoot]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Import Root';
END
/*
PRINT CONCAT('[', dbo.fnGetKeyImportRoot(), ']');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ======================================================================================================
-- Author:       Terry Watts
-- Create date:  02-AUG-2023
-- Description:  SETS the session context  [Import Root]
-- ======================================================================================================
CREATE   PROCEDURE [dbo].[sp_set_session_context_import_root]
   @val VARCHAR(450)
AS
BEGIN
   DECLARE @key NVARCHAR(60) = dbo.fnGetKeyImportRoot();
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test_100_fnGetSessionContextImportRoot';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================
-- Author:      Terry Watts
-- Create date: 19-AUG-2023
-- Description: returns the import_id key
-- ==============================================================================
CREATE   FUNCTION [dbo].[fnGetSessionKeyImportId] ()
RETURNS NVARCHAR(30)
AS
BEGIN
   RETURN N'IMPORT_ID';
END
/*
EXEC sp_set_session_context_import_id 240530
PRINT CONCAT('import_id: [', dbo.fnGetSessionValueImportId(),']');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ====================================================
-- Author:       Terry Watts
-- Create date:  19-AUG-2023
-- Description:  SETS the import correction id
-- ====================================================
CREATE   PROCEDURE [dbo].[sp_set_ctx_imp_id]
   @val     INT
AS
BEGIN
   DECLARE @key NVARCHAR(60)
   SET @key = dbo.fnGetSessionKeyImportId();
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC sp_set_ctx_imp_id 35
PRINT CONCAT(dbo.fnGetSessionKeyImportId(), ': [', dbo.fnGetSessionValueImportId(),']');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================================
-- Procedudure: NM:dbo].[sp_mn_imprt_ini
-- Description: main import routine init, set the import state tables
-- Design EA:   Model.Requirements.LRAP import Requirements.Import Initialisation
-- Tests:       EXEC tSQLt.Run 'test.test_099_sp_mn_imprt_ini'
-- AUTHOR:      Terry Watts
-- CREATE DATE: 02-AUG-2023
--
-- Notes: to get the modified parameters query the state tables Importstate and Corfiles
--
-- CALLED BY:   sp_main__import_pesticide_register
--
-- RESPONSIBILITIES:
-- R01: Display the prms
-- R03: Clear tables
--   R03.1: Clear AppLog table
--   R03.2: Clear CorrectionLog table
--   R03.3: Clear S2UpdateLog table
--   R03.4: Clear S2UpdateSummary table
-- R04: Set the log level
-- R05: prefix the root to the import file
--------------------------------------------------------------------------------------------------------------------------------
-- 06: Validation:
--------------------------------------------------------------------------------------------------------------------------------
--       the inputs according to stage
-- R06.1: import root: must be specified/exist if stage < 4 if not raise exception 60001 'R05.1: import root must be specified if stage < 5'
-- R06.3: cor files:   1 or more files must be specified if stage < 5 if not raise exception 60003 'R05.3: 1: or more correction files must be specified if stage < 5'
-- R06.4: start stage: between 0 and 10                     if not raise exception 60004 'R05.4: start_stage must be between 0 and 10'
-- R06.5: stop stage:  between 0 and 10, >= st stg          if not raise exception 60005 'R05.5: stop stage must be between 0 and 10 and be >= start stage'
-- R06.6: start row:   between 0 and 100000                 if not raise exception 60006 'R05.6: start row must be between 0 and 100000'
-- R06.7: stop row:    between 0 and 100000 , >= st row     if not raise exception 60007 'R05.7: stop row must be between 0 and 100000 and be >= start row'
-- R06.8: log level:   between 0 and 4                      if not raise exception 60008 'R05.8: log level must be between 0 and 4'
-- R06.9: import id:   is a numeric LRAP file format identifier. This varies with LRAP release. RANGE: 0 < import_id < 10
--                     if stage < 7                         if not raise exception 60009 'R05.9: import id should be between 1 and 10'
-- R07: imports the CallRegister ASAP
-- R09: Configure routine call control to avoid multiple calls of single call routines
-- R11: Configure routine call control to avoid multiple calls of single call routines
-- R13: Get the import id from the file name
--
-- Preconditions: NONE
--
-- Postconditions:
-- POST 02: R02
-- POST 03: R03
-- POST 06: R06
-- POST 07: Parameter defaults:
--    @start_row      1
--    @stop_row       100000
--
-- Process for LRAP Import and scrub:
-------------------------------------------------------------------------------------------------------
-- Stage                                               Preconditions
-------------------------------------------------------------------------------------------------------
-- 01: Initialize (mandatory)                          none
-- 02: Import primary static data                      import_root specified
-- 03: Import the LRAP data                            import_root specified, LRAP file specified
-- 04: Do the S1 fixup                                 s1 pop
-- 05: Stage 5: Copy S1 to S2                          LRAP file imported
-- 06: Import the LRAP corrections files               cor files specified
-- 07: optionally restore s2 from S1 or S3 caches      none
-- 08: Scrub the imported LRAP fixup S2                Import corrections tbl pop
-- 09: Populate the dynamic data staging tables        fixup done
-- 10: Indentify the unmatched dynamic staging data    fixup done
-- 11: Copy S2 to the S3 cache                         LRAP file imported
-- 12: Merge Staging to Main                           fixup done
-- 13: Perform postcondition checks                    none
-------------------------------------------------------------------------------------------------------
-- CHANGES:
-- 230811: Clean import then merge into the main tables, save the import_id as a session setting in import-init
-- 231013: Override @import_id if supplied
-- 231014: ADDED POST Condition CHKS: import_id NOT NULL AND > 0
--         Added support of table logging: clear the table before the main procedure starts
-- 231108: removed params: @import_root which is now supplied to the main fn with a default
-- 240207: added call to sp_clear_call_register to clear the routine call register table
-- 240309: moved the tuncate applog to main as we dont get any logging of main import right now
-- 240323: added sp_write_results_to_cor_file validation now so as to waste time processing if bad p
-- ======================================================================================================
CREATE PROCEDURE [dbo].[sp_mn_imprt_ini]
    @import_root     VARCHAR(450)
   ,@import_file     VARCHAR(150)    -- LRAP import file
   ,@cor_files       VARCHAR(500)   = NULL -- must be specified if stage < 5
   ,@start_stage     INT            --= 0
   ,@stop_stage      INT            --= 100
   ,@start_row       INT            --= 1
   ,@stop_row        INT            --= 100000
   ,@restore_s1_s2   BIT            = 0      -- Reset the state of Staging2 to the original LRAP import - useful when testing corrections
   ,@restore_s3_s2   BIT            = 0      -- Reset the state of Staging2 to the Fixed up version of S2 before the Corrections process
   ,@log_level       INT            = 1
   ,@import_eppo     BIT            = 0
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)   = N'sp_mn_imprt_ini'
   ,@msg             VARCHAR(500)  = ''
   ,@ndx             INT
   ,@import_id_cpy   INT
   ,@imp_file        VARCHAR(500)
   ,@import_id       INT
   ,@file_type       VARCHAR(10)

      SET NOCOUNT OFF
      SET XACT_ABORT ON;

-- R01: display the prms
    EXEC sp_log 2, @fn,'000: starting:
import_root:   [', @import_root,   ']
import_file:   [', @import_file,   ']
cor_files:     [', @cor_files,     ']
start_stage:   [', @start_stage,   ']
stop_stage:    [', @stop_stage,    ']
start_row:     [', @start_row,     ']
stop_row:      [', @stop_row,      ']
restore_s3_s2: [', @restore_s3_s2, ']
log_level:     [', @log_level,     ']
';


   BEGIN TRY
      --********************************************************************************
      -- Set defaults:
      --********************************************************************************
      EXEC sp_log 1, @fn, '010: setting defaults';

      IF @import_root IS NULL SET @import_root = 'D:\Dev\Farming\Data';
      IF @start_row   IS NULL SET @start_row   = 1;
      IF @stop_row    IS NULL SET @stop_row    = 100000

      --********************************************************************************
      -- Validation
      --********************************************************************************
      EXEC sp_log 1, @fn, '020: validating preconditions';

      IF @start_stage NOT BETWEEN 0 AND 13      EXEC sp_raise_exception 50005, 'start_stage must be between 0 and 13';
      IF @stop_stage  NOT BETWEEN 0 AND 13      EXEC sp_raise_exception 50006, 'stop_stage must be between 0 and 13';
      IF @start_row   NOT BETWEEN 0 AND 1000000 EXEC sp_raise_exception 50005, 'start_row must be between 1 and 1000000';
      IF @stop_row    NOT BETWEEN 0 AND 1000000 EXEC sp_raise_exception 50005, '@stop_row must be between 1 and 1000000';

      If @start_stage < 7
      BEGIN
         -- R06.3: if stage < 7 then 1 or more cor files must be specified  if not raise exception 60003 'R05.3: 1: or more correction files must be specified if stage < 5'
         EXEC sp_assert_not_null_or_empty @cor_files, '030: 1 or more cor files must be specified if stage <5', @ex_num=60003, @fn=@fn;
         EXEC sp_log 1, @fn, '040: chk @import_root specified';

         -- POST 07: @file_type set = 'txt' or 'xlsx'  and not null
         EXEC sp_assert_not_null_or_empty @import_root, '101:  @import_root',@fn=@fn;


         -----------------------------------------------------------------------------------
         --R04: prefix the root to the import file
         -----------------------------------------------------------------------------------
         SET @import_file = CONCAT(@import_root, CHAR(92), @import_file);

         -- R05.1 @import_root: must be specified if stage < 5 -- if not raise exception 60001 'R05.1: import root must be specified if stage < 5'
         IF (@import_root IS NULL OR dbo.fnLen(@import_root)=0) AND @start_stage < 5
            EXEC sp_raise_exception 60001, '050: R05.1: import root must be specified if stage < 5', @fn=@fn;

         -- R05.3 @cor_files:   must be specified if stage < 5 -- if not raise exception 60003 @cor_files: must be specified if stage < 5
         IF (@cor_files   IS NULL OR dbo.fnLen(@cor_files)=0) AND @start_stage < 5
            EXEC sp_raise_exception 60003, '060: R05.3: 1 or more correction files must be specified if stage < 5', @fn=@fn;
      END

      -- R06.1: import root: must be specified/exist if stage < 4 if not raise exception 60001 'R05.1: import root must be specified if stage < 5'
      --        if stage < 7                         if not raise exception 60009 'R05.9: import id should be between 1 and 10'
      -- R02: Determine the file type - xlsx or txt if stage < 4
      If @start_stage < 4
      BEGIN
         EXEC sp_assert_not_null_or_empty @import_root, '070: Import root must be specified if stage <4', @fn=@fn;
         EXEC sp_log 1, @fn,'080 getting the LRAP import file type([',@import_file,'])';
         SELECT @file_type = ext
         FROM dbo.fnGetFileDetails(@import_file);

         EXEC sp_log 1, @fn,'090 chk @file_type [',ext,']';
         EXEC sp_assert_not_null_or_empty @file_type, ' 131: @file_type', @fn= @fn;

         -- R03.1: Clear AppLog table - by the end of the ini process AppLog will have about 35 rows - so chk this post condidion now - its the only time it should be true
         -- POST 02: R02
         -----------------------------------------------------------------------------------
         -- Get the import id from the data header
         -- R11: Get the import id from the file name
         -----------------------------------------------------------------------------------
         EXEC sp_log 1, @fn, '100: calling sp_get_LRAP_import_type @import_file:[', @import_file,']';
         EXEC sp_get_LRAP_import_type @import_file, @import_id OUT;
         EXEC sp_log 1, @fn, '110: @import_id: ',@import_id;
         EXEC dbo.sp_assert_not_null @import_id,    '120: @import_id must not be NULL', @ex_num = 58100; 
         EXEC sp_assert_not_equal -1, @import_id, '130: Unrecognised LRAP import file format (',@import_file,')';
         --------------------------------------------------------------------------------------------------------------------------------
         -- R05.9: @import_id: is a numeric LRAP file format identifier. This varies with LRAP release. RANGE: 0 < import_id < 10 
         -- if not raise exception 60009 'R05.9: import id should be between 1 and 10'
         IF (@import_id < 1) OR (@import_id>10) EXEC sp_raise_exception 60009,'140: R05.9: import id should be between 1 and 10', @fn=@fn;
      END
      EXEC sp_log 1, @fn,'150';

      IF @start_stage < 9
      BEGIN
         -- R05.4: start_stage must be between 0 and 10         -- if not raise exception 60004 'R05.4: start_stage must be between 0 and 10'
         IF (@start_stage <0) OR (@start_stage>10) EXEC sp_raise_exception 60004,'170: R05.4: start_stage must be between 0 and 10', @fn=@fn;

         -- R05.5: @stop_stage:  between 0 and 10, >= st stg    -- if not raise exception 60005 'R05.5: stop stage: must be between 0 and 10 and be >= start stage'
         IF (@stop_stage <0) OR (@stop_stage>10) OR (@start_stage > @stop_stage) EXEC sp_raise_exception 60005,'180: R05.5: stop stage: must be between 0 and 10 and be >= start stage', @fn=@fn;

         -- R05.6: start row must be between 0 and 100000 and be >= start row -- if not raise exception 60006 'R05.6: start row must be between 0 and 10000'
         IF (@start_row <0) OR (@start_row>100000) EXEC sp_raise_exception 60006,'190: R05.6: start row must be between 0 and 100000 and be >= start row', @fn=@fn;

         -- R05.7: 'R05.7: stop row must be between 0 and 100000 and be >= start row' - if not raise exception 60006 'R05.7: stop row must be between 0 and 100000 and be >= start row'
         IF (@stop_row < 0) OR (@stop_row > 100000) EXEC sp_raise_exception 60007,'200: R05.7: stop row must be between 0 and 100000 and be >= start row', @fn=@fn;
      END

      -- R05.8 @log_level:   between 0 and 4                -- if not raise exception 60008 'R05.8: @log_level: must be between 0 and 4'
      IF (@log_level <0 ) OR (@log_level >4 )  EXEC sp_raise_exception 60008,'210: R05.8: @log_level: must be between 0 and 4', @fn=@fn;

     -----------------------------------------------------------------------------------
      -- R03: Set the log level
      -----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '220: setting minimum logging level to: ', @log_level, ' mode txt:[',@msg,']';
     --------------------------------------------------------------------------------------------------------------------------------
      -- ASSERTION: Validated parameters
      --------------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '230: ASSERTION: Validated parameters';
      EXEC sp_set_log_level @log_level;-- POST 4: set the min log level

      SET @import_id_cpy = @import_id;

      --------------------------------------------------------------------------------------------
      -- ASSERTION: Validation succeeded
      --------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '240: ASSERTION: Validation succeeded';


      --********************************************************************************
      -- Process
      --********************************************************************************
     -----------------------------------------------------------------------------------
      -- R02: Clear the following tables Clear the results tables
     -----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '250: Clear the results tables: CorrectionLog, S2UpdateLog, S2UpdateSummary';
      -- Disable the staging2 on update trigger
      DISABLE TRIGGER staging2.sp_Staging2_update_trigger ON staging2;
      TRUNCATE TABLE CorFiles;
      TRUNCATE TABLE S2UpdateLog;
      TRUNCATE TABLE S2UpdateSummary;
      TRUNCATE TABLE CorrectionLog;
      -- R03.1: Clear AppLog table
     TRUNCATE TABLE Applog;
     TRUNCATE TABLE ImportState;

      -- ASSERTION: @import_id id known and > 0
      EXEC sp_set_ctx_imp_id @import_id;              -- POST 3: set import id

      -- R03: Clear tables
      EXEC sp_log 1, @fn, '260: chk postcondion R03: Cleared tables';
      --   R03.2: Clear CorrectionLog table
      EXEC sp_assert_tbl_not_pop 'CorrectionLog';
      --   R03.3: Clear S2UpdateLog table
      EXEC sp_assert_tbl_not_pop 'S2UpdateLog';
      --   R03.4: Clear S2UpdateSummary table
      EXEC sp_assert_tbl_not_pop 'S2UpdateSummary';

      ----------------------------------------------------------------
   -- R15: Set the session context values:
         -------------------------------------------------------------
   -- R15.1 set ctx: import_root
   EXEC sp_set_session_context_import_root @import_root

   -- file type: txt or xlsx
   -- Cor files
   EXEC sp_log 1, @fn, '270: pop ImportState, Corfiles';

   -- Save parameters in state
   INSERT INTO ImportState
          ( import_root, import_file, cor_files, start_stage, stop_stage, start_row, stop_row, restore_s1_s2, restore_s3_s2
          , log_level, import_eppo, import_id, file_type)
   VALUES (@import_root,@import_file,@cor_files,@start_stage,@stop_stage,@start_row,@stop_row,@restore_s1_s2,@restore_s3_s2
          ,@log_level,@import_eppo,@import_id,@file_type)
   ;

   EXEC sp_init_cor_files @cor_files = @cor_files, @import_root = @import_root;

         -------------------------------------------------------------
         -- 10: Completed processing
         -------------------------------------------------------------
      EXEC sp_log 2, @fn, '400: Completed processing ok';
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: caught exception';
      EXEC dbo.sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999: leaving, @import_id: [',@import_id,']';
END
/*
EXEC tSQLt.Run 'test.test_099_sp_mn_imprt_ini';
EXEC test.test_099_sp_mn_imprt_ini;
EXEC sp_AppLog_display 'sp_mn_imprt_ini'
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==================================================================================================================================================
-- Author:      Terry Watts
-- Create date: 31-MAR-2024
-- Description: validates sp_merge_normalised_tables postconditions
--       and do any main table fixup
--
-- POSTCONDITIONS
-- DEL01: This is the deliverable set of output tables populated by this routine
-- POST 01: Action table populated
-- POST 02: Chemical table populated
-- POST 03: ChemicalAction table populated
-- POST 04: ChemicalProduct table populated
-- POST 05: ChemicalUse table populated
-- POST 06: Company table populated
-- POST 07: Crop table populated
-- POST 08: CropPathogen table populated
-- POST 09: Distributor table populated
-- POST 10: Pathogen table populated
-- POST 11: PathogenChemical table populated
-- POST 12: PathogenType table populated
-- POST 13: Product table populated
-- POST 14: ProductCompany table populated
-- POST 15: ProductUse table populated
-- POST 16: Type table populated
-- POST 17: Use table populated
-- POST 18: DistributorManufacturer populated
--
-- TESTS:
--
-- CHANGES:
-- ==================================================================================================================================================
CREATE PROCEDURE [dbo].[sp_mrg_mn_tbls_post_cks]
AS
BEGIN
   SET NOCOUNT OFF;

   DECLARE 
       @fn        VARCHAR(30)  = N'MRG_MN_TBLS_POST_CHKS'
      ,@error_msg VARCHAR(MAX)  = NULL
      ,@file_path VARCHAR(MAX)
      ,@id        INT = 1

   BEGIN TRY
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'000: starting, running postcondition validation checks';
      -----------------------------------------------------------------------------------
      -----------------------------------------------------------------------------------
      -- 1: Table pop chks
      -----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'010: table pop chks';
      EXEC sp_assert_tbl_pop 'Action';
      EXEC sp_assert_tbl_pop 'Chemical';
      EXEC sp_assert_tbl_pop 'ChemicalAction';
      EXEC sp_assert_tbl_pop 'ChemicalProduct';
      EXEC sp_assert_tbl_pop 'ChemicalUse';
      EXEC sp_assert_tbl_pop 'Company';
      EXEC sp_assert_tbl_pop 'Crop';
      EXEC sp_assert_tbl_pop 'CropPathogen';
      EXEC sp_assert_tbl_pop 'Distributor';
      EXEC sp_assert_tbl_pop 'DistributorManufacturer';
      EXEC sp_assert_tbl_pop 'Pathogen';
      EXEC sp_assert_tbl_pop 'PathogenChemical';
      EXEC sp_assert_tbl_pop 'PathogenType';
      EXEC sp_assert_tbl_pop 'Product';
      EXEC sp_assert_tbl_pop 'ProductCompany';
      EXEC sp_assert_tbl_pop 'ProductUse';
      EXEC sp_assert_tbl_pop 'Use';

      -----------------------------------------------------------------------------------
      -- 2: Detailed checks
      -----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'020: detailed chks';
      EXEC sp_log 2, @fn,'005: Action';
      EXEC sp_check_field_not_null 'Action','action_id';
      EXEC sp_check_field_not_null 'Action','action_nm';

      EXEC sp_log 2, @fn,'010: Chemical';
      EXEC sp_check_field_not_null 'Chemical','chemical_id';
      EXEC sp_check_field_not_null 'Chemical','chemical_nm';

      EXEC sp_log 2, @fn,'015: Company';
      EXEC sp_check_field_not_null 'Company','company_id';
      EXEC sp_check_field_not_null 'Company','company_nm';

      EXEC sp_log 2, @fn,'020: Crop';
      EXEC sp_check_field_not_null 'Crop','crop_id';
      EXEC sp_check_field_not_null 'Crop','crop_nm';

      EXEC sp_log 2, @fn,'025: Distributor';
      EXEC sp_check_field_not_null 'Distributor','distributor_id';
      EXEC sp_check_field_not_null 'Distributor','distributor_name';

      EXEC sp_log 2, @fn,'030: Pathogen';
      EXEC sp_check_field_not_null 'Pathogen','pathogen_id';
      EXEC sp_check_field_not_null 'Pathogen','pathogen_nm';
      EXEC sp_check_field_not_null 'Pathogen','pathogenType_nm';
      EXEC sp_check_field_not_null 'Pathogen','pathogenType_id';
      EXEC sp_check_field_not_null 'Pathogen','crops';
      EXEC sp_check_field_not_null 'Pathogen','taxonomy';
      EXEC sp_check_field_not_null 'Pathogen','biological_cure';
      EXEC sp_check_field_not_null 'Pathogen','notes';
      EXEC sp_check_field_not_null 'Pathogen','urls';

      EXEC sp_log 2, @fn,'035: PathogenType';
      EXEC sp_check_field_not_null 'PathogenType','pathogenType_id';
      EXEC sp_check_field_not_null 'PathogenType','pathogenType_nm';

      EXEC sp_log 2, @fn,'040: Product';
      EXEC sp_check_field_not_null 'Product','product_id';
      EXEC sp_check_field_not_null 'Product','product_nm';

      EXEC sp_log 2, @fn,'045: Type';
      EXEC sp_check_field_not_null 'Type','type_id';
      EXEC sp_check_field_not_null 'Type','type_nm';

      EXEC sp_log 2, @fn,'050: Use';
      EXEC sp_check_field_not_null 'Use','use_id';
      EXEC sp_check_field_not_null 'Use','use_nm';

      EXEC sp_log 2, @fn,'060: ChemicalAction';
      EXEC sp_check_field_not_null 'ChemicalAction','chemical_id';
      EXEC sp_check_field_not_null 'ChemicalAction','action_id';
      EXEC sp_check_field_not_null 'ChemicalAction','chemical_nm';
      EXEC sp_check_field_not_null 'ChemicalAction','action_nm';
      EXEC sp_check_field_not_null 'ChemicalAction','created';

      EXEC sp_log 2, @fn,'065: ChemicalProduct';
      EXEC sp_check_field_not_null 'ChemicalProduct','chemical_id';
      EXEC sp_check_field_not_null 'ChemicalProduct','product_id';
      EXEC sp_check_field_not_null 'ChemicalProduct','chemical_nm';
      EXEC sp_check_field_not_null 'ChemicalProduct','product_nm';

      EXEC sp_log 2, @fn,'070: ChemicalUse';
      EXEC sp_check_field_not_null 'ChemicalUse','chemical_id';
      EXEC sp_check_field_not_null 'ChemicalUse','use_id';
      EXEC sp_check_field_not_null 'ChemicalUse','chemical_nm';
      EXEC sp_check_field_not_null 'ChemicalUse','use_nm';

      EXEC sp_log 2, @fn,'075: CropPathogen';
      EXEC sp_check_field_not_null 'CropPathogen','crop_id';
      EXEC sp_check_field_not_null 'CropPathogen','pathogen_id';
      EXEC sp_check_field_not_null 'CropPathogen','crop_nm';
      EXEC sp_check_field_not_null 'CropPathogen','pathogen_nm';

      EXEC sp_log 2, @fn,'080: PathogenChemical';
      EXEC sp_check_field_not_null 'PathogenChemical','pathogen_id';
      EXEC sp_check_field_not_null 'PathogenChemical','chemical_id';
      EXEC sp_check_field_not_null 'PathogenChemical','pathogenType_id';
      EXEC sp_check_field_not_null 'PathogenChemical','pathogen_nm';
      EXEC sp_check_field_not_null 'PathogenChemical','chemical_nm';
      EXEC sp_check_field_not_null 'PathogenChemical','created';

      EXEC sp_log 2, @fn,'085: ProductCompany';
      EXEC sp_check_field_not_null 'ProductCompany','product_id';
      EXEC sp_check_field_not_null 'ProductCompany','company_id';
      EXEC sp_check_field_not_null 'ProductCompany','product_nm';
      EXEC sp_check_field_not_null 'ProductCompany','company_nm';

      EXEC sp_log 2, @fn,'090: ProductUse';
      EXEC sp_check_field_not_null 'ProductUse','product_id';
      EXEC sp_check_field_not_null 'ProductUse','use_id';

      EXEC sp_log 2, @fn,'095: ProductUse';
      EXEC sp_check_field_not_null 'ProductUse','product_nm';
      EXEC sp_check_field_not_null 'ProductUse','use_nm';
      EXEC sp_check_field_not_null 'ProductUse','created';
      -----------------------------------------------------------------------------------
      -- Detailed checks
      -----------------------------------------------------------------------------------

      -----------------------------------------------------------------------------------
      -- 23: Completed processing OK
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '220: Completed processing OK';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving: OK';
END
/*
EXEC sp_sp_mrg_mn_tbls_post_cks;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =================================================================
-- Author:      Terry Watts
-- Create date: 08-NOV-2023
-- Description: precondition helper for sp_merge_normalised_tables
-- =================================================================
CREATE PROCEDURE [dbo].[sp_mrg_mn_tbls_precndtn_hlpr] 
    @id        INT            OUTPUT
   ,@table_nm  VARCHAR(50)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE 
       @fn        VARCHAR(30)  = N'MRG_NORM_TBLS'
      ,@msg       VARCHAR(100)

   SET @msg = CONCAT('PRE', FORMAT(@id, '00'),': checking ',@table_nm);
   EXEC sp_log 2, @fn, @msg; 
   EXEC sp_assert_tbl_pop @table_nm;
   SET @id = @id+1;
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ChemicalAction](
	[chemical_id] [int] NOT NULL,
	[action_id] [int] NOT NULL,
	[chemical_nm] [varchar](400) NULL,
	[action_nm] [varchar](50) NULL,
	[created] [date] NULL,
 CONSTRAINT [PK_ChemicalEntryMode] PRIMARY KEY CLUSTERED 
(
	[chemical_id] ASC,
	[action_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_ChemicalEntryMode_chemical] ON [dbo].[ChemicalAction]
(
	[chemical_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_ChemicalEntryMode_entry_mode] ON [dbo].[ChemicalAction]
(
	[action_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

ALTER TABLE [dbo].[ChemicalAction] ADD  CONSTRAINT [DF_ChemicalAction_created]  DEFAULT (getdate()) FOR [created]

ALTER TABLE [dbo].[ChemicalAction]  WITH CHECK ADD  CONSTRAINT [FK_ChemicalAction_Action] FOREIGN KEY([action_id])
REFERENCES [dbo].[Action] ([action_id])

ALTER TABLE [dbo].[ChemicalAction] CHECK CONSTRAINT [FK_ChemicalAction_Action]

ALTER TABLE [dbo].[ChemicalAction]  WITH CHECK ADD  CONSTRAINT [FK_ChemicalAction_Chemical] FOREIGN KEY([chemical_id])
REFERENCES [dbo].[Chemical] ([chemical_id])

ALTER TABLE [dbo].[ChemicalAction] CHECK CONSTRAINT [FK_ChemicalAction_Chemical]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===========================================================================
-- Author:      Terry Watts
-- Create date: 22-OCT-2023
-- Description: fixes up the ChemicalEntryMode link table
--    from the corrected Staging2 table
--
-- PRECONDITIONS:
--    PRE01: Chemical table populated
--    PRE02: EntryModeType table populated
--
-- POSTCONDITIONS:
-- POST01: ChemicalAction table has rows
-- POST02: mancozeb exists and is only contact
-- ===========================================================================
CREATE PROCEDURE [dbo].[sp_pop_chemicalAction]
AS
BEGIN
   SET NOCOUNT OFF;

   DECLARE
     @fn          VARCHAR(35)   = N'POP_ChemicalAction'
    ,@row_cnt     INT = -1

   BEGIN TRY
      EXEC sp_log 2, @fn, '01: starting, validation chks';
      --EXEC sp_register_call @fn;

      ------------------------------------------------------------------
      -- VALIDATION:
      ------------------------------------------------------------------
      -- PRE01: Chemical table populated
      -- PRE02: EntryModeType table populated
      EXEC sp_assert_tbl_pop 'Chemical';
      EXEC sp_assert_tbl_pop 'Action';

      ------------------------------------------------------------------
      -- ASSERTION: precondition validation passed
      ------------------------------------------------------------------
      EXEC sp_log 2, @fn, '05: passed validation chks';

      ------------------------------------------------------------------
      -- Process
      ------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: Process';

            -- First update the names in the link table
      UPDATE ChemicalAction 
      SET chemical_nm=X.chemical_nm
      ,action_nm = X.action_nm
      FROM
      (
         SELECT c.chemical_nm, a.action_nm, a.action_id, c.chemical_id 
         FROM ChemicalAction ca join Chemical c ON ca.chemical_id = c.chemical_id
         JOIN Action a ON a.action_id=ca.action_id
      ) AS X
      WHERE ChemicalAction.action_id = X.action_id
        AND ChemicalAction.chemical_id = X.chemical_id;

      -- Now merge
      MERGE ChemicalAction as target
      USING
      (
         SELECT c.chemical_id, c.chemical_nm, a.action_nm, a.action_id
         FROM ChemicalActionStaging  cas 
         JOIN Chemical        c  ON c.chemical_nm = cas.chemical_nm
         JOIN [Action] a ON a.action_nm=cas.action_nm
      ) AS S
      ON target.chemical_nm = S.chemical_nm AND target.action_nm = s.action_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  chemical_id,   action_id,   chemical_nm,   action_nm)
         VALUES (s.chemical_id, s.action_id, s.chemical_nm, s.action_nm)
      ;

      SET @row_cnt = @@ROWCOUNT;

      ------------------------------------------------------------------
      -- check postconditions
      ------------------------------------------------------------------
      EXEC sp_log 1, @fn, '20: checking postconditions   ';
      -- Chk POST01: ChemicalActionStaging table populated
      -- Chk POST02: mancozeb exists and is only contact
      EXEC sp_assert_tbl_pop 'ChemicalAction';
      SELECT @row_cnt = COUNT(*) FROM ChemicalActionStaging WHERE chemical_nm='Mancozeb';
      EXEC sp_assert_equal 1, @row_cnt, 'Mancozeb should only have 1 entry in ChemicalActionStaging, count: ', @row_cnt, @ex_num=53224, @fn=@fn;
      SELECT @row_cnt = COUNT(*) FROM ChemicalActionStaging WHERE chemical_nm='Mancozeb' AND action_nm='CONTACT';
      EXEC sp_assert_equal 1, @row_cnt, 'Mancozeb mode should be CONTACT in ChemicalActionStaging, count: ', @row_cnt, @ex_num=53224, @fn=@fn;

      ------------------------------------------------------------------
      -- ASSERTION: postcondition validation passed
      ------------------------------------------------------------------
      EXEC sp_log 1, @fn, '25: passed postcondition checks';
      EXEC sp_log 1, @fn, '40: process complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '99: leaving, updated ', @row_cnt, ' rows', @row_count=@row_cnt;
END
/*
EXEC sp_pop_chemicalAction; -- 91 -> 156 -> 332 rows
SELECT * FROM [ChemicalAction];
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[PathogenChemical](
	[pathogen_id] [int] NULL,
	[chemical_id] [int] NULL,
	[pathogenType_id] [int] NULL,
	[pathogen_nm] [varchar](100) NULL,
	[chemical_nm] [varchar](100) NULL,
	[created] [datetime] NOT NULL
) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_PathogenChemical] ON [dbo].[PathogenChemical]
(
	[pathogen_id] ASC,
	[chemical_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE UNIQUE NONCLUSTERED INDEX [IX_PathogenChemical_1] ON [dbo].[PathogenChemical]
(
	[pathogen_nm] ASC,
	[chemical_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_PathogenChemical_chemical] ON [dbo].[PathogenChemical]
(
	[chemical_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_PathogenChemical_pathogen] ON [dbo].[PathogenChemical]
(
	[pathogen_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

ALTER TABLE [dbo].[PathogenChemical] ADD  CONSTRAINT [DF_PathogenChemical_created]  DEFAULT (getdate()) FOR [created]

ALTER TABLE [dbo].[PathogenChemical]  WITH NOCHECK ADD  CONSTRAINT [FK_PathogenChemical_Chemical] FOREIGN KEY([chemical_nm])
REFERENCES [dbo].[Chemical] ([chemical_nm])

ALTER TABLE [dbo].[PathogenChemical] CHECK CONSTRAINT [FK_PathogenChemical_Chemical]

ALTER TABLE [dbo].[PathogenChemical]  WITH CHECK ADD  CONSTRAINT [FK_PathogenChemical_Pathogen] FOREIGN KEY([pathogen_nm])
REFERENCES [dbo].[Pathogen] ([pathogen_nm])

ALTER TABLE [dbo].[PathogenChemical] CHECK CONSTRAINT [FK_PathogenChemical_Pathogen]

ALTER TABLE [dbo].[PathogenChemical]  WITH CHECK ADD  CONSTRAINT [FK_PathogenChemical_type] FOREIGN KEY([pathogenType_id])
REFERENCES [dbo].[PathogenType] ([pathogenType_id])

ALTER TABLE [dbo].[PathogenChemical] CHECK CONSTRAINT [FK_PathogenChemical_type]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ======================================================================================================
-- Author:      Terry Watts
-- Create date: 14-MAR-2024
-- Description: lists unmatched PathogenChemicalStaging pathogens that merge can't handle
--
-- Uses
--   in sp_merge_normalised_tables when the PathogenChemical merge fails due to mismatched pathogen names
-- ======================================================================================================
CREATE VIEW [dbo].[list_unmatched_PathogenChemicalStaging_pathogens_vw]
AS
SELECT DISTINCT TOP 1000 pcs.pathogen_nm
FROM
   PathogenChemicalStaging pcs
   LEFT JOIN Pathogen p      ON p.pathogen_nm      = pcs.pathogen_nm
   LEFT JOIN PathogenType pt ON pt.pathogenType_id = p.pathogenType_id
WHERE 
pt.pathogenType_id IS NULL
ORDER BY pcs.pathogen_nm;
/*
SELECT TOP 50 * FROM list_unmatched_PathogenChemicalStaging_pathogens_vw;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[Product](
	[product_id] [int] IDENTITY(1,1) NOT NULL,
	[product_nm] [varchar](50) NOT NULL,
 CONSTRAINT [PK_Product] PRIMARY KEY CLUSTERED 
(
	[product_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Product_nm] UNIQUE NONCLUSTERED 
(
	[product_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ProductCompany](
	[product_id] [int] NOT NULL,
	[company_id] [int] NOT NULL,
	[product_nm] [varchar](50) NULL,
	[company_nm] [varchar](100) NULL,
 CONSTRAINT [PK_ProductCompany] PRIMARY KEY CLUSTERED 
(
	[product_id] ASC,
	[company_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].[ProductCompany]  WITH CHECK ADD  CONSTRAINT [FK_ProductCompany_company] FOREIGN KEY([company_id])
REFERENCES [dbo].[Company] ([company_id])

ALTER TABLE [dbo].[ProductCompany] CHECK CONSTRAINT [FK_ProductCompany_company]

ALTER TABLE [dbo].[ProductCompany]  WITH CHECK ADD  CONSTRAINT [FK_ProductCompany_product] FOREIGN KEY([product_id])
REFERENCES [dbo].[Product] ([product_id])

ALTER TABLE [dbo].[ProductCompany] CHECK CONSTRAINT [FK_ProductCompany_product]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ProductUse](
	[product_id] [int] NOT NULL,
	[use_id] [int] NOT NULL,
	[product_nm] [varchar](50) NULL,
	[use_nm] [varchar](50) NULL,
	[created]  AS (getdate()),
 CONSTRAINT [PK_ProductUse] PRIMARY KEY CLUSTERED 
(
	[product_id] ASC,
	[use_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_ProductUse_product_id] ON [dbo].[ProductUse]
(
	[product_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_ProductUse_product_nm] ON [dbo].[ProductUse]
(
	[product_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_ProductUse_type_id] ON [dbo].[ProductUse]
(
	[use_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

SET ANSI_PADDING ON

CREATE NONCLUSTERED INDEX [IX_ProductUse_usr_nm] ON [dbo].[ProductUse]
(
	[use_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

ALTER TABLE [dbo].[ProductUse]  WITH CHECK ADD  CONSTRAINT [FK_ProductUse_Product] FOREIGN KEY([product_id])
REFERENCES [dbo].[Product] ([product_id])

ALTER TABLE [dbo].[ProductUse] CHECK CONSTRAINT [FK_ProductUse_Product]

ALTER TABLE [dbo].[ProductUse]  WITH CHECK ADD  CONSTRAINT [FK_ProductUse_Use] FOREIGN KEY([use_id])
REFERENCES [dbo].[Use] ([use_id])

ALTER TABLE [dbo].[ProductUse] CHECK CONSTRAINT [FK_ProductUse_Use]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ChemicalProduct](
	[chemical_id] [int] NOT NULL,
	[product_id] [int] NOT NULL,
	[chemical_nm] [varchar](100) NULL,
	[product_nm] [varchar](50) NULL,
 CONSTRAINT [PK_ChemicalProduct] PRIMARY KEY CLUSTERED 
(
	[chemical_id] ASC,
	[product_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [IX_Chem2Prod] UNIQUE NONCLUSTERED 
(
	[chemical_id] ASC,
	[product_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_Chem2Prod_chemical] ON [dbo].[ChemicalProduct]
(
	[chemical_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_Chem2Prod_product] ON [dbo].[ChemicalProduct]
(
	[product_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_ChemicalProduct] ON [dbo].[ChemicalProduct]
(
	[chemical_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

ALTER TABLE [dbo].[ChemicalProduct]  WITH CHECK ADD  CONSTRAINT [FK_ChemicalProduct_Chemical] FOREIGN KEY([chemical_id])
REFERENCES [dbo].[Chemical] ([chemical_id])

ALTER TABLE [dbo].[ChemicalProduct] CHECK CONSTRAINT [FK_ChemicalProduct_Chemical]

ALTER TABLE [dbo].[ChemicalProduct]  WITH CHECK ADD  CONSTRAINT [FK_ChemicalProduct_Product] FOREIGN KEY([product_id])
REFERENCES [dbo].[Product] ([product_id])

ALTER TABLE [dbo].[ChemicalProduct] CHECK CONSTRAINT [FK_ChemicalProduct_Product]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[DistributorManufacturer](
	[distributor_id] [int] NOT NULL,
	[manufacturer_id] [int] NOT NULL,
 CONSTRAINT [PK_DistributorManufacturer] PRIMARY KEY CLUSTERED 
(
	[distributor_id] ASC,
	[manufacturer_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].[DistributorManufacturer]  WITH CHECK ADD  CONSTRAINT [FK_DistributorManufacturer_Company] FOREIGN KEY([manufacturer_id])
REFERENCES [dbo].[Company] ([company_id])

ALTER TABLE [dbo].[DistributorManufacturer] CHECK CONSTRAINT [FK_DistributorManufacturer_Company]

ALTER TABLE [dbo].[DistributorManufacturer]  WITH CHECK ADD  CONSTRAINT [FK_DistributorManufacturer_Distributor] FOREIGN KEY([distributor_id])
REFERENCES [dbo].[Distributor] ([distributor_id])

ALTER TABLE [dbo].[DistributorManufacturer] CHECK CONSTRAINT [FK_DistributorManufacturer_Distributor]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[ChemicalUse](
	[chemical_id] [int] NULL,
	[use_id] [int] NULL,
	[chemical_nm] [varchar](100) NULL,
	[use_nm] [varchar](50) NULL
) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_Chemical2Type_chemical] ON [dbo].[ChemicalUse]
(
	[chemical_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_Chemical2Type_type] ON [dbo].[ChemicalUse]
(
	[use_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

CREATE NONCLUSTERED INDEX [IX_ChemicalUse] ON [dbo].[ChemicalUse]
(
	[chemical_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]

ALTER TABLE [dbo].[ChemicalUse]  WITH CHECK ADD  CONSTRAINT [FK_ChemicalUse_Chemical] FOREIGN KEY([chemical_id])
REFERENCES [dbo].[Chemical] ([chemical_id])

ALTER TABLE [dbo].[ChemicalUse] CHECK CONSTRAINT [FK_ChemicalUse_Chemical]

ALTER TABLE [dbo].[ChemicalUse]  WITH CHECK ADD  CONSTRAINT [FK_ChemicalUse_Use] FOREIGN KEY([use_id])
REFERENCES [dbo].[Use] ([use_id])

ALTER TABLE [dbo].[ChemicalUse] CHECK CONSTRAINT [FK_ChemicalUse_Use]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================
-- Author:      Terry Watts
-- Create date: 05-MAR-2024
-- Description: separates the manufacturers
--
-- CHANGES:
--
-- ==============================================================================
CREATE   VIEW [dbo].[DistributorStaging_vw]
AS
SELECT distributor_nm, value as manufacturer_nm
FROM DistributorStaging CROSS APPLY string_split(manufacturers, ',');
/*
SELECT * FROM DistributorStaging_vw
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==================================================================================================================================================
-- Author:      Terry Watts
-- Create date: 19-AUG-2023
-- Description: Merges the normalised staging tables to the associated main normalised tables
--       and do any main table fixup
--
-- REQUIREMENTS:
-- R01: populate the DEL01 set using the PRE01 set of tables
--
-- PRECONDITIONS:
-- PRE01: the following set of staging tables are populated and fixed up
--    PRE03: ChemicalActionStaging
--    PRE04: ChemicalProductStaging
--    PRE05: ChemicalUseStaging
--    PRE08: CropPathogenStaging
--    PRE10: PathogenChemicalStagng
--    PRE11: PathogenTypeStaging
--    PRE12: PathogenPathogenStaging
--    PRE12: ProductStaging
--    PRE13: ProductCompanyStaging
--    PRE14: ProductUseStaging
--
-- PRE02: import id session setting set or is a parameter
--
-- POSTCONDITIONS
-- DEL01: This is the deliverable set of output tables populated by this routine
-- POST 03: ChemicalAction table populated
-- POST 04: ChemicalProduct table populated
-- POST 05: ChemicalUse table populated
-- POST 08: CropPathogen table populated
-- POST 11: PathogenChemical table populated
-- POST 12: PathogenType table populated
-- POST 13: Product table populated
-- POST 14: ProductCompany table populated
-- POST 15: ProductUse table populated
-- POST 18: DistributorManufacturer populated
--
-- TESTS:
-- 1. initially empty aLl tables,
--    run routine,
--    check all tables are populated
--
-- CHANGES:
-- 231006: added post condition checks for table population
-- 231008: do any main table fixup: 
--         Update the ProductCompany link table with product nm & id and company nm & id 
-- 231009: fix ChemicalProduct merge: the merge view needs to use ChemicalProductStaging table but supported by main tables linked on names not ids
--         else no rows affected
-- 231024: added sp_pop_chemicalEntryMode to populate the ChemicalEntryMode link table to relate the chemical to its modes of action
-- 231104: added PathogenChemical, removed ChemicalPathogen
-- 231108: added Action,Type and Use table merges
-- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
--         In which case we need to assign a new id and use that in the associated link tables.
--         Make the main table id field auto incremental.
-- ==================================================================================================================================================
CREATE PROCEDURE [dbo].[sp_merge_mn_tbls]
AS
BEGIN
   SET NOCOUNT OFF;

   DECLARE 
       @fn        VARCHAR(30)  = N'sp_merge_mn_tbls'
      ,@error_msg VARCHAR(MAX)  = NULL
      ,@file_path VARCHAR(MAX)
      ,@id        INT = 1

   BEGIN TRY
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'000: starting, running precondition validation checks';
      -----------------------------------------------------------------------------------
      EXEC sp_register_call @fn;

      -----------------------------------------------------------------------------------
      -- Precondition checks
      -----------------------------------------------------------------------------------

      -----------------------------------------------------------------------------------
      -- 02: check preconditions: PRE00: staging tables populated and fixed up
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '005: checking preconditions';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'ChemicalActionStaging';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'ChemicalProductStaging';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'ChemicalUseStaging';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'CropPathogenStaging';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'PathogenChemicalStaging';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'PathogenTypeStaging';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'ProductStaging';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'ProductCompanyStaging';
      EXEC sp_mrg_mn_tbls_precndtn_hlpr @id OUTPUT, 'ProductUseStaging';

      -----------------------------------------------------------------------------------
      --  03: merging main primary tables
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'020: merging main primary tables   ';

      -- ??
      DELETE FROM DistributorManufacturer;
      DELETE FROM ProductCompany;
      DELETE FROM ProductUse;
      DELETE FROM PathogenChemical;
      DELETE FROM ChemicalUse;
      DELETE FROM ChemicalProduct;
      DELETE FROM CropPathogen;

      -----------------------------------------------------------------------------------
      -- 12: Merge Product table
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '110: merging Product table';
      MERGE Product          AS target
      USING ProductStaging   AS s
      ON target.product_nm=s.product_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  product_nm)
         VALUES (s.product_nm)
      WHEN NOT MATCHED BY SOURCE THEN DELETE
         ;

      EXEC sp_assert_tbl_pop 'Product';

      -----------------------------------------------------------------------------------
      -- ASSERTION: all the main primary tables merged
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'120: ASSERTION: all the main primary tables merged.';

      -----------------------------------------------------------------------------------
      -- 13: merging main link tables using the standard strategy:
      -----------------------------------------------------------------------------------
      -- Strategy:
      --    Join the staging link table to the 2 respective primary staging tables based on ids
      --    Join the staging tables to their respective main tables based on names
      --    Use the primary main table ids to populate the main link table
      ---------------------------------------------------
      EXEC sp_log 2, @fn,'130: merging main link tables   ';

      -----------------------------------------------------------------------------------
      -- Merge CropPathogen table
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '140 merging CropPathogen link table';
      SELECT * From CropPathogen

      MERGE CropPathogen          AS target
      USING
      (
         SELECT p.pathogen_nm, c.crop_id, c.crop_nm, p.pathogen_id
         FROM
            CropPathogenStaging cps
            LEFT JOIN CropStaging   cs ON cs.crop_nm = cps.crop_nm
            LEFT JOIN Crop          c  ON c. crop_nm = cs .crop_nm
            LEFT JOIN Pathogen      p  ON p .pathogen_nm = cps.pathogen_nm
         WHERE 
                cs.crop_nm IS NOT NULL 
            AND cs.crop_nm <>''
            AND p.pathogen_nm IS NOT NULL
            AND p.pathogen_nm <>''
      )       AS s
      ON target.crop_nm = s.crop_nm AND target.pathogen_nm = s.pathogen_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  crop_id,   pathogen_id,  crop_nm,   pathogen_nm)
         VALUES (s.crop_id, s.pathogen_id,s.crop_nm, s.pathogen_nm)
         ;

      EXEC sp_assert_tbl_pop 'CropPathogen';

      -----------------------------------------------------------------------------------
      -- 15: Merge ChemicalProduct table
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '150: merging ChemicalProduct link table';
      MERGE ChemicalProduct AS target
      USING
      (
         SELECT c.chemical_id, p.product_id, c.chemical_nm, p.product_nm
         FROM
         ChemicalProductStaging cps
         LEFT JOIN ChemicalStaging   cs ON cs.chemical_nm = cps.chemical_nm
         LEFT JOIN Chemical          c  ON c. chemical_nm = cs .chemical_nm
         LEFT JOIN ProductStaging    ps ON ps.product_nm  = cps.product_nm
         LEFT JOIN Product           p  ON p. product_nm  = ps .product_nm
      ) AS s
      ON target.chemical_nm = s.chemical_nm AND target.product_nm=s.product_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  chemical_id,   product_id,   chemical_nm,   product_nm)
         VALUES (s.chemical_id, s.product_id, s.chemical_nm, s.product_nm)
     ;

      EXEC sp_assert_tbl_pop 'ChemicalProduct';

      -----------------------------------------------------------------------------------
      -- 16: Merge ChemicalAction table
      -----------------------------------------------------------------------------------
      -- POST 03: ChemicalAction table populated
      EXEC sp_log 2, @fn, '160: merging ChemicalAction link table';

      MERGE ChemicalAction          AS target
      USING
      (
         SELECT c.chemical_id, a.action_id, c.chemical_nm, a.action_nm
         FROM 
         ChemicalActionStaging cas
         LEFT JOIN ChemicalStaging cs ON cs.chemical_nm = cas.chemical_nm
         LEFT JOIN Chemical c ON c.chemical_nm = cas.chemical_nm
         LEFT JOIN [Action] a ON a.action_nm = cas.action_nm
      ) AS s
      ON target.chemical_nm = s.chemical_nm AND target.action_nm = s.action_nm
      WHEN NOT MATCHED BY target THEN
         INSERT ( chemical_id, action_id, chemical_nm, action_nm)
         VALUES ( chemical_id, action_id, chemical_nm, action_nm)
      ;

      EXEC sp_assert_tbl_pop 'ChemicalUse';

      -----------------------------------------------------------------------------------
      -- 16: Merge ChemicalUse table
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '160: merging ChemicalUse link table';
      MERGE ChemicalUse          AS target
      USING 
      (
         SELECT c.chemical_id, u.use_id, c.chemical_nm, u.use_nm
         FROM 
         ChemicalUseStaging cus 
         LEFT JOIN ChemicalStaging cs ON cs.chemical_nm = cus.chemical_nm
         LEFT JOIN Chemical c ON c.chemical_nm = cs.chemical_nm
         LEFT JOIN [Use] u ON u.use_nm = cus.use_nm
      ) AS s
      ON target.chemical_nm = s.chemical_nm AND target.use_nm = s.use_nm
      WHEN NOT MATCHED BY target THEN
         INSERT ( chemical_id, use_id, chemical_nm, use_nm)
         VALUES ( chemical_id, use_id, chemical_nm, use_nm)
      ;

      EXEC sp_assert_tbl_pop 'ChemicalUse';

      -----------------------------------------------------------------------------------
      --17: Merge PathogenChemical table - needs the pathogen type info 2059 rows
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      BEGIN TRY
         EXEC sp_log 2, @fn, '170: merging PathogenChemical link table';
         EXEC sp_log 2, @fn, '180: checking PathogenChemical dependencies are populated';
         EXEC sp_assert_tbl_pop 'PathogenChemicalStaging';
         EXEC sp_assert_tbl_pop 'Pathogen';
         EXEC sp_assert_tbl_pop 'Chemical';
         --EXEC sp_assert_tbl_pop 'PathogenPathogenTypeStaging';
         EXEC sp_assert_tbl_pop 'PathogenTypeStaging';
         EXEC sp_assert_tbl_pop 'PathogenType';

         -- Update Pathogen.PathogenType_id and import
         UPDATE Pathogen 
         SET pathogenType_id = pt.pathogenType_id
         FROM Pathogen p JOIN PathogenType pt ON p.pathogenType_nm=pt.pathogenType_nm;

         EXEC sp_log 2, @fn, '190: merging PathogenChemical table';
         /*----------------------------------------------------------------------------------------------------------------
          * If this yields null pathogenType_id which PathogenChemical wont accept then use this view to trace the issues
          * list_unmatched_PathogenChemicalStaging_pathogens_vw
          *----------------------------------------------------------------------------------------------------------------*/
         MERGE PathogenChemical AS target
         USING
         (
            SELECT p.pathogen_id, p.pathogen_nm, c.chemical_id, c.chemical_nm, pt.pathogenType_id 
            FROM 
               PathogenChemicalStaging pcs
               LEFT JOIN Pathogen p ON p.pathogen_nm = pcs.pathogen_nm
               LEFT JOIN Chemical c ON c.chemical_nm = pcs.chemical_nm
               LEFT JOIN PathogenType pt ON pt.pathogenType_id=p.pathogenType_id
         ) AS s
         ON target.pathogen_nm = s.pathogen_nm AND target.chemical_nm = s.chemical_nm
         WHEN NOT MATCHED BY target THEN
            INSERT ( pathogen_id, chemical_id, pathogen_nm, chemical_nm, pathogenType_id)
            VALUES ( pathogen_id, chemical_id, pathogen_nm, chemical_nm, pathogenType_id)
            ;

         EXEC sp_assert_tbl_pop 'PathogenChemical';
      END TRY
      BEGIN CATCH
         EXEC dbo.sp_log_exception @fn;

         ------------------------------------------------------------------------------------------------------------------
         -- If the  error is trying to insert null pathogen_id into PathogenChemical: then this will help trace the issues
         ------------------------------------------------------------------------------------------------------------------
         SELECT 'MERGE PathogenChemical', pathogen_nm AS [mismatched pathogens] 
         FROM list_unmatched_PathogenChemicalStaging_pathogens_vw;
         THROW;
      END CATCH

      EXEC sp_assert_tbl_pop 'PathogenChemical';

      -----------------------------------------------------------------------------------
      -- 18: ProductUse table 
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '200: merging ProductUse link table';
      MERGE ProductUse          AS target
      USING 
      (
         SELECT p.product_id, u.use_id, p.product_nm, u.use_nm FROM 
         ProductUseStaging pus 
         LEFT JOIN ProductStaging ps ON ps.product_nm = pus.product_nm
         LEFT JOIN Product p ON p.product_nm = ps.product_nm
         LEFT JOIN [Use] u ON u.use_nm = pus.use_nm
      ) AS s
      ON target.product_nm = s.product_nm AND target.use_nm = s.use_nm
      WHEN NOT MATCHED BY target THEN
         INSERT ( product_id, use_id, product_nm, use_nm)
         VALUES ( product_id, use_id, product_nm, use_nm)
         ;

      EXEC sp_assert_tbl_pop 'ProductUse';

      -----------------------------------------------------------------------------------
      -- 19: Update the ProductCompany link table with product nm & id and company nm & id 
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '210: merging ProductCompany link table';

      MERGE ProductCompany as target
      USING
      (
         SELECT p.product_id, c.company_id, p .product_nm, c.company_nm
         FROM ProductCompanyStaging  pcs 
         JOIN ProductStaging ps ON ps.product_nm = pcs.product_nm
         JOIN Product        p  ON p .product_nm = ps.product_nm
         JOIN CompanyStaging cs ON cs.company_nm = pcs.company_nm
         JOIN Company        c  ON c.company_nm  = cs.company_nm
      ) AS S
      ON target.product_nm = S.product_nm AND target.company_nm = s.company_nm
      WHEN NOT MATCHED BY target THEN
         INSERT (  product_id,   company_id,   product_nm,   company_nm)
         VALUES (s.product_id, s.company_id, s.product_nm, s.company_nm)
      ;

      EXEC sp_assert_tbl_pop 'ProductCompany';

      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '220: merging ChemicalAction link table';
      -----------------------------------------------------------------------------------
      EXEC sp_pop_chemicalAction;

      -----------------------------------------------------------------------------------
      -- 20: DistributorManufacturer
      -----------------------------------------------------------------------------------
      -- 241027: It may be that that staging ids are different for a given name and may conflict other ids in the table.
      --         In which case we need to assign a new id and use that in the associated link tables.
      --         Make the main table id field auto incremental.
      EXEC sp_log 2, @fn, '230: merging DistributorManufacturer link table';
      MERGE DistributorManufacturer as target
      USING
      (
         SELECT d.distributor_id, c.company_id
         FROM DistributorStaging_vw ds
         JOIN Distributor d ON ds.distributor_nm = d.distributor_nm
         JOIN Company     c ON c.company_nm      = ds.manufacturer_nm
      ) AS S
      ON target.distributor_id = s.distributor_id AND target.manufacturer_id = s.company_id
      WHEN NOT MATCHED BY target THEN
         INSERT (  distributor_id,   manufacturer_id)
         VALUES (s.distributor_id, s.company_id)
      ;

      EXEC sp_assert_tbl_pop 'DistributorManufacturer';

      -----------------------------------------------------------------------------------
      -- 21: do any main table fixup: 
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '240: do any main table fixup: currently none';

      -----------------------------------------------------------------------------------
      -- 22  POSTCONDITION checks
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '250: POSTCONDITION checks   ';
   -- POST 03: ChemicalAction table populated
   -- POST 04: ChemicalProduct table populated
   -- POST 05: ChemicalUse table populated
   -- POST 08: CropPathogen table populated
   -- POST 11: PathogenChemical table populated
   -- POST 12: PathogenType table populated
   -- POST 13: Product table populated
   -- POST 14: ProductCompany table populated
   -- POST 15: ProductUse table populated
   -- POST 18: DistributorManufacturer populated
      EXEC sp_mrg_mn_tbls_post_cks;

      -----------------------------------------------------------------------------------
      -- 23: Completed processing OK
      -----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '400: Completed processing OK';
   END TRY
   BEGIN CATCH
      SET @error_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '500: Caught exception: ', @error_msg;
      THROW;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving: OK';
END
/*
EXEC sp_import_callRegister 'D:\Dev\Farming\Data\CallRegister.txt';
EXEC sp_reset_CallRegister;
EXEC sp_mrg_mn_tbls;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ====================================================
-- Procedure:   dbo.LRAP_Imprt_S09_mrg_mn
-- Description: Merge the  mn tables <- staging tables
-- Author:      Terry Watts
-- Create date: 05-FEB-2024
--
-- PRECONDITIONS: Stage 06 ran ok
--
-- POSTCONDITIONS:
--    POST 01: main tables updated
-- ====================================================
CREATE PROCEDURE [dbo].[LRAP_Imprt_S09_merge_mn]
AS
BEGIN
   DECLARE
       @fn        VARCHAR(35)   = 'LRAP_Imprt_S09_merge_mn'

   EXEC sp_log 1, @fn, '00: starting';
   --EXEC sp_register_call @fn;

   -----------------------------------------------------------------------------------
   -- Merge the staging tables to the normalised tables
   -----------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '10: Merge the staging tables to the normalised tables';
   EXEC sp_merge_mn_tbls;--   EXEC sp_merge_normalised_tables;

   -----------------------------------------------------------------------------------
   -- POSTCONDITIONS: POST 01: main normalised_tables updated
   -----------------------------------------------------------------------------------
   EXEC sp_log 2, @fn, '90: processing complete';
   EXEC sp_log 1, @fn, '99: leaving OK';
END
/*
   EXEC LRAP_Imprt_S09_merge_mn;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================    
-- Author:      Terry Watts
-- Create date: 22-MAR-2020
-- Description: Pads Left
-- =============================================    
CREATE   FUNCTION [dbo].[fnPadLeft2]( @s VARCHAR(500), @width INT, @pad VARCHAR(1)=' ')
RETURNS VARCHAR (1000)
AS
BEGIN
   DECLARE 
    @ret  VARCHAR(1000)
   ,@len INT

   IF @s IS null
      SET @s = '';

   SET @len = dbo.fnLen(@s);

   RETURN iif(@len < @width
      , RIGHT( CONCAT( REPLICATE( @pad, @width-@len), @s), @width)
      , RIGHT(@s, @width))
END
/*
SELECT CONCAT('[', dbo.fnPadLeft2('', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadLeft2(NULL, 25, '.'), ']  ');
PRINT CONCAT('[', dbo.fnPadLeft2(NULL, 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('', 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('asdfg', 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('asdfg', 3, 'x'),']')
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =========================================================================
-- Author:      Terry Watts
-- Create date: 15-OCT-2023
-- Description: helper rtn to update s1 and record the update count
--              Handles errors from sp_executesql by chk the ret
--              Doubles up single quotes
-- =========================================================================
CREATE PROCEDURE [dbo].[sp_fixup_s1_preprocess_hlpr]
    @field     VARCHAR(60)
   ,@key       VARCHAR(200)
   ,@value     VARCHAR(200)
   ,@ndx       INT    = NULL        OUTPUT
   ,@fixup_cnt INT    = NULL        OUTPUT
AS
BEGIN
   SET NOCOUNT OFF;
   DECLARE
    @fn        VARCHAR(35)   = 'sp_s1_fixup_preprocess_hlpr'
   ,@sql       NVARCHAR(MAX)
   ,@row_count INT
   ,@ret       INT
   ,@ndx_str   VARCHAR(35)
   ,@msg       VARCHAR(200)

   EXEC sp_log 1, @fn,'000: starting
   @field    : [',@field, ']
   @key      : [',@key, ']
   @value    : [',@value, ']
   @ndx      : [',@ndx, ']
   @fixup_cnt: [',@fixup_cnt, ']
   '
   ;

   -- Double up single quotes
   SET @value = REPLACE(@value, '''', '''''')
   SET @ndx_str = CONCAT(dbo.fnPadLeft2(@ndx, 2, '0'),' ');

   SET @sql = CONCAT('UPDATE staging1 SET [',@field,'] = REPLACE([', @field, '],''',@key,''',''',@value, ''') WHERE ',@field, ' LIKE ''%', @key, '%''');
   EXEC sp_log 1, @fn, 'sql:
', @sql;

   EXEC @ret = sp_executesql @sql;
   SET @row_count = @@ROWCOUNT;

   IF @ret <> 0
   BEGIN
      SET @msg = CONCAT('sp_executesql returned error code: ',@ret);
      EXEC sp_log 4, @fn, '010:',@ndx_str, @msg;
      THROW 64541, @msg, 1;
   END

   SET @fixup_cnt = @fixup_cnt + @row_count;
   SET @msg = CONCAT(@field, ': replaced ''',@key,''' with ''', @value, '''');
   EXEC sp_log 1, @fn, @ndx_str, @msg, @row_count = @row_count;
   SET @ndx = @ndx +1
   EXEC sp_log 1, @fn,'999: leaving, @fixup_cnt: ',@fixup_cnt;
END
/*
EXEC sp_fixup_s1_preprocess;
EXEC sp_fixup_s1_preprocess_hlpr 'pathogens',' and & ', ','
EXEC sp_fixup_s1_preprocess_hlpr  'company', '"', ''''
EXEC sp_fixup_s1_preprocess_hlpr 'product', 'á', ' '
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==========================================================
-- Author:      Terry Watts>
-- Create date: 01-JUL-2023
-- Description: Replace alternatie for hanling wsp, comma
-- ==========================================================
CREATE   FUNCTION [dbo].[fnReplace](@src VARCHAR(MAX), @old VARCHAR(MAX), @new VARCHAR(MAX)) 
RETURNS VARCHAR(MAX)
AS
BEGIN

DECLARE
    @ndx INT
   ,@len INT

   IF(@src IS NULL)
      return @src;

   SET @len = dbo.fnLen(@old);
   SET @ndx = CHARINDEX(@old, @src);

   IF(@ndx = 0)
      return @src;

   WHILE @ndx > 0
   BEGIN
      SET @src = STUFF(@src, @ndx, @len, @new);
      SET @ndx = CHARINDEX(@old, @src);
   END

   RETURN @src;
END
/*
SELECT dbo.fnReplace('ab ,cde ,def, ghi,jk', ' ,', ',' );   
SELECT dbo.fnReplace('ab ,cde ,def, ghi,jk, lmnp', ', ', ',' );   
SELECT dbo.fnReplace('abcdefgh', 'def', 'xyz' );   -- abcxyzgh
SELECT dbo.fnReplace(null, 'cd', 'xyz' );          -- null
SELECT dbo.fnReplace('', 'cd', 'xyz' );            -- ''
SELECT dbo.fnReplace('as', '', 'xyz' );            -- 'as'
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =====================================================
-- Author:      Terry Watts
-- Create date: 06-JUL-2023
-- Description: Make first character upper case
--              and all the subsequent chars lower case
--
-- Changes:
-- 241206: changed name from fnInitialCap to fnCamelCase
-- =====================================================
CREATE FUNCTION [dbo].[fnCamelCase]( @s VARCHAR(MAX))
  RETURNS VARCHAR(MAX)
AS
BEGIN 
   DECLARE @Position INT;

   IF (@s IS NULL) OR (@s='')
      RETURN @s;

   SET @s = CONCAT(Upper(Left(@s, 1)), LOWER(SUBSTRING(@s, 2, dbo.fnLen(@s)-1)));
   RETURN @s;
END;
/*
   PRINT CONCAT('[', dbo.InitialCap('this is a String'), ']');
   PRINT CONCAT('[', dbo.InitialCap(''), ']');
   PRINT CONCAT('[', dbo.InitialCap(NULL), ']');
   PRINT CONCAT('[', dbo.InitialCap('- this is a String'), ']');
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===============================================================================
-- Author:      Terry Watts
-- Create date: 04-JUL-2023
-- Description: standardises (replaces) combinations of & and space -> ' and'
-- ===============================================================================
CREATE   FUNCTION [dbo].[fnStandardiseAnds] (@s VARCHAR(MAX))
RETURNS VARCHAR(MAX)
AS
BEGIN
   DECLARE @r VARCHAR(MAX)

   -- Add the T-SQL statements to compute the return value here
   RETURN REPLACE(REPLACE(REPLACE(REPLACE(@s, '& ', '&'), '& ', '&'), ' &', '&' ), '&', ' and ');
END
/*
Print CONCAT('[',dbo.fnStanardiseAnds('AB & CDE and FG&HIJ &KLM&NOP'),']');
Print CONCAT('[',dbo.fnStanardiseAnds('')                        ,']');
Print CONCAT('[',dbo.fnStanardiseAnds(NULL)                      ,']');
Print CONCAT('[',dbo.fnStanardiseAnds('&')                      ,']');
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- --------------------------------------------------------------------------------------------------------------------------=
-- Author:      Terry Watts
-- Create date: 16=JUL=2023
-- Description: does the following std preprocess:
--    1. Removing wrapping double quotes from following columns:
--       company, ingredient product, crops, entry_mode, pathogens
--    2. pathogens: replace á -> spc
--    3. pathogens: standardise whitespace [tab, line fedd, hard space] -> spc
--    4. pathogens: make all double spaces -> single spc
--    5. standardise null fields to default
--    6. Camel case the following columns: company, ingredient, product, uses, entry_mode
--    7. standardise ands
-- CALLED BY:
--    sp_fixup_s1 < sp_main_import_stage_03_s1_fixup < sp__main_import
--
-- CHANGES:
-- 230717: _, [, ], and ^ need to be escaped, they are special characters in LIKE searches so replace [] with () here
-- 231015: factored the update sql, cunting and msg to a helper fn: sp_fixup_s1_preprocess_hlpr
-- 240121: remove double quotes from uses
-- --------------------------------------------------------------------------------------------------------------------------=
CREATE PROCEDURE [dbo].[sp_fixup_s1_preprocess]
      @fixup_cnt       INT OUT
AS
BEGIN
   DECLARE
       @fn           VARCHAR(35)   = 'sp_fixup_s1_preprocess'
      ,@row_count    INT
      ,@row_count_st INT
      ,@ndx          INT = 3
      ,@spc          VARCHAR(1) = N' '

   BEGIN TRY
      SET NOCOUNT OFF;
      SET @row_count_st = @row_count;
      EXEC sp_log 2, @fn, '000: starting, @fixup_cnt: ',@fixup_cnt;
      EXEC sp_assert_not_null @fixup_cnt, '@fixup_cnt',@fn=@fn;

      --3.1  standardise whitespace line feed in fields {company, crops, entry_mode, ingredient, mrl, phi, pathogens, product, rate, uses}
      EXEC sp_log 1, @fn, '010 standardise chrs(10) in company, crops, entry_mode, ingredient, product, pathogens, rate, mrl, phi, uses}';
      EXEC sp_log 1, @fn, '020 standardise chrs(10) in company';
      UPDATE staging1 SET company   = REPLACE(company    , NCHAR(10),  ' ') WHERE company    LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '030 standardise chrs(10) in crops, fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET crops     = REPLACE(crops      , NCHAR(10),  ' ') WHERE crops      LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '040 standardise chrs(10) in entry_mode, fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET entry_mode= REPLACE(entry_mode       , NCHAR(10),  ' ') WHERE entry_mode       LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '050 standardise chrs(10) in ingredient, fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET ingredient= REPLACE(ingredient , NCHAR(10),  ' ') WHERE ingredient LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '060 standardise chrs(10) in mrl.fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET mrl       = REPLACE(mrl        , NCHAR(10),  ' ') WHERE mrl        LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '070 standardise chrs(10) in pathogens. fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET pathogens = REPLACE(pathogens  , NCHAR(10),  ' ') WHERE pathogens  LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '080 standardise chrs(10) in phi, fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET phi       = REPLACE(phi        , NCHAR(10),  ' ') WHERE phi        LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '090 standardise chrs(10) in product, fixup_cnt:',@fixup_cnt;;
      UPDATE staging1 SET product   = REPLACE(product    , NCHAR(10),  ' ') WHERE product    LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '100 standardise chrs(10) in rate, fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET rate      = REPLACE(rate       , NCHAR(10),  ' ') WHERE rate       LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '110 standardise chrs(10) in uses, fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET uses      = REPLACE(uses       , NCHAR(10),  ' ') WHERE uses       LIKE  '%'+NCHAR(10)+'%';   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 1, @fn, '120: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_log 1, @fn, '130: company: removing wrapping double quotes'
      EXEC sp_fixup_s1_preprocess_hlpr  'company', '"', ''        , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '140: ingredient: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'ingredient', '"', ''     , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '150: product: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'product', '"', '  '      , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '160: crops: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'crops', '"', ''          , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '170: entry_mode: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'entry_mode', '"', ''     , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '180: pathogens: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'pathogens', '"', ''      , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '190: rate: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'rate', '"', ''           , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '200: mrl: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'mrl', '"', ''            , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '210: phi: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'phi', '"', ''            , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, '220: registration: removing wrapping double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'registration', '"', ''   , @ndx OUT, @fixup_cnt OUT;

      -- 240121: remove double quotes from uses
      EXEC sp_log 1, @fn, '230: uses: remove double quotes, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'uses'        , '"', ''   , @ndx OUT, @fixup_cnt OUT;

      -- 240121: replace uses 'Insecticide/fu ngicide' with 'Insecticide,Fungicide' 'Insecticide/fu ngicide'
      EXEC sp_log 1, @fn, '240: uses: replace Insecticide/fu ngicide < Insecticide,Fungicide, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr  'uses'        , 'Insecticide/fu ngicide', 'Insecticide,Fungicide'   , @ndx OUT, @fixup_cnt OUT;
      --UPDATE staging1 SET uses = 'Insecticide,Fungicide' WHERE uses LIKE  '%Insecticide/fu ngicide%';
      SET @row_count =  @@ROWCOUNT;
      SET @fixup_cnt = @fixup_cnt + @row_count;

      -- 22. pathogens: replace á with spc
      EXEC sp_log 1, @fn, @ndx, '250: pathogens: replacing á with spc, @fixup_cnt:',@fixup_cnt;
      SET @ndx = @ndx +1;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens', 'á', @spc     , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, @ndx, '260: product: replacing á with spc, @fixup_cnt:',@fixup_cnt; SET @ndx = @ndx +1;
      EXEC sp_fixup_s1_preprocess_hlpr 'product', 'á', ' '     , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_log 1, @fn, @ndx, '270: company: replacing á with spc, @fixup_cnt:',@fixup_cnt; SET @ndx = @ndx +1;
      EXEC sp_fixup_s1_preprocess_hlpr 'company', 'á', ' '     , @ndx OUT, @fixup_cnt OUT;

      -- 3. pathogens: standardise whitespace from [tab, line feed, hard space] = spc
      EXEC sp_log 1, @fn, @ndx, '280: pathogens: standardise whitespace from [tab, line feed, hard space] = spc, @fixup_cnt:',@fixup_cnt; SET @ndx = @ndx +1;
      UPDATE staging1 SET pathogens = REPLACE(pathogens, NCHAR(9) ,  ' ') WHERE pathogens LIKE  '%'+NCHAR(9) +'%';
      SET @row_count =  @@ROWCOUNT;
      SET @fixup_cnt = @fixup_cnt + @row_count;
   
      EXEC sp_log 1, @fn, '290: pathogens: standardised whitespace: CHAR(13), @fixup_cnt:',@fixup_cnt, @row_count = @row_count;

      UPDATE staging1 SET pathogens = REPLACE(pathogens, NCHAR(13),  ' ') WHERE pathogens LIKE  '%'+NCHAR(13)+'%';
      SET @row_count =  @@ROWCOUNT;
      SET @fixup_cnt = @fixup_cnt + @row_count;
      EXEC sp_log 1, @fn, '300: pathogens: standardised whitespace: CHAR(160), @fixup_cnt:',@fixup_cnt, @row_count = @row_count;
      UPDATE staging1 SET pathogens = REPLACE(pathogens, NCHAR(160), ' ') WHERE pathogens LIKE  '%'+NCHAR(160)+'%';
      SET @row_count =  @@ROWCOUNT;
      SET @fixup_cnt = @fixup_cnt + @row_count;
      EXEC sp_log 1, @fn, '310: pathogens: standardised whitespace: CHAR(160), @fixup_cnt:',@fixup_cnt, @row_count = @row_count;

      -- 3.2 (was 7) standardise ands
      EXEC sp_log 1, @fn, '320: pathogens: standardise ands, @fixup_cnt:',@fixup_cnt;
      -- Do this before calling fnStanardiseAnds()  because exists: 'Annual and Perennial grasses, sedges and and Broadleaf weeds'
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens',' and & ', ',' , @ndx OUT, @fixup_cnt OUT;

      -- 04-JUL-2023 Added Stanardise Ands (for comparability with staging2)
      UPDATE dbo.staging1 SET pathogens = dbo.fnStandardiseAnds (pathogens) WHERE pathogens LIKE '%&%' OR pathogens LIKE '% and ' OR  pathogens LIKE '% AND '; 
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      -- Remove duplicate ands
      EXEC sp_log 1, @fn, '330: pathogens: remove duplicate ands, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens',' and and ',' and ' , @ndx OUT, @fixup_cnt OUT;

      -- 3.5  make comma space consistent in pathogens and crops
      EXEC sp_log 1, @fn, '350. standardise comma spcs in pathogens, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens',', ', ','      , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens',', ,', ','     , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens', ', ,', ','    , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens', ',,', ','     , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens', ', ', ','     , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens',' ,', ','      , @ndx OUT, @fixup_cnt OUT;

      -- fixup Crops 
      EXEC sp_log 1, @fn, '360:. Fixup crops, @fixup_cnt:',@fixup_cnt;
      EXEC sp_log 1, @fn, '370: crops: standardise comma spc = not counting fixups';
      UPDATE staging1 SET crops = dbo.fnReplace(dbo.fnReplace(crops, N', ', N','), N' ,', N',') WHERE crops LIKE '%, %' OR crops LIKE '% ,%';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '380: crops: replace char(10( with spc, @fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET crops = REPLACE(crops, NCHAR(10),  ' ') WHERE crops LIKE '%'+NCHAR(10)+'%';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      -- fixup phi
      EXEC sp_log 1, @fn, '390: Fixup phi commas and semi-colons, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr 'phi','  ', ' '      , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_fixup_s1_preprocess_hlpr 'phi',';', ','       , @ndx OUT, @fixup_cnt OUT;

      -- 3.6: remove double spaces in crops and pathogens, phi
      EXEC sp_log 1, @fn, '400: crops and pathogens: remove double spaces, @fixup_cnt:',@fixup_cnt;
      EXEC sp_fixup_s1_preprocess_hlpr 'crops', '  ', ' '     , @ndx OUT, @fixup_cnt OUT;
      EXEC sp_fixup_s1_preprocess_hlpr 'pathogens', '  ', ' '     , @ndx OUT, @fixup_cnt OUT;

      -- 10  _, [, ], and ^ need to be escaped, they are special characters in LIKE searches 
      -- replace [] with () here
      EXEC sp_log 1, @fn, '410: crops remove square bracketes [], @fixup_cnt:',@fixup_cnt;
      UPDATE staging1 set crops = Replace(crops, '[', '(') WHERE crops LIKE '%\[%' ESCAPE NCHAR(92);
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      UPDATE staging1 set crops = Replace(crops, ']', ')') WHERE crops LIKE '%\]%' ESCAPE NCHAR(92);
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      -- 11. standardise null fields to default sht, row
      EXEC sp_log 1, @fn, '420: formulation_type: standardise null to default, @fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET formulation_type   = ''                   WHERE formulation_type   IS NULL;
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 1, @fn, '430: toxicity_category: standardise null to default, @fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET toxicity_category  = ''                   WHERE toxicity_category  IS NULL;
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 1, @fn, '440: entry_mode: standardise null to default, @fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET entry_mode         = ''                   WHERE entry_mode         IS NULL;
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 1, @fn, '450: crops: standardise null to default, @fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET crops              = ''                   WHERE crops              IS NULL;
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 1, @fn, '460: pathogens: standardise null to default, @fixup_cnt:',@fixup_cnt;
      UPDATE staging1 SET pathogens          = ''                   WHERE pathogens          IS NULL;
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      -- 12. Camel case the following columns: company, ingredient, product, uses, entry_mode
      EXEC sp_log 1, @fn, '470: Camel case the following columns: company, ingredient, , product, uses, entry_mode, @fixup_cnt:',@fixup_cnt;

      UPDATE staging1 SET 
         company      = dbo.fnCamelCase(company)
       , ingredient   = dbo.fnCamelCase(ingredient)
       , pathogens    = dbo.fnCamelCase(pathogens)
       , [product]    = dbo.fnCamelCase([product])
       , uses         = dbo.fnCamelCase(uses)
       , entry_mode   = dbo.fnCamelCase(entry_mode)
      ;

      --------------------------------------------------------
      -- Completed processing
      --------------------------------------------------------
      EXEC sp_log 1, @fn, '800: completed processing, @fixup_cnt:',@fixup_cnt;
   END TRY
   BEGIN CATCH
      DECLARE @msg VARCHAR(500);
      SET @msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '500: caught exception: ',@msg;
      THROW;
   END CATCH

   SET @row_count_st = @row_count - @row_count_st;
   EXEC sp_log 2, @fn, '999: leaving OK, delta fixup: ',@row_count_st, ' @fixup_cnt: ', @fixup_cnt, @row_count = @fixup_cnt;
END
/*
EXEC sp_fixup_s1_preprocess;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 01-JUL-2023
-- Description: Helper fn to test a fixup
-- operation
-- =============================================
CREATE PROCEDURE [dbo].[sp_chk_fixup_clause]
    @fixup_clause VARCHAR(200)
   ,@col          VARCHAR(60) = 'pathogens'
   ,@table        VARCHAR(60) = 'staging2'
   
AS
BEGIN
   DECLARE 
       @cnt INT
      ,@msg VARCHAR(200)
      ,@sql NVARCHAR(MAX)

   SET NOCOUNT OFF;

   SET @sql = CONCAT('SELECT @cnt = COUNT(*) FROM ',@table, ' WHERE ', @col, ' LIKE ''', @fixup_clause, '''');
   PRINT CONCAT('sql: ', @sql);

   EXEC sp_executesql 
      @sql
      ,N'@cnt INT OUT'
      ,@cnt OUT;
   
   IF @cnt > 0 
   BEGIN
      SET @msg = CONCAT(' there are ', @cnt,' instances of [', @fixup_clause, '] in ', @table);
      THROW 50130, @msg, 1;
   END

   PRINT CONCAT('[',@fixup_clause, '] does not exist in ', @table);
END

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 01-JUL-2023
-- Description: deletes rows from the given table
-- where the col @col is like @delete_clause
-- =============================================
CREATE PROC [dbo].[sp_delete]
    @delete_clause   VARCHAR(500) 
   ,@col             VARCHAR(60) = 'pathogens'
   ,@table           VARCHAR(60) = 'staging2'
AS
BEGIN
   DECLARE 
       @cnt INT
      ,@msg VARCHAR(200)
      ,@sql NVARCHAR(MAX)

   SET NOCOUNT OFF;

   PRINT CONCAT('Removing ',@delete_clause,' from col:[', @col, ' table: [', @table, ']');
   SET @sql = CONCAT('DELETE FROM [', @table, '] WHERE [', @col, '] LIKE ''', @delete_clause, '''');
   PRINT @sql;

   EXEC sp_executesql 
      @sql
      ,N'@cnt INT OUT'
      ,@cnt OUT;
   
   PRINT CONCAT('Deleted ', @@ROWCOUNT, ' rows');
   EXEC sp_chk_fixup_clause @delete_clause, @col,@table;
END
/*
EXEC sp_delete '%NAME OF COMPANY%', 'company', 'staging2'
DELETE FROM [pathogens] WHERE [company] LIKE '%NAME OF COMPANY%'
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 16-JUL-2023
-- Description: Removes the page headers and 
-- other occasional headers
-- =============================================
CREATE PROCEDURE [dbo].[sp_fixup_s1_rem_hdrs]
      @fixup_cnt       INT = NULL OUT
AS
BEGIN
   DECLARE
       @fn              VARCHAR(35) = 'FIXUP sp_fixup_s1_rem_hdrs REM HDRS'

   SET NOCOUNT OFF;

   BEGIN TRY
      IF @fixup_cnt IS NULL SET @fixup_cnt = dbo.fnGetSessionContextAsInt(N'fixup count');
      EXEC sp_log 1, @fn, '000: starting, @fixup_cnt: ',@fixup_cnt

      EXEC sp_log 1, @fn, '010: Remove page header rows'
      EXEC sp_delete '%NAME OF COMPANY%'            , 'company', 'staging1';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_delete '%REPUBLIC OF THE PHILIPPINES%', 'company', 'staging1';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 1, @fn, '030: Removing rows where company LIKE REPUBLIC OF THE PHILIPPINES'
      EXEC sp_delete '%REPUBLIC OF THE PHILIPPINES%', 'company', 'staging1';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 1, @fn, '040: Removing rows where company LIKE DEPARTMENT OF AGRICULTURE'
      EXEC sp_delete '%NAME OF COMPANY%'     , 'company', 'staging1';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 0, @fn, '050: Removing rows where company LIKE DEPARTMENT OF AGRICULTURE'
      EXEC sp_delete '%Department Of Agriculture%'     , 'company', 'staging1';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 0, @fn, '060: Removing rows where company LIKE FERTILIZER AND PESTICIDE AUTHORITY'
      EXEC sp_delete '%FERTILIZER AND PESTICIDE AUTHORITY%', 'company', 'staging1';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 0, @fn, '070: sp_fixup_staging1: Removing rows where company LIKE LIST OF REGISTERED AGRICULTURAL PESTICIDES'
      EXEC sp_delete '%LIST OF REGISTERED AGRICULTURAL PESTICIDES%', 'company', 'staging1';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

      EXEC sp_log 1, @fn, '080: DELETE ''as of %'' rows'
      EXEC sp_delete '%as of %', 'company', 'staging1';
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;
      EXEC sp_log 1, @fn, '090: DELETE null company,ingredient,product'
      DELETE FROM staging1 WHERE company IS NULL AND product IS NULL AND ingredient IS NULL;
      SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, '@fixup_cnt: ',@fixup_cnt;
      THROW;
   END CATCH
      
   EXEC sp_log 2, @fn, '99: leaving, @fixup_cnt: ',@fixup_cnt
END
/*
EXEC sp_fixup_s1_rem_hdrs
SELECT * FROM staging1 where pathogens LIKE  '% and and %'
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 03-AUG-2023
-- Description: Fixup for the rate column 
-- =============================================
CREATE PROCEDURE [dbo].[sp_fixup_s1_rate]
      @fixup_cnt     INT OUT --- = NULL 
AS
BEGIN
   DECLARE
       @fn           VARCHAR(35) = 'FIXUP STG1 RATE'
      ,@fixup_delta  INT = 0

   SET NOCOUNT OFF;

   BEGIN TRY
      EXEC sp_log 2, @fn, '01: starting, @fixup_cnt: ',@fixup_cnt;
      --EXEC sp_register_call @fn;

      UPDATE staging1 SET rate = NULL where rate in ('-','_');
      SET @fixup_delta = @fixup_delta + @@ROWCOUNT;
   END TRY
   BEGIN CATCH
      DECLARE @error_msg VARCHAR(MAX);
      SET @error_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, ' caught exception: ', @error_msg, ' , @fixup_cnt: ',@fixup_cnt;
      THROW;
   END CATCH

   SET  @fixup_cnt = @fixup_cnt + @fixup_delta ;
   EXEC sp_log 2, @fn, '99: leaving OK, @fixup_cnt: ',@fixup_cnt;
END
/*
SELECT distinct rate from staging1 ORDER BY rate
EXEC sp_fixup_s1
SELECT id, product, rate FROM staging1 where rate LIKE  '%tbsp./3-5 L water%' ORDER by rate, id
SELECT id, product, rate FROM staging1 where id in
(581,601,840,1004,1256,1446,1633,2518,3261,3829,4070,4292,4767,5676,5825,6245,7857,7918,7933
,8980,9209,9411,9745,10014,10174,11915,12573,13142,13254,13491,14178,14250,14749,14760,15194
,15406,17254,17669,18107,18247,18762,19128,19277,20238,21240,21247,22107,22362,22820,23130,23494
,23573,23732,24077,24263,24478,24486,24840,25283,25563)

SELECT id, product, rate FROM staging1 where rate LIKE  '%-1¢%Tbsp/16 L of water%'
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ---------------------------------------------------------------------------------------------------------------------
-- Author:      Terry Watts
-- Create date: 29-JAN-2024
-- Description: does the following std preprocess:
--    Remove header rows
--    fixup spelling errors:
--    [Perrenial] -> [Perennial]
--
-- RESPONSIBILITIES:
--  Fixup:
--    1. spelling errors:
--       [Perrenial] -> [Perennial]
--
-- POST CONDITIONS:
-- POST 01: no header rows exists in S1
-- POST 02: [Perennial] spelling errors corrected
--
-- CALLED BY: sp_fixup_s1
-- CHANGES:
-- 241105: Remove header rows 
-- 250107: pathogens: remove trailing commas
-- ---------------------------------------------------------------------------------------------------------------------
CREATE   PROCEDURE [dbo].[sp_fixup_s1_pathogens]
      @fixup_cnt       INT = 0 OUT
AS
BEGIN
   DECLARE
       @fn           VARCHAR(35)= 'S1_FIXUP_PATHOGENS'
      ,@row_count    INT
      ,@ndx          INT         = 3
      ,@spc          VARCHAR(1) = N' '

   SET NOCOUNT OFF;

   BEGIN TRY
      EXEC sp_log 2, @fn, '000: starting';

      -- ---------------------------------------------------------
      --    1. Remove header rows 
      -- ---------------------------------------------------------
      DELETE FROM Staging1 WHERE company = 'NAME OF COMPANY';
      SET @row_count = @@ROWCOUNT
      SET @fixup_cnt = @fixup_cnt + @row_count;
      EXEC sp_log 1, @fn, '005: removed ',@row_count, ' header rows from staging 1';

      -- ---------------------------------------------------------
      --    1. fixup spelling errors: 
      -- ---------------------------------------------------------
      EXEC sp_log 1, @fn, '010: fixup spelling errors [Perrenial]->[Perennial]';
      --       [Perrenial] -> [Perennial]
      UPDATE staging1 SET pathogens   = REPLACE(pathogens    , 'Perrenial', 'Perennial') WHERE company    LIKE  '%Perrenial%';
      SET @row_count = @@ROWCOUNT
      SET @fixup_cnt = @fixup_cnt + @row_count;
      EXEC sp_log 1, @fn, '020: fixup [Perrenial] -> [Perennial] updated ', @row_count, ' rows';

      -- 250107: pathogens: remove trailing commas
       UPDATE staging1 SET pathogens   = TRIM(',' FROM pathogens) WHERE pathogens LIKE '%,';
      SET @row_count = @@ROWCOUNT
      SET @fixup_cnt = @fixup_cnt + @row_count;
      EXEC sp_log 1, @fn, '030: removed trailing commas, updated ', @row_count, ' rows';

         -----------------------------------------------------------------------------------
         -- Completed processing
         -----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '800: fixup spelling errors completed';
   END TRY
   BEGIN CATCH
      DECLARE @msg VARCHAR(500);
      SET @msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fn, '500: caught exception: ',@msg;
      throw;
   END CATCH

   EXEC sp_log 2, @fn, '999: leaving OK, @fixup_cnt: ', @fixup_cnt, @row_count = @fixup_cnt;
END
/*
EXEC sp_fixup_s1_pathogens;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ================================================================================================
-- Author:      Terry Watts
-- Create date: 16-JUL-2023
-- Description: perform the stage 1 postcondition checks on the staging1 table
--
-- PRECONDITIONS: none
--
-- POSTCONDITIONS:
-- POST 01: no 'double and'
-- POST 02: no double quotes in flds: {company, ingredient, product, crops, entry_mode, pathogens, uses}
-- POST 03: no null fields tests in {company, ingredient, product, concentration, crops, formulation_type
--    uses, pathogens, toxicity_category, registrations, expiry dates, entry_modes)
--
-- CHANGES:
-- 21-JAN-2024 Added check for no double quotes in the uses field 
-- ================================================================================================
CREATE   PROCEDURE [dbo].[sp_fixup_s1_postcondition_checks] 
AS
BEGIN
   DECLARE
       @fn              VARCHAR(30)   = 'S1_FIXUP_POSTCONDITION_CHECKS'
      ,@RC              INT            = 0
      ,@result_msg      VARCHAR(500)  = ''
      ,@cnt             INT            = 0
      ,@default_fld_val VARCHAR(15)   = '*** UNKNOWN ***'
      ,@sql             VARCHAR(MAX)  = ''

   EXEC sp_log 2, @fn, '01: starting'
   -- POST 01: no 'double and' in the following fields: {company, ingredient, product, crops, entry_mode, pathogens, uses}
   EXEC sp_log 2, @fn, 'POST 01: no ''double and'' in the following fields: {company, ingredient, product, crops, entry_mode, pathogens, uses}'
   IF EXISTS (SELECT 1 FROM staging1 WHERE pathogens like '% and and %') THROW 60400,'AND AND present in S1.pathogens',1

   -- POST 02: no double quotes in the following fields: {company, ingredient, product, crops, entry_mode, pathogens, uses}
   EXEC sp_log 2, @fn, 'POST 01: no double quotes test in the following fields: {company, ingredient, product, crops, entry_mode, pathogens, uses}'
   SELECT @cnt = COUNT(*) FROM staging1  WHERE company LIKE '%"%'
   IF @cnt > 0 Throw 50130, '" still exists in s1.company', 1
   SELECT @cnt = COUNT(*) FROM staging1  WHERE ingredient LIKE '%"%'
   IF @cnt > 0 Throw 50131, '" still exists in s1.ingredient', 1
   SELECT @cnt = COUNT(*) FROM staging1  WHERE product LIKE '%"%'
   IF @cnt > 0 Throw 50132, '" still exists in s1.product', 1
   SELECT @cnt = COUNT(*) FROM staging1  WHERE crops LIKE '%"%'
   IF @cnt > 0 Throw 50133, '" still exists in s1.crops', 1
   SELECT @cnt = COUNT(*) FROM staging1  WHERE entry_mode LIKE '%"%'
   IF @cnt > 0 Throw 50134, '" still exists in s1.entry_mode', 1
   SELECT @cnt = COUNT(*) FROM staging1  WHERE pathogens LIKE '%"%'
   IF @cnt > 0 Throw 50135, '" still exists in s1.pathogens', 1
   SELECT @cnt = COUNT(*) FROM staging1  WHERE uses LIKE '%"%'
   IF @cnt > 0 Throw 50135, '" still exists in s1.uses', 1

   -- POST 03.1,: no null fields tests in {company, ingredient, product}
   EXEC sp_log 2, @fn, 'POST 03.1: no null fields tests in {company, ingredient, product}'
   SELECT @cnt = COUNT(*) FROM staging1 WHERE company           IS NULL;         
   IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL companies in S1';
   SELECT @cnt = COUNT(*) FROM staging1 WHERE ingredient        IS NULL;       
   IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL ingredients in S1';
   SELECT @cnt = COUNT(*) FROM staging1 WHERE product           IS NULL;          
   IF @cnt > 0  EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL products in S1';

   -- POST 03.2,: no null fields in {company, ingredient, product, concentration, crops, formulation_type, uses, pathogens, toxicity_category}
   EXEC sp_log 2, @fn, 'POST 03.2: null fields tests in concentration, crops, formulation_type, uses, pathogens, toxicity_category'
   SELECT @cnt = COUNT(*) FROM staging1 WHERE concentration     IS NULL;    
   IF @cnt > 0 EXEC sp_log 3, @fn, '50: there are ', @cnt, ' NULL concentration values in S1'; -- WARNING ONLY
   SELECT @cnt = COUNT(*) FROM staging1 WHERE formulation_type  IS NULL; 
   IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL formulation_types in S1';
   SELECT @cnt = COUNT(*) FROM staging1 WHERE uses              IS NULL;             
   IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL uses in S1';
   SELECT @cnt = COUNT(*) FROM staging1 WHERE toxicity_category IS NULL;
   IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL toxicity_categories in S1';

   -- POST 03.3,: no null fields in {registrations, expiry dates, entry_modes}
   EXEC sp_log 2, @fn, 'POST 03.3: no null fields in {registrations, expiry dates, entry_modes}'
   SELECT @cnt = COUNT(*) FROM staging1 WHERE registration     IS NULL;    
   IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL registrations in S1';

   SELECT @cnt = COUNT(*) FROM staging1 WHERE entry_mode            IS NULL;           
   IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL entry_mode in S1';

   SELECT @cnt = COUNT(*) FROM staging1 WHERE expiry            IS NULL;           
   IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL expiry dates in S1';
   
   --SELECT @cnt = COUNT(*) FROM staging1 WHERE entry_mode        IS NULL;       
   --IF @cnt > 0 EXEC sp_log 4, @fn, '50: there are ', @cnt, ' NULL entry_modes';
   EXEC sp_log 2, @fn, '99: leaving, all ok, rc:', @rc,' msg:[', @result_msg,']';
END
/*
EXEC sp_fixup_s1_chks
EXEC sp__main_import_pesticide_register @import_file = 'D:\Dev\Repos\Farming\Data\Exports Ph DepAg Registered Pesticides LRAP-230721.pdf\LRAP-20230721.tsv.txt', @mode='LOG_LEVEL:1', @stage = 0 -- full
select * FROM staging1 where company is null
SELECT * FROM Staging1

*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===================================================================================
-- Author:      Terry Watts
-- Create date: 26-JUN-2023
-- Description: Tidies up staging 1 after import so that it is comparable to staging2
--
-- RESPONSIBILITIES:
-- Remove:
-- the page header rows
-- wrapping quotes
-- standarise commas and &
-- spelling errors:
--    [Perrenial] -> [Perennial]
--
-- Error handling by exception handling
--
-- Preconditions: 
-- PRE 01: staging1 pop'd
--
-- returns 
--       (0 if success and @result_msg='') OR Error code and result_msg=error message
--
-- Postconditions:
-- POST 01: no occasional page headers as in LDAP 221008 version
-- POST 02: no wrapping quotes in the following fields {}         see sp_fixup_s1_preprocess
-- POST 03: no double quotes in flds: {company, ingredient, product, crops, entry_mode, pathogens, uses}
-- POST 04: no null fields tests in {company, ingredient, product, concentration, crops, formulation_type
--    uses, pathogens, toxicity_category, registrations, expiry dates, entry_modes)
-- POST 05: camel case the following fields {}                    see sp_fixup_s1_preprocess
-- POST 06: no double spaces in the following fields: {company, ingredient, product, crops, entry_mode, pathogens, uses}
-- POST 07: Fixup entry mode (Actions) issues                     see sp_fixup_s1_entry_mode
-- POST 08: Fixup Rate issues                                     see sp_fixup_s1_rate
-- POST 09: see sp_fixup_s1_chks
-- POST 10: no 'double and'
-- POST 11: no spelling errors
--
-- CHANGES:
-- 02-JUL-2023 Added CamelCase of various fields (for readability)
-- 04-JUL-2023 Added Stanardise Ands (for comparability with staging2)
-- 04-JUL-2023 Added Trim [] and double quotes
-- 04-JUL-2023 pathogens: á'
-- 16-JUL-2023 refactored
-- 21-JAN-2024 replace uses, 'Insecticide/fu ngicide' with 'Insecticide,fungicide'
-- ===================================================================================
CREATE PROCEDURE [dbo].[sp_fixup_s1]
   @fixup_cnt INT OUTPUT
AS
BEGIN
   DECLARE
       @fn              VARCHAR(30)   = 'sp_fixup_s1'
      ,@RC              INT            = 0
      ,@result_msg      VARCHAR(500)  = ''
      ,@cnt             INT            = 0
      ,@default_fld_val VARCHAR(15)   = '*** UNKNOWN ***'
      ,@sql             NVARCHAR(MAX)  = ''

   EXEC sp_log 2, @fn, '000: starting';

   ---------------------------------------------------------------------
   -- Validation
   ---------------------------------------------------------------------
   EXEC sp_log 2, @fn, '010: Validating parameters';
   EXEC sp_assert_not_null @fixup_cnt, '@fixup_cnt',@fn=@fn;

   -- PRE 01: staging1 pop'd
   EXEC sp_assert_tbl_pop 'staging1';

   ---------------------------------------------------------------------
   -- ASSERTION Validated parameters
   ---------------------------------------------------------------------
   EXEC sp_log 2, @fn, '020: ASSERTION: Validated parameters';

   IF @fixup_cnt IS NULL SET @fixup_cnt = dbo.fnGetSessionContextAsInt(N'fixup count');

   ---------------------------------------------------------------------
   -- Process
   ---------------------------------------------------------------------
   EXEC sp_log 1, @fn, '030: Process';
   EXEC sp_log 1, @fn, '040: removing occasional headers, calling: sp_fixup_s1_rem_hdrs';

   -- Remove occasional headers
   EXEC sp_fixup_s1_rem_hdrs @fixup_cnt OUT

   -- Std preprocess like removing wrapping quotes, camel case etc.
   EXEC sp_log 1, @fn, '050: removing wrapping quotes, camelcase list items, calling: sp_fixup_s1_preprocess';
   EXEC sp_fixup_s1_preprocess @fixup_cnt OUT;

   -- Specifics
   EXEC sp_log 1, @fn, '060: calling sp_fixup_s1_pathogens';
   EXEC sp_fixup_s1_pathogens @fixup_cnt OUT
   EXEC sp_log 1, @fn, '070: removing double spaces in company field';
   UPDATE staging1 SET company = REPLACE(company, '  ', ' ') WHERE company LIKE '%  %';
   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

   -- 21-JAN-2024 replace uses, 'Insecticide/fu ngicide' with 'Insecticide,fungicide'
   UPDATE staging1 SET uses = REPLACE(uses, 'Insecticide/fu ngicide', 'Insecticide,Fungicide') WHERE uses LIKE '%Insecticide/fu ngicide%';
   SET @fixup_cnt = @fixup_cnt + @@ROWCOUNT;

   -- Fixup entry mode (Actions) issues
   --EXEC sp_log 1, @fn, '05: Fixup entry mode (Actions) issues, calling sp_fixup_s1_entry_mode';
   --EXEC  sp_s1_fixup_entry_mode @fixup_cnt OUT;

   -- Fixup Rate issues
   EXEC sp_log 1, @fn, '080: Fixup Rate issues, calling sp_fixup_s1_rate';
   EXEC sp_fixup_s1_rate @fixup_cnt OUT;

   -- Checks
   EXEC sp_log 1, @fn, '090: perform post condition checks, calling sp_fixup_s1_chks';
   EXEC  dbo.sp_fixup_s1_postcondition_checks;

   EXEC sp_log 2, @fn, '999: leaving OK, @fixup_cnt: ', @fixup_cnt
END
/*
   EXEC sp_copy_staging1_s1_bak;
   EXEC sp_fixup_s1;
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ===================================================================================
-- Author:      Terry Watts
-- Create date: 20-JUN-2023
-- Description: copy (replaces) Staging2 with all of Staging1
--    Does some simple initital fixup. Can use S1 as a backup
-- CHANGES:
-- 231103: turned auto increment off so SET IDENTITY_INSERT ON/OFF not needed
-- 231106: increase S2 pathogens col sz from 180 to 360 - as issues in 231005 import
-- ===================================================================================
CREATE   PROCEDURE [dbo].[sp_cpy_s1_s2]
AS
BEGIN
   DECLARE 
       @rc   INT = 0
      ,@cnt  INT = 0
      ,@result_msg   VARCHAR(500) = NULL
      ,@fn           VARCHAR(500) = 'CPY_S1_S2'

   SET NOCOUNT OFF;

   BEGIN TRY
      EXEC sp_log 1, @fn, '00:starting';
      --EXEC sp_register_call @fn;
      SET XACT_ABORT ON;

      EXEC sp_log 0, @fn, '01: truncating S2   ';

      TRUNCATE TABLE Staging2;
      SET @rc = @@ERROR;

      IF @RC <> 0
      BEGIN
         SET @result_msg = CONCAT('stage 1 TRUNCATE TABLE Staging2; failed: ',ERROR_MESSAGE());
         EXEC sp_log 4, @fn, @result_msg;
         THROW 50600, @result_msg, 1;
      END

      EXEC sp_log 1, @fn, '03: about to copy s1 -> S2   ';

      INSERT INTO dbo.staging2
      (
          id
         ,company
         ,ingredient
         ,product
         ,concentration
         ,formulation_type
         ,uses
         ,toxicity_category
         ,registration
         ,expiry
         ,entry_mode
         ,crops
         ,pathogens
         ,rate
         ,mrl
         ,phi
         ,reentry_period
         ,notes
         ,created
      )
      SELECT 
          id
         ,company
         ,ingredient
         ,product
         ,concentration
         ,formulation_type
         ,uses
         ,toxicity_category
         ,registration
         ,expiry
         ,entry_mode
         ,crops
         ,pathogens
         ,rate
         ,mrl
         ,phi
         ,reentry_period
         ,notes
         ,created
      FROM dbo.staging1;

      EXEC sp_log 1, @fn, '04: copied s1 -> S2   ';
      SET @rc  = @@ERROR;
      SET @cnt = @@ROWCOUNT;

      IF @RC <> 0
      BEGIN
         SET @result_msg = CONCAT('stage 2 insert failed: ',ERROR_MESSAGE());
         EXEC sp_log 4, @fn, @result_msg;
         THROW 50601, @result_msg, 1;
      END

      EXEC sp_log 1, @fn, '05: success   ';
   END TRY
   BEGIN CATCH
      DECLARE @error_msg VARCHAR(500);
      SET @error_msg = ERROR_MESSAGE();
      SET @RC = -1;
      EXEC sp_log 4, @fn, '50: caught exception: ', @error_msg;
      THROW;
   END CATCH
   EXEC sp_log 1, @fn, 'leaving ok';
END
/*
EXEC sp_copy_s1_s2;
SELECT * FROM staging1;
SELECT MAX(dbo.fnLen(pathogens)) FROM staging1;
SELECT id, dbo.fnLen(pathogens), pathogens FROM staging1 WHERE dbo.fnLen(pathogens) > 200 ORDER BY dbo.fnLen(pathogens) DESC;
SELECT * FROM staging2 where pathogens LIKE '%-%';
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[staging3](
	[id] [int] NOT NULL,
	[company] [varchar](60) NULL,
	[ingredient] [varchar](100) NULL,
	[product] [varchar](50) NULL,
	[concentration] [varchar](50) NULL,
	[formulation_type] [varchar](50) NULL,
	[uses] [varchar](50) NULL,
	[toxicity_category] [varchar](50) NULL,
	[registration] [varchar](100) NULL,
	[expiry] [varchar](100) NULL,
	[entry_mode] [varchar](60) NULL,
	[crops] [varchar](200) NULL,
	[pathogens] [varchar](200) NULL,
	[rate] [varchar](200) NULL,
	[mrl] [varchar](200) NULL,
	[phi] [varchar](200) NULL,
	[phi_resolved] [varchar](120) NULL,
	[reentry_period] [varchar](250) NULL,
	[notes] [varchar](250) NULL,
	[comments] [varchar](500) NULL,
	[created] [datetime] NULL,
 CONSTRAINT [PK_staging3] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'resolved to days' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'staging3', @level2type=N'COLUMN',@level2name=N'phi_resolved'

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==============================================================================
-- Author:      Terry Watts
-- Create date: 09-JUL-2023
-- Description: Caches a copy of Staging2 to Staging3 
--    Do after any stage once S2 is populated
--
-- CHANGES:
-- 231103: turned auto increment off so SET IDENTITY_INSERT ON/OFF not needed
-- ==============================================================================
CREATE PROCEDURE [dbo].[sp_cpy_s2_s3]
AS
BEGIN
   DECLARE
       @fn           VARCHAR(35)  = N'CPY_S2_S3'

   SET NOCOUNT OFF;
   EXEC sp_log 2, @fn,'00: Caching COPYING staging2 to staging3 (backup) starting';

   TRUNCATE TABLE Staging3;

   INSERT INTO dbo.Staging3
   (
       id
      ,company
      ,ingredient
      ,product
      ,concentration
      ,formulation_type
      ,uses
      ,toxicity_category
      ,registration
      ,expiry
      ,entry_mode
      ,crops
      ,pathogens
      ,rate
      ,mrl
      ,phi
      ,phi_resolved
      ,reentry_period
      ,notes
      ,comments
   )
   SELECT 
       id
      ,company
      ,ingredient
      ,product
      ,concentration
      ,formulation_type
      ,uses
      ,toxicity_category
      ,registration
      ,expiry
      ,entry_mode
      ,crops
      ,pathogens
      ,rate
      ,mrl
      ,phi
      ,phi_resolved
      ,reentry_period
      ,notes
      ,Comments
     FROM Staging2;

   EXEC sp_log 2, @fn,'99: leaving: OK';
END
/*
EXEC sp_copy_s2_s3
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ===============================================================
-- Author:      Terry Watts
-- Create date: 09-JUL-2023
-- Description: Restores Staging2 from Staging3 cache.
-- ===============================================================
CREATE PROCEDURE [dbo].[sp_cpy_s3_s2]
AS
BEGIN
   DECLARE @fn VARCHAR(35)  = N'CPY_S3_S2'
   EXEC sp_log 1, @fn, 'starting'
   SET NOCOUNT OFF;

   TRUNCATE TABLE Staging2;

   INSERT INTO [dbo].[Staging2]
   (
       id
      ,company
      ,ingredient
      ,product
      ,concentration
      ,formulation_type
      ,uses
      ,toxicity_category
      ,registration
      ,expiry
      ,entry_mode
      ,crops
      ,pathogens
      ,rate
      ,mrl
      ,phi
      ,phi_resolved
      ,reentry_period
      ,comments
    )
    SELECT 
       id
      ,company
      ,ingredient
      ,product
      ,concentration
      ,formulation_type
      ,uses
      ,toxicity_category
      ,registration
      ,expiry
      ,entry_mode
      ,crops
      ,pathogens
      ,rate
      ,mrl
      ,phi
      ,phi_resolved
      ,reentry_period
      ,comments
   FROM Staging3;

   EXEC sp_log 1, @fn, 'leaving ok'
END
/*
EXEC  sp_copy_s3_s2
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- =============================================================================================
-- Author:      Terry Watts
-- Create date: 17-NOV-2024
-- Description: This validates the preconditions for sp_find_unmatched_dynamic_data
--
-- POSTCONDITIONS:
--    ChemicalStaging         populated or exception 63859, 'ChemicalStaging has null chemical_nm fields', 1;
--    ChemicalActionStaging   populated or exception 63859, 'ChemicalActionStaging has null chemical_nm or action_nm fields', 1;
--    ChemicalProductStaging  populated or exception 63859, 'ChemicalProductStaging has null  fields', 1;
--    ChemicalUseStaging      populated or exception 63859, 'ChemicalUseStaging has null chemical_nm or use_nm fields', 1;
--    CompanyStaging          populated or exception 63859, 'CompanyStaging has null  fields', 1;
--    CropPathogenStaging     populated or exception 63859, 'CropPathogenStaging has null crop_nm OR pathogen_nm fields', 1;
--    PathogenChemicalStaging populated or exception 63859, 'PathogenChemicalStaging has null pathogen_nm or chemical_nm fields', 1;
--    ProductCompanyStaging   populated or exception 63859, 'ProductCompanyStaging has null company_nm or product_nm fields', 1;
--    ProductStaging          populated or exception 63859, 'ProductStaging has null product_nm fields', 1;
--    ProductUseStaging       populated or exception 63859, 'ProductUseStaging has null product_nm OR use_nm fields', 1;
-- =============================================================================================
CREATE   PROCEDURE [dbo].[sp_fnd_unregistered_dyndta_chk_precndtns]
AS
BEGIN
   DECLARE
    @fn        VARCHAR(35)   = N'sp_fnd_unmtchd_dyndta_chk_precndtns'
   ;

   SET NOCOUNT ON;
   EXEC sp_log 2, @fn,'000: starting';

   --------------------------------------------------------------------
   -- Validate preconditions
   --------------------------------------------------------------------

   EXEC sp_log 1, @fn,'010: validating preconditions: dynamic data populated';

   IF EXISTS (SELECT 1 FROM ChemicalStaging           WHERE chemical_nm IS NULL)                         --THROW 63859, 'ChemicalStaging has null chemical_nm fields', 1;
   BEGIN
      SELECT * FROM ChemicalStaging  WHERE chemical_nm IS NULL;
      THROW 63859, 'ChemicalStaging has null chemical_nm fields', 1;
   END

   IF EXISTS (SELECT 1 FROM ChemicalActionStaging     WHERE chemical_nm IS NULL OR action_nm IS NULL)    --THROW 63859, 'ChemicalActionStaging has null chemical_nm or action_nm fields', 1;
   BEGIN
      SELECT* FROM ChemicalActionStaging     WHERE chemical_nm IS NULL OR action_nm IS NULL
   END

   IF EXISTS (SELECT 1 FROM ChemicalStaging           WHERE chemical_nm IS NULL)                         THROW 63859, 'ChemicalStaging has null chemical_nm fields', 1;
   IF EXISTS (SELECT 1 FROM ChemicalActionStaging     WHERE chemical_nm IS NULL OR action_nm IS NULL)    THROW 63859, 'ChemicalActionStaging has null chemical_nm or action_nm fields', 1;
   IF EXISTS (SELECT 1 FROM ChemicalProductStaging    WHERE chemical_nm IS NULL OR product_nm IS NULL)   THROW 63859, 'ChemicalProductStaging has null  fields', 1;
   IF EXISTS (SELECT 1 FROM ChemicalUseStaging        WHERE chemical_nm IS NULL OR use_nm IS NULL)       THROW 63859, 'ChemicalUseStaging has null chemical_nm or use_nm fields', 1;
   IF EXISTS (SELECT 1 FROM CompanyStaging            WHERE company_nm IS NULL )                         THROW 63859, 'CompanyStaging has null  fields', 1;
   IF EXISTS (SELECT 1 FROM CropPathogenStaging       WHERE crop_nm IS NULL OR pathogen_nm IS NULL  )    THROW 63859, 'CropPathogenStaging has null crop_nm OR pathogen_nm fields', 1;
   IF EXISTS (SELECT 1 FROM PathogenChemicalStaging   WHERE pathogen_nm IS NULL OR chemical_nm IS NULL)  THROW 63859, 'PathogenChemicalStaging has null pathogen_nm or chemical_nm fields', 1;
   IF EXISTS (SELECT 1 FROM ProductCompanyStaging     WHERE company_nm IS NULL OR product_nm IS NULL)    THROW 63859, 'ProductCompanyStaging has null company_nm or product_nm fields', 1;
   IF EXISTS (SELECT 1 FROM ProductStaging            WHERE product_nm IS NULL)                          THROW 63859, 'ProductStaging has null product_nm fields', 1;
   IF EXISTS (SELECT 1 FROM ProductUseStaging         WHERE product_nm IS NULL OR use_nm IS NULL)        THROW 63859, 'ProductUseStaging has null product_nm OR use_nm fields', 1;

   --------------------------------------------------------------------
   -- ASSERTION: sp_find_unmatched_dynamic_data preconditions valid
   --------------------------------------------------------------------
   EXEC sp_log 2, @fn, '999: leaving, ASSERTION: sp_find_unmatched_dynamic_data preconditions valid';
END
/*
EXEC sp_find_unmatched_dynamic_data;

SELECT COUNT(*) FROM ChemicalStaging        
SELECT COUNT(*) FROM ChemicalActionStaging  
SELECT COUNT(*) FROM ChemicalProductStaging 
SELECT COUNT(*) FROM ChemicalUseStaging     
SELECT COUNT(*) FROM CompanyStaging         
SELECT COUNT(*) FROM CropPathogenStaging    
SELECT COUNT(*) FROM PathogenChemicalStaging
SELECT COUNT(*) FROM ProductCompanyStaging  
SELECT COUNT(*) FROM ProductStaging         
SELECT COUNT(*) FROM ProductUseStaging      
*/
/* 6 rows
Insecticide,fungicide
Insecticide / Nematicide
-
Others*
Insecticide/ Nematicide
Pgr
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==================================================================================================
-- Author:      Terry Watts
-- Create date: 10-DEC-2024
-- Description: returns the body of the select unregistered items SQL
--
-- Notes:
-- There are 2 types of field in staging2
-- 1: single value fields like Company, Product, concentration, formulation_type,toxicity, reg,expiry
-- 2: multi  value fields like ingredient, uses, entry_mode, crops, pathogens
-- These need handling differently
--
-- Preconditions: all parameters must be valid
-- Postconditions: output valid SQL body part to find the unregistered
--                 items for valid inoputs parameters
-- ==================================================================================================
CREATE FUNCTION [dbo].[fnCrtFndUnregisterdItemsSql]
(
    @is_multi_value  BIT
   ,@stg_field_nm    NVARCHAR(40)
   ,@table_nm        NVARCHAR(60)
   ,@pk_table_nm     NVARCHAR(40)
   ,@pk_field_nm     NVARCHAR(40)
   ,@sep             NVARCHAR(1)
)
RETURNS NVARCHAR(4000)
AS
BEGIN
   DECLARE
       @sql          NVARCHAR(4000)
      ,@nl           NCHAR(2) = NCHAR(13)+NCHAR(10)
      ,@tab          NCHAR(3) = '   '
   ;

-- 241210: handle multi value fields differently
-- There are 2 types of field in staging2
-- 1: single value fields like Company, Product, concentration, formulation_type,toxicity, reg,expiry
-- 2: multi  value fields like ingredient, uses, entry_mode, crops, pathogens
-- These need handling differently
   IF @table_nm       IS NULL SET @table_nm       = 'Staging2';
   IF @pk_table_nm    IS NULL SET @pk_table_nm    = dbo.fnRTrim2(@stg_field_nm, 's');
   IF @pk_field_nm    IS NULL SET @pk_field_nm    = CONCAT(dbo.fnRTrim2(@stg_field_nm, 's'), '_nm');
   IF @is_multi_value IS NULL SET @is_multi_value = iif(@stg_field_nm IN ('ingredient','uses','entry_mode','crops','pathogens'),1, 0);

   SET @sql = iif
   (
       @is_multi_value = 0
      ,CONCAT
      (
'(',@nl
,@tab,'SELECT DISTINCT TOP 1000 [', @stg_field_nm,'] AS item',@nl
,@tab,'FROM [', @table_nm,']',@nl
,@tab,'WHERE [', @stg_field_nm,'] NOT IN',@nl
,@tab,'(',@nl
,@tab,@tab,'SELECT [', @pk_field_nm,']',@nl
,@tab,@tab,'FROM [', @pk_table_nm,']', @nl
,@tab, ')', @nl
,') AS X;')

      ,CONCAT
      (@nl
,'(',@nl
,@tab,'SELECT DISTINCT TOP 1000 value AS item',@nl
,@tab,'FROM Staging2 CROSS APPLY string_split([', @stg_field_nm,'], ''',@sep, ''')',@nl
,@tab,'WHERE value NOT IN',@nl
,@tab,'(',@nl
,@tab,@tab,'SELECT [', @pk_field_nm,']', @nl
,@tab,@tab,'FROM [', @pk_table_nm,']',@nl
,@tab,')',@nl
,') X;')
   ); -- end iif

   --SET @sql = CONCAT(@sql,@NL, N'ORDER BY [', @stg_field_nm,'];');
   RETURN @sql;
END
/*
EXEC sp_fnd_unregistered_dynamic_data;
EXEC tSQLt.Run 'test.test_007_fnCrtFndUnregisterdItemsSql';

PRINT dbo.fnCrtFndUnregisterdItemsSql(1,'pathogens','staging2','Pathogen', 'pathogen_nm', ',');
GO
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ========================================================================================================================
-- Author:      Terry Watts
-- Create date: 17-NOV-2024
-- Description: This lists the unregisterd items in in staging2 for the given field table and logs message
--              and adds the count of unregisterd items to @unmtchd_cnt
--  e.g Pathogen, pathogens
--
-- Notes:
-- There are 2 types of field in staging2
-- 1: single value fields like Company, Product, concentration, formulation_type,toxicity, reg,expiry
-- 2: multi  value fields like ingredient, uses, entry_mode, crops, pathogens
-- These need handling differently
--
-- Design: Farming.eap/Model.SQLServer2012/Procedures/Fixup rtns/Find unmatched dynamic data/
--    Create the select sql/Create the select sql ACT

-- Paramaters:
-- @stg_field_nm:    the staging2 field holding the items to check if they are registered MANDATORY
-- @table_nm:        the primary table holding the list of registered items, default: RTrim2(@stg_field_nm, 's')
-- @pk_field_nm      the pk field of the primary table, default: 
-- @display_tables   optional if true then the list of unregistered items is displayed 
-- @unmtchd_cnt      optional if not null then the count of unregistered items is returned
--
-- Responsibilities:
-- R01: displays a list of unregisterd items in staging2 the given item table
-- R02: populate the dbo.UnregisteredItem table with the unregisterd item data
-- R03: logs message if unregistered items found : level 3, 'found <@cnt> unregistered <table_nm>';
--
-- PRECONDITIONS: none
--
-- POSTCONDITIONS:
-- POST 01: aggregates the count of unregistered items intp @unmtchd_cnt i.e unmtchd_cnt=unmtchd_cnt+cnt of unmtched items
-- POST 02: if @display_tables true then the list of unregistered items is displayed
--
-- Changes:
-- 241210: handle multi value fields differently
-- ========================================================================================================================
CREATE PROCEDURE [dbo].[sp_fnd_unregistered_dyndta_hlpr]
    @stg_field_nm    NVARCHAR(60)
   ,@table_nm        NVARCHAR(60)   = NULL -- default is Staging2
   ,@pk_table_nm     NVARCHAR(60)   = NULL -- default is RTrim(@stg_field_nm, 's') + '_nm'
   ,@pk_field_nm     NVARCHAR(60)   = NULL -- default is @table_nm + '_nm'
   ,@sep             NVARCHAR(1)    = NULL -- null then single value field
   ,@tot_cnt         INT            = NULL OUTPUT
   ,@display_tables  BIT            = 1
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)    = N'sp_fnd_unregistered_dyndta_hlpr'
   ,@nl              NVARCHAR(2)    = NCHAR(13)+NCHAR(10)
   ,@sql             NVARCHAR(MAX)
   ,@sql_body        NVARCHAR(MAX)
   ,@cnt             INT
   ,@is_multi_value  BIT
   ;

   SET @cnt = 0;
   SET @is_multi_value = iif(@sep IS NULL, 0, 1);

-- 241210: handle multi value fields differently
-- There are 2 types of field in staging2
-- 1: single value fields like Company, Product, concentration, formulation_type,toxicity, reg,expiry
-- 2: multi  value fields like ingredient, uses, entry_mode, crops, pathogens
-- These need handling differently

   SET NOCOUNT ON;
   EXEC sp_log 2, @fn,'000: starting:
stg_field_nm  :[', @stg_field_nm  ,']
table_nm      :[', @table_nm      ,']
pk_table_nm   :[', @pk_table_nm   ,']
pk_field_nm   :[', @pk_field_nm   ,']
sep           :[', @sep           ,']
cnt           :[', @cnt           ,']
is_multi_value:[', @is_multi_value,']
display_tables:[', @display_tables,']
';

   -- Get the sql to find the unregistered items
   EXEC sp_log 1, @fn,'010: calling fnCrtFndUnregisterdItemsSql',@nl, @sql;
   SET @sql_body = dbo.fnCrtFndUnregisterdItemsSql(@is_multi_value ,@stg_field_nm, @table_nm, @pk_table_nm, @pk_field_nm, @sep);
   EXEC sp_log 1, @fn,'020: @sql_body:',@nl, @sql_body;

   IF @display_tables = 1
   BEGIN
      SET @sql = CONCAT('SELECT item AS [',@pk_table_nm,'] FROM ', @sql_body);
      EXEC sp_log 1, @fn,'030: @sql:',@nl, @sql;
      EXEC(@sql);
--      SET @cnt = @@ROWCOUNT;
   END
/*
   ELSE
   BEGIN
      SET @sql = CONCAT('SELECT @cnt = COUNT(*) FROM ', @sql_body);
      EXEC sp_log 1, @fn,'040: @sql:',@nl, @sql;
      EXEC sp_executesql @sql, N'@cnt INT OUT', @cnt OUT;
   END
*/
   -- R02: populate the dbo.UnregisteredItem table with the unregisterd item data
   SET @sql = CONCAT('INSERT INTO UnregisteredItem (unreg_item, [table]) 
SELECT item, ''',@pk_table_nm,''' FROM ',@sql_body);

   EXEC sp_log 1, @fn,'050: insert unreg sql:',@nl, @sql;
   EXEC(@sql);
   SET @cnt = @@ROWCOUNT;

   IF @tot_cnt IS NULL
      SET @tot_cnt = 0;

   SET @tot_cnt = @tot_cnt + @cnt;
   EXEC sp_log 1, @fn,'100: found ',@cnt, ' unregistered ', @stg_field_nm;
   EXEC sp_log 2, @fn,'999: leaving, @tot_cnt:', @tot_cnt, ' found ',@cnt, ' unregistered ', @stg_field_nm, ' items';
END
/*
TRUNCATE table AppLog;
EXEC test.test_031_sp_fnd_unregistered_dyndta_hlpr;
EXEC sp_appLog_display;
EXEC sp_appLog_display 'sp_fnd_unregistered_dyndta_hlp';
--==============================================================================
DECLARE @tot_cnt      INT;
EXEC sp_fnd_unmtchd_dyndta_hlpr 'Pathogen', 'pathogens', @tot_cnt=@tot_cnt OUT, @display_tables=0;
PRINT @tot_cnt;
EXEC sp_fnd_unmtchd_dyndta_hlpr 'Pathogen', 'pathogens', @tot_cnt=@tot_cnt OUT, @display_tables=1;
PRINT @tot_cnt;
--==============================================================================
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [dbo].[UnregisteredItem](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[unreg_item] [varchar](500) NULL,
	[table] [varchar](20) NULL,
 CONSTRAINT [PK_UnregisteredItem] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =================================================================================================
-- Author:      Terry Watts
-- Create date: 04-NOV-2024
-- Description: This rtn finds the unmatched dynamic data items derived from the LRAP
--
-- Details:  Once the S2 fixup has been completed we need to find any S2 data that 
--    is still not matched against the primary data.
--    The LRAP data is very dirty so we need some rigorous checks in place to filter bad data
--
-- Responsibilities:
-- R01: displays a list of unregisterd items in staging2 the given item table
-- R02: populate the dbo.UnregisteredItem table with the unregisterd item data
-- R03: logs message if unregistered items found : level 3, 'found <@cnt> unregistered <table_nm>';
--
-- Dynamic Tables that need checking for null references:
--    ChemicalStaging
--    ChemicalActionStaging
--    ChemicalProductStaging
--    ChemicalUseStaging
--    CompanyStaging
--    CropPathogenStaging
--    PathogenChemicalStaging
--    ProductCompanyStaging
--    ProductStaging
--    ProductUseStaging
--
-- PRECONDITIONS:
--    All static data loaded
--    S2 cleaned up
--    sp_pop_dynamic_data called
--
-- POSTCONDITIONS:
-- POST 01: RETURNS the total count of unregistered items
-- =================================================================================================
CREATE PROCEDURE [dbo].[sp_fnd_unregistered_dynamic_data]
AS
BEGIN
   DECLARE
    @fn        VARCHAR(35) = N'sp_fnd_unregistered_dynamic_data'
   ,@tot_cnt   INT = 0
   ,@was_error INT = 0
    ;

   SET NOCOUNT ON;
   EXEC sp_log 2, @fn,'000: starting';

   BEGIN TRY
      TRUNCATE TABLE UnregisteredItem;

      --------------------------------------------------------------------
      -- Validate preconditions
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn,'010: validating dynamic data populated';
      EXEC sp_fnd_unregistered_dyndta_chk_precndtns;

      --------------------------------------------------------------------
      -- Check for bad data in the LRAP extracted dynamic data tables
      -- to do this we need assocated primary static data from non LRAP sources
      -- E.G: Company, Crop, Pathogen, Use
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn,'010: checking for bad data in the LRAP extracted dynamic data tables';
      --   sp_fnd_unregistered_dyndta_hlpr @stg_field_nm @table_nm,  @pk_table_nm,@pk_field_nm, @sep, @tot_cnt, @display_tables
      EXEC sp_fnd_unregistered_dyndta_hlpr 'company'   ,'Staging2', 'Company'                             ,@sep = NULL,@tot_cnt = @tot_cnt OUT;
      EXEC sp_fnd_unregistered_dyndta_hlpr 'crops'     ,'Staging2', 'Crop'                                ,@sep = ',' ,@tot_cnt = @tot_cnt OUT;
      EXEC sp_fnd_unregistered_dyndta_hlpr 'pathogens' ,'Staging2', 'Pathogen'                            ,@sep = ',' ,@tot_cnt = @tot_cnt OUT;
    --EXEC @tot_cnt = sp_fndUnregPathogens;                                                                           
      EXEC sp_fnd_unregistered_dyndta_hlpr 'uses'      ,'Staging2', 'Use'                                 ,@sep = ',' ,@tot_cnt = @tot_cnt OUT;
      EXEC sp_fnd_unregistered_dyndta_hlpr 'entry_mode','Staging2', 'Action','action_nm'                  ,@sep = ',' ,@tot_cnt = @tot_cnt OUT;
   END TRY
   BEGIN CATCH
      SET @was_error = 1;
      EXEC sp_log 4, @fn,'500: caught exception';
      EXEC sp_log_exception @fn;
   END CATCH

   SELECT CONCAT('Total unregisterd count = ', @tot_cnt) AS [Total unregisterd count    .];
   SELECT * FROM UnregisteredItem;
   EXEC sp_log 2, @fn, '999: leaving, errors?: ',@was_error;
-- POST 01: RETURNS (0 and all data matched) or (1 and some data not matched with  the static data)
   RETURN @tot_cnt; -- iif(@tot_cnt = 0, 0, 1);
END
/*
TRUNCATE TABLE AppLog;
EXEC sp_fnd_unregistered_dynamic_data;
SELECT * FROM UnregisteredItem;
EXEC sp_appLog_display @dir=0;-- desc
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- ==================================================================================================================================================
-- Procedure:   dbo._main_import
-- Description: Main entry point for Importing 1 Ph DepAg LRAP (List of Registered Agructural Pesticides) file
-- Design     : EA: Model.Conceptual Model.LRAP Import
--            :     Model.Use Case Model.Import Lrap File (activity diagram)
--
-- Tests      : tSQLt.Run 'test.test_066__main_import'
-- Author:      Terry Watts
-- Create date: 20-JUNE-2023
-- Description: Main entry point for Importing all 9 100 page files Ph DepAg Registered Pesticides files
-- *** This cleans the staging tables first
-- import root = 'D:\Dev\Repos\<db name>\Data\'; use dbo.fnGetImportRoot() to get it
-- in <import root>\Exports Ph DepAg Registered Pesticides LRAP-221018.pdf\tsvs\ - 9 tsv files
-- or <import root>\Exports Ph DepAg Registered Pesticides LRAP-230721.pdf\      - 1 tsv file
--
-- PARAMETERS:
-- @stage            : coarse granularity progress cursor
-- @start_row (n)    : if set then corrections loop will skip the first n rows
-- @stop_row         : if set then all processing is stoped after this row is procesed
-- @restore_s3_s2    : used to load s2 with a previous s3 cache of S2
-- @log_level        : multi switch parameter currently lonly LOG LEVEL:  is used
-- @LRAP_data_file   : LRAP import data file
-- @corrections_file : the tab separated s2 corrections file
-- @import_id        : int this is the version of the import file: 1 for LRAP-221018
-- @stop_stage       : set this top processing after the specified stage
--
-- Responsibilities:
-- 01. Initialise
-- 02 Import primary static data from non LRAP sources (optional)
--
-- Preconditions: none
-- Postconditions:

-- Process for LRAP Import and scrub:
-------------------------------------------------------------------------------------------------------
-- Stage                                               Preconditions
-------------------------------------------------------------------------------------------------------
-- 01: Initialize (mandatory)                          none
-- 02: Import primary static data                      import_root specified
-- 03: Import the LRAP data                            import_root specified, LRAP file specified
-- 04: Do the S1 fixup                                 s1 pop
-- 05: Stage 5: Copy S1 to S2                          LRAP file imported
-- 06: Import the LRAP corrections files               import_root specified, LRAP file specified,cor files specified
-- 07: optionally restore s2 from S1 or S3 caches      none
-- 08: Scrub the imported LRAP fixup S2                Import corrections tbl pop
-- 09: Populate the dynamic data staging tables        fixup done
-- 10: Indentify the unmatched dynamic staging data    fixup done
-- 11: Copy S2 to the S3 cache                         LRAP file imported
-- 12: Merge Staging to Main                           fixup done
-- 13: Perform postcondition checks                    none
-------------------------------------------------------------------------------------------------------
--
-- CHANGES:
-- ==================================================================================================================================================
CREATE PROCEDURE [dbo].[_main_import]
    @import_root     VARCHAR(500)   = NULL
   ,@import_file     VARCHAR(500)   = NULL    -- exclude path, (and range if XL) assume in @import_root
   ,@cor_files       VARCHAR(500)   = NULL    -- coma sep list, file name only - assume in @import_root
   ,@start_stage     INT            = 0
   ,@stop_stage      INT            = 10
   ,@start_row       INT            = 1
   ,@stop_row        INT            = 100000
   ,@restore_s1_s2   BIT            = 0      -- Reset the state of Staging2 to the original LRAP import - useful when testing corrections
   ,@restore_s3_s2   BIT            = 0      -- Reset the state of Staging2 to the Fixed up version of S2 before the Corrections process
   ,@log_level       INT            = 1
   ,@import_eppo     BIT            = 0
   ,@display_tables  BIT            = 0
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)    = N'_main_import'
   ,@cnt             INT            = 0
   ,@error_msg       VARCHAR(500)   = ''
   ,@file_cnt        INT
   ,@fixup_cnt       INT            = 0
   ,@first_time      BIT            = 1
   ,@import_id       INT            = NULL
   ,@line2           VARCHAR(200)   = REPLICATE('*', 200)
   ,@msg             VARCHAR(500)   = ''
   ,@nl              VARCHAR(2)     = NCHAR(13)
   ,@options         INT
   ,@RC              INT            = 0
   ,@result_msg      VARCHAR(500)   = ''
   ,@row_cnt         INT            = 0
   ,@sql             VARCHAR(MAX)
   ,@stage_id        INT            = 1   -- current stage
   ,@status          INT
   ;

   -----------------------------------------------------------------------------------
   -- 00: Clear the applog
   -----------------------------------------------------------------------------------

   EXEC sp_log 2, @fn,'000: starting:
import_root:   [', @import_root,   ']
import_file:   [', @import_file,   ']
cor_files:     [', @cor_files,     ']
start_stage:   [', @start_stage,   ']
stop_stage:    [', @stop_stage,    ']
start_row:     [', @start_row,     ']
stop_row:      [', @stop_row,      ']
restore_s3_s2: [', @restore_s3_s2, ']
log_level:     [', @log_level,     ']
log_level:     [', @log_level,     ']
';

   SET NOCOUNT OFF;
   SET XACT_ABORT ON;

   BEGIN TRY
      SET NOCOUNT OFF;
      SET XACT_ABORT ON;

      WHILE 1=1
      BEGIN
         -------------------------------------------------------------------------------------------
         -- Stage 01: Initialise (always performed)
         -------------------------------------------------------------------------------------------
         -- Preconditions: none
         EXEC sp_log 1, @fn,'010: initialising, calling sp_main_import_init';

         -- 241230: Notes to get the modified parameters query the state tables Importstate and Corfiles
         EXEC sp_mn_imprt_ini
          @import_root    = @import_root      -- have import root suffix when output
         ,@import_file    = @import_file -- LRAP import file
         ,@cor_files      = @cor_files       -- must be specified if stage < 5
         ,@start_stage    = @start_stage
         ,@stop_stage     = @stop_stage
         ,@start_row      = @start_row
         ,@stop_row       = @stop_row
         ,@restore_s1_s2  = @restore_s1_s2  -- Reset the state of Staging2 to the original LRAP import - useful when testing corrections
         ,@restore_s3_s2  = @restore_s3_s2  -- Reset the state of Staging2 to the Fixed up version of S2 before the Corrections process
         ,@log_level      = @log_level
         ,@import_eppo    = @import_eppo
         ;

         SELECT
             @import_root    = import_root     -- have import root suffix when output
            ,@import_file    = import_file      -- LRAP import file
            ,@cor_files      = cor_files       -- must be specified if stage < 5
            ,@start_stage    = start_stage
            ,@stop_stage     = stop_stage
            ,@start_row      = start_row
            ,@stop_row       = stop_row
            ,@restore_s1_s2  = restore_s1_s2  -- Reset the state of Staging2 to the original LRAP import - useful when testing corrections
            ,@restore_s3_s2  = restore_s3_s2  -- Reset the state of Staging2 to the Fixed up version of S2 before the Corrections process
            ,@log_level      = log_level
            ,@import_eppo    = import_eppo
            ,@import_id      = import_id
         FROM Importstate
         WHERE id = 1;

         -- Stage 1: Postconditions: (which become the prconditions for the next stage)
         -- all init done for the given stage
         -- Tables pop: CallRegister
         -- Tables clrd: AppLog,CallRegister,CorrectionLog,S2UpdateLog,S2UpdateSummary
         EXEC sp_log 1, @fn,'020: ret frm sp_main_import_init, @import_id: ', @import_id;

         -- *** Register this call only after sp_main_import_init has configured the call register
         --EXEC sp_register_call @fn;

         IF @stage_id >= @stop_stage BREAK;

         -------------------------------------------------------------------------------------------
         -- Stage 2: Import static data
         -------------------------------------------------------------------------------------------
         IF @start_stage <= 2
         BEGIN
            EXEC sp_log 2, @fn,'030: Stage 02: import static data';
            SET @stage_id = 2;
            --EXEC LRAP_Imprt_S02_ImprtStaticData @import_eppo = @import_eppo;
            EXEC sp_import_static_data @import_root, @display_tables, @import_eppo;
         END

         -- Stage 2: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         ----------------------------------------------------------------------------------------------------------
         -- Stage 03: Import the LRAP data
         ----------------------------------------------------------------------------------------------------------
         IF @start_stage <= 3
         BEGIN
            SET @stage_id = 3; -- go directly to import corrections

            IF @restore_s3_s2 = 0
            BEGIN
               -- Import the LRAP data and do the S1 fixup
               EXEC sp_log 2, @fn,'040: Stage 03: import LRAP data';
               EXEC sp_import_LRAP_file @import_file, @import_id;
            END
         END

         -- Stage 3: Postconditions: Staging1 pop'd
         IF @stage_id >= @stop_stage BREAK;

         -----------------------------------------------------------------------------------
         -- 04: Do the S1 fixup
         -----------------------------------------------------------------------------------
         IF @start_stage <= 4
         BEGIN
            EXEC sp_log 2, @fn,'050: Stage 04: fixup S1';
            SET @stage_id = 4;
            EXEC sp_fixup_s1 @fixup_cnt = @fixup_cnt OUT;
         END

         -- Stage 4: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         ---------------------------------------------------------------------------------------
         -- 05: Stage 5: Copy S1 to S2
         ---------------------------------------------------------------------------------------
         IF @start_stage <= 5
         BEGIN
            EXEC sp_log 2, @fn,'060: Stage 05: copy s1 -> s2';
            SET @stage_id = 5;
            EXEC sp_cpy_s1_s2;
         END

         -- Stage 5: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         ---------------------------------------------------------------------------------------
         -- 06: Import the LRAP corrections files
         ---------------------------------------------------------------------------------------
         IF @start_stage <= 6
         BEGIN
            EXEC sp_log 2, @fn,'050: Stage 06 Import the LRAP corrections file';
            SET @stage_id = 6;
            EXEC sp_import_cor_files @tot_cnt = @row_cnt OUT, @file_cnt=@file_cnt OUT;
            EXEC sp_log 2, @fn,'060: Stage 06 Imported ',@row_cnt,' rows from ',@file_cnt,' cor files';
         END

         -- Stage 6: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         ---------------------------------------------------------------------------------------
         -- 07: optionally restore s2 from either S1 or S3 cache cache
         ---------------------------------------------------------------------------------------
         IF @start_stage <= 7
         BEGIN
            SET @stage_id = 7;

            IF @restore_s1_s2 = 1
            BEGIN
               EXEC sp_log 2, @fn,'070. stage 07.1: optionally restore s2 from either S1 or S3 cache cache';
               EXEC sp_cpy_s1_s2;
            END
            ELSE IF @restore_s3_s2 = 1
            BEGIN
               EXEC sp_log 2, @fn,'080. stage 07.2:restore s2 from the S3 cache';
               EXEC sp_cpy_s3_s2;
            END
         END

         -- Stage 7: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         -----------------------------------------------------------------------------------
         -- 08: Scrub the imported LRAP source table data i.e. fixup S2
         -----------------------------------------------------------------------------------
         IF @start_stage <= 8
         BEGIN
            SET @stage_id = 8;
            EXEC sp_log 2, @fn,'090: Stage 08: S2 fixup';

            EXEC @rc = sp_fixup_S2
                @start_row = @start_row
               ,@stop_row  = @stop_row
               ,@row_count = @row_cnt   OUT
               ,@fixup_cnt = @fixup_cnt OUT
               ;
         END

         -- Stage 8: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         -----------------------------------------------------------------------------------
         -- 09: Populate the dynamic data staging tables (mandatory)
         -----------------------------------------------------------------------------------
         IF @start_stage <= 9
         BEGIN
            SET @stage_id = 9;
            EXEC sp_log 2, @fn,'100: Stage 09: Populate dynamic data staging tables';
            EXEC sp_pop_dynamic_data;
         END

         -- Stage 9: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         -----------------------------------------------------------------------------------
         -- 10: Indentify the unmatched dynamic staging data
         --     items not found in the primary static data
         --     Like Pathogens, Crops, Company, Ingredient, Entry mode (mandatory)
         -----------------------------------------------------------------------------------
         IF @start_stage <= 10
         BEGIN
            SET @stage_id = 10;
            EXEC sp_log 2, @fn,'110: Stage 10: indentify and display a list of the unmatched dynamic staging data items not found in the primary static data';
            EXEC @rc = sp_fnd_unregistered_dynamic_data;

            IF @rc<> 0
            BEGIN
               -------------------------------------------------------------------------------------------------------------------------------------
               -- Manual process: build XL correction sheets for these anomalies and repeat eimport rom Stage 04: Import the LRAP corrections files
               -------------------------------------------------------------------------------------------------------------------------------------
               EXEC sp_log 3, @fn,'120 There are ',@rc,' unmatched unmatched dynamic staging data items not found in the primary static data';
               EXEC sp_log 3, @fn,'130: Fix and re-import from Stage 04: Import the LRAP corrections files';

               -- 241218: continue for now so we can test what we have
               -- make a copy of S3 now for test prurposes
               -- EXEC sp_cpy_s2_s3;
               -- BREAK;
            END
         END

         -- Stage 10: Postconditions: no unmatched dynamic reference staging data
         IF @stage_id >= @stop_stage BREAK;

         ---------------------------------------------------------
         -- ASSERTION no unmatched dynamic reference staging data
         ---------------------------------------------------------

         -----------------------------------------------------------------------------------
         -- 11: Copy S2 to the S3 cache
         -----------------------------------------------------------------------------------
         IF @start_stage <= 11
         BEGIN
            ---------------------------------------------------------------------------
            -- 08: Copy S2 to S3 so that S3 holds the fixed up S2
            -- this can be used for re-entrant fixup when modifying the corrections files
            -- and to create the test data stored is test.s2_tst, and  test.s2_tst_bak
            -- that is used by sp_gen_tst_dta_S2_tst
            ----------------------------------------------------------------------------
            SET @stage_id = 11;
            EXEC sp_log 2, @fn,'140: Stage 11: copy s2->s3';
            EXEC sp_cpy_s2_s3;
         END

         -- Stage 11: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         --------------------------------------------------------------------------------------
         -- 12: Merge the dynamic data staging to their respective main tables 
         --------------------------------------------------------------------------------------
         IF @start_stage <= 12
         BEGIN
            SET @stage_id = 12;
            EXEC sp_log 2, @fn,'150: Stage 12: merge the main tables';
            EXEC LRAP_Imprt_S09_merge_mn; -- @correction_file_path_inc_rng= @cor_file;
         END

         -- Stage 12: Postconditions:
         IF @stage_id >= @stop_stage BREAK;

         -----------------------------------------------------------------------------------
         -- 13: Perform postcondition checks
         -----------------------------------------------------------------------------------
         IF @start_stage <= 13
         BEGIN
            SET @stage_id = 13;
            EXEC sp_log 2, @fn,'160: Stage 13: postcondition checks';
            EXEC sp_mn_imprt_stg_12_post_cks @import_eppo;
         END

         -----------------------------------------------------------------------------------
         -- Completed processing
         -----------------------------------------------------------------------------------
         EXEC sp_log 2, @fn,'800: completed processing OK';

         -- Stage 13: Postconditions:
         BREAK;
         END -- WHILE 1=1 main loop
   END TRY
   BEGIN CATCH
      PRINT CONCAT(@nl, @line2);
      EXEC sp_log_exception @fn, ' 550: @stage_id: ', @stage_id;
      PRINT CONCAT(@line2, @nl);
      THROW;
   END CATCH

   SET @stage_id = 99;
   EXEC sp_log 2, @fn, '999: leaving, stage: ', @stage_id, ' ret: ', @RC, @row_count=@fixup_cnt;
   RETURN @RC;
END
/*
-- 01: Full import from initialization to ImportCorrections_221018-Pathogens_A-C.txt
EXEC _main_import
    @start_stage=1
   ,@import_file='LRAP-221018.txt'
   ,@import_root='D:\Dev\Farming\Data'
   ,@cor_files = 'ImportCorrections_221018-Crops.txt';

--   ,@cor_files = 'ImportCorrections_221018-PreFixup.txt,ImportCorrections_221018-Company.txt,ImportCorrections_221018-Crops.txt,ImportCorrections_221018-Entry_mode.txt,ImportCorrections_221018-Product.txt,ImportCorrections_221018-Uses.txt,ImportCorrections_221018-Pathogens_A-C.txt';
;

--****************************************************************************************************************************
   -- uncache s1-> s2, and import the cor files up to and inc crops
   -- 06: Import the LRAP corrections files from crops fixup and on

EXEC _main_import @start_stage=6, @restore_s1_s2 = 1, @import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections_221018-Entry_mode.txt,ImportCorrections_221018-Product.txt,ImportCorrections_221018-Uses.txt,ImportCorrections_221018-Crops.txt' --,ImportCorrections_221018-Entry_mode.txt,ImportCorrections_221018-Product.txt,ImportCorrections_221018-Uses.txt,ImportCorrections_221018-Pathogens_A-C.txt,ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';
--****************************************************************************************************************************


-- 06: Import the LRAP corrections files from up not including pathogens
-- assumes previous fixup has been done
EXEC _main_import @start_stage=8, @restore_s1_s2 = 1,@import_root='D:\Dev\Farming\Data'
,@cor_files = 'ImportCorrections_221018-Crops.txt';--,ImportCorrections_221018-Entry_mode.txt,ImportCorrections_221018-Product.txt,ImportCorrections_221018-Uses.txt';

--******************************************************************************************************************************************************************
-- 06: Import the LRAP corrections files ImportCorrections_221018-crops
-- assumes previous fixup has been done
EXEC _main_import @start_stage=6, @import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections_221018-Entry_mode.txt,ImportCorrections_221018-Uses.txt';
--******************************************************************************************************************************************************************

EXEC _main_import @start_stage=6, @import_file='LRAP-221018.txt',@import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections_221018-Company.txt,ImportCorrections_221018-Pathogens_A-C.txt';

-- 06: Import the LRAP corrections files ImportCorrections_221018-Pathogens_A-C.txt only
-- assumes previous fixup has been done
EXEC _main_import @start_stage=6, @import_file='LRAP-221018.txt',@import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections_221018-Company.txt';
EXEC _main_import @start_stage=6, @import_file='LRAP-221018.txt',@import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections_221018-Company.txt,ImportCorrections_221018-Pathogens_A-C.txt';

-- 06: Import the LRAP corrections files ImportCorrections_221018-Pathogens_D-M.txt only
-- assumes previous fixup has been done includin ImportCorrections_221018-Pathogens_A-C.txt
EXEC _main_import @start_stage=6,@stop_row=20,@import_file='LRAP-221018-2.txt',@import_root='D:\Dev\Farming\Tests\test_066',@cor_files = 'ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';

EXEC _main_import @start_stage=6,@import_file='LRAP-221018.txt',@import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections.PreFixup 221018.txt,ImportCorrections_221018-Pathogens_A-C.txt,ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';
-- pre conditions: ImportCorrections.PreFixup 221018.tx,,ImportCorrections 221018.txt imported
EXEC _main_import @start_stage=6,@stop_row=20,@import_file='LRAP-221018-2.txt',@import_root='D:\Dev\Farming\Tests\test_066',@cor_files = 'ImportCorrections_221018-Pathogens_A-C.txt,ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';

-- 02: Import primary static data
EXEC _main_import @start_stage=2, @import_eppo = true, @import_file='LRAP-221018.txt',@import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections.PreFixup 221018.txt,ImportCorrections_221018-Pathogens_A-C.txt,ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';

-- 03: Import the LRAP data
EXEC _main_import @start_stage=3, @import_eppo= 0,@import_file='LRAP-221018.txt',@import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections.PreFixup 221018.txt,ImportCorrections_221018-Pathogens_A-C.txt,ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';

-- 04: Do the S1 fixup
EXEC _main_import @start_stage=4, @import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections.PreFixup 221018.txt,ImportCorrections_221018-Pathogens_A-C.txt,ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';

-- 05: Stage 5: Copy S1 to S2
EXEC _main_import @start_stage=5, @import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections.PreFixup 221018.txt,ImportCorrections_221018-Pathogens_A-C.txt,ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';

-- 06: Import the LRAP corrections files and restore S2 from S1
EXEC _main_import @start_stage=6,@restore_s1_s2=1;, @import_root='D:\Dev\Farming\Data',@cor_files = 'ImportCorrections.PreFixup 221018.txt,ImportCorrections_221018-Pathogens_A-C.txt,ImportCorrections_221018-Pathogens_D-M.txt,ImportCorrections_221018-Pathogens-N-Z.txt';

-- 07: optionally restore s2  from either S1 or S3 cache cache
EXEC _main_import @start_stage=7;

-- 08: fixup S2, using S1 and the exisitng import corrections
EXEC _main_import @start_stage=8,@restore_s1_s2=1;

-- 09: Populate the dynamic data staging tables
EXEC _main_import @start_stage=9;

-- 10: Indentify the unmatched dynamic staging data
EXEC _main_import @start_stage=10

-- 11: Copy S2 to the S3 cache
EXEC _main_import @start_stage=11;

-- 12: Merge Staging to Main
EXEC _main_import @start_stage=12;

-- 13: Perform postcondition checks
EXEC _main_import @start_stage=13;

EXEC tSQLt.RunAll;
EXEC test.sp__crt_tst_rtns ' [dbo].[_main_import]', @trn=67, @ad_stp=1
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

-- =============================================
-- Author:      Terry Watts
-- Create date: 08-FEB-2020
-- Description: checks if table exists 
--    if not throws @ex_num=62250, @ex_msg= '[<table spec>] does not exist.'
-- Parameters:
-- @table_spec <db>.<schema>.<table> or <table>
-- @ex_num default @ex_num=62250
-- @ex_msg default is '[<table spec>] does not exist.'
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_table_exists]
    @table_spec   VARCHAR(60)    -- LIKE dbo.
   ,@ex_num       INT            = NULL OUT
   ,@ex_msg       VARCHAR(500)   = NULL OUT
   ,@fn           VARCHAR(60)    = N'*'
   ,@log_level    INT            = 0
AS
BEGIN
   DECLARE
       @fnThis    VARCHAR(35)   = N'sp_assert_table_exists'
      ,@schema_nm VARCHAR(20)
      ,@table_nm  VARCHAR(60)
      ,@sql       VARCHAR(200)
      ,@n         INT
      ,@exists    BIT

   EXEC sp_log @log_level, @fnThis, '000: starting,
@table_spec:[',@table_spec,']
@ex_num:    [',@ex_num,']
@ex_msg:    [',@ex_msg,']'
;

   IF @ex_num IS NULL SET @ex_num = 62250;
   IF @ex_msg IS NULL SET @ex_msg = CONCAT('[',@table_spec,'] does not exist.');

   IF dbo.fnTableExists(@table_spec) = 0
   BEGIN
      EXEC sp_raise_exception @ex_num, @ex_msg, @fn=@fn;
   END

   EXEC sp_log @log_level, @fnThis, '010: table exists';
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_036_sp_chk_table_exists';
*/

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [test].[RtnDetails](
	[qrn] [varchar](90) NULL,
	[schema_nm] [varchar](60) NULL,
	[rtn_nm] [varchar](60) NULL,
	[trn] [int] NULL,
	[cora] [nchar](1) NULL,
	[ad_stp] [bit] NULL,
	[tst_mode] [bit] NULL,
	[stop_stage] [int] NULL,
	[rtn_ty] [varchar](2) NULL,
	[rtn_ty_code] [varchar](2) NULL,
	[is_clr] [bit] NULL,
	[tst_rtn_nm] [varchar](50) NULL,
	[hlpr_rtn_nm] [varchar](50) NULL,
	[max_prm_len] [int] NULL,
	[sc_fn_ret_ty] [varchar](20) NULL,
	[prm_cnt] [int] NULL,
	[display_tables] [bit] NULL
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO

CREATE TABLE [test].[HlprDef](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[line] [varchar](4000) NULL,
 CONSTRAINT [PK_test.HlprDef] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==============================================================================
-- Author:      Terry Watts
-- Create date: 16-AUG-2023
-- Description: displays the import/update audit
--
-- CHANGES:
--
-- ==============================================================================
CREATE   VIEW [dbo].[audit_vw] AS
SELECT TOP 10000 *
FROM
(
SELECT distinct ids, X.cor_id, old, new, search_clause, replace_clause, not_clause, row_cnt 
FROM
(
SELECT STRING_AGG(id, ',') as ids, cor_id --, old, new, search_clause, replace_clause, not_clause, row_cnt, cor_rnk 
FROM
(
SELECT id, stg_id, cor_id, old, new, search_clause, replace_clause, not_clause, row_cnt
,row_number() over (partition by cor_id order by id) as cor_rnk
FROM  CorrectionLog
) ranks
where cor_rnk<100
group by cor_id --, old, new, search_clause, replace_clause, not_clause, row_cnt, cor_rnk  
) X
JOIN CorrectionLog cl ON X.cor_id = cl.cor_id 
) Y
order by y.cor_id;
/*
SELECT TOP 50 * FROM audit_vw;
*/


GO
SET ANSI_NULLS ON

SET QUOTED_IDENTIFIER ON

GO


-- ==================================================================================
-- Author:      Terry Watts
-- Create date: 07-OCT-2023
-- Description: lists the products and their associated chemicals from the main tables
--
-- ==================================================================================
CREATE   VIEW [dbo].[ChemicalProduct_vw]
AS
SELECT TOP 100000 c.chemical_nm, p.product_nm, c.chemical_id, p.product_id
FROM ChemicalProduct cp
LEFT JOIN Product  p ON p.product_id  = cp.product_id 
LEFT JOIN Chemical c ON c.chemical_id = cp.chemical_id
ORDER BY chemical_nm, product_nm
/*
SELECT chemical_nm, product_nm FROM ChemicalProduct_vw WHERE product_nm liKE '%Brodan 31.5 Ec%'
SELECT chemical_nm, product_nm FROM ChemicalProduct_vw WHERE product_nm liKE '%Heneral 31.5 Ec%'
SELECT chemical_nm, product_nm FROM ChemicalProduct_vw WHERE chemical_nm IN ('Chlorpyrifos','Dimethoate','Thiamethoxam','Lambda Cyhalothrin')
SELECT * FROM Staging1 where product LIKE '%Brodan%'
*/


GO
GO

CREATE TYPE [tSQLt].[Private]
EXTERNAL NAME [tSQLtCLR].[tSQLtCLR.tSQLtPrivate]

GO
GO

CREATE TYPE [dbo].[MyDataType] FROM [varchar](500) NULL

GO
GO

CREATE TYPE [dbo].[IdNmTbl] AS TABLE(
	[id] [int] IDENTITY(1,1) NOT NULL,
	[val] [varchar](4000) NULL,
	PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (IGNORE_DUP_KEY = OFF)
)

GO
